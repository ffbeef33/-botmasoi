from dotenv import load_dotenv
import os

load_dotenv()
import discord
from discord.ext import commands
from discord import app_commands
import random
import asyncio
import logging
import sys
import traceback
import inspect
from collections import deque
import gspread
from oauth2client.service_account import ServiceAccountCredentials
import mysql.connector

def get_db_connection():
    return mysql.connector.connect(
        host=os.getenv("MYSQL_HOST"),
        port=os.getenv("MYSQL_PORT"),
        user=os.getenv("MYSQL_USER"),
        password=os.getenv("MYSQL_PASSWORD"),
        database=os.getenv("MYSQL_DATABASE"),
        charset='utf8mb4',
        collation='utf8mb4_unicode_ci'
    )

# Cấu hình logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Log hoạt động vai trò
game_logs = {}
game_states = {}

# Thiết lập Google Sheets
#scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
#creds = ServiceAccountCredentials.from_json_keyfile_name("credentials.json", scope)
#client = gspread.authorize(creds)
#spreadsheet = client.open("Ma Soi Leaderboard")

# Thêm URL của các GIF
GIF_URLS = {
    "morning": "https://cdn.discordapp.com/attachments/1365707789321633813/1372115998525620335/Phase_day.gif?ex=68259a1a&is=6824489a&hm=c01364ba79cba7d7aed13a993a24850c2e0d17a2cf27af95a95389789d79a7a6&",
    "night": "https://cdn.discordapp.com/attachments/1365707789321633813/1372117342380621855/Phase_night.gif?ex=68259b5b&is=682449db&hm=1bafb461bb02b41ed95b43de2753d09254bed7bd052bbf5d2136f397f89850b0&",
    "hang": "https://cdn.discordapp.com/attachments/1365707789321633813/1372117715707232266/Phase_deadbyvote.gif?ex=68259bb4&is=68244a34&hm=6cb3e2864efd785a39be137defbcc2fe4a27636a83b80192602bc378a95666e7&",
    "vote": "https://cdn.discordapp.com/attachments/1365707789321633813/1372117883957678080/Phase_vote.gif?ex=68259bdc&is=68244a5c&hm=1c16c879de3730319169681f6325fced29953b63d688433c9baa0b44dc683ef7&",
    "villager_win": "https://cdn.discordapp.com/attachments/1365707789321633813/1372118299856474184/Phase_humanwin.gif?ex=68259c3f&is=68244abf&hm=64f37b2b28a0790a990469bf14c6bcddf36b438629c1902b21d8ab425f6c2f5d&",
    "werewolf_win": "https://cdn.discordapp.com/attachments/1365707789321633813/1372118396673458217/Phase_wolfwin.gif?ex=68259c56&is=68244ad6&hm=e1e53652db3548081e3e3a5ea419ff785d7e1e434cd168284da334682e1083e6&",
    "death": "https://cdn.discordapp.com/attachments/1365707789321633813/1372118623287509002/Phase_deadbynight.gif?ex=68259c8c&is=68244b0c&hm=ea2f732c04d7bae102f00612f75c81ec5b0c54db7a65ea4f034cdd4626ff0c1a&"  # URL GIF thực tế cho thông báo người chết
}

# Thêm URL của các hình ảnh icon cho vai trò
ROLE_ICONS = {
    "Villager": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853615445676143/villager-512.png?ex=68284910&is=6826f790&hm=21ba4ed9e3293b568f09edf5861a92f5472c11cef09db470c9400e813cf9c180&",
    "Werewolf": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853692226736128/werewolf-512.png?ex=68284922&is=6826f7a2&hm=f931eea427ae3a00a1a2c7f8cf38b41d3c3fa77774b3ff262c031eedf687e1c5&",
    "Seer": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853452555943966/seer-512.png?ex=682848e9&is=6826f769&hm=98e371c02b99c848a39c3267f14eb166bcf4c5a687ed9a9e24f39e35e5900afd&",
    "Guard": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853215065931867/guard-512.png?ex=682848b0&is=6826f730&hm=afc74125559a3d35912aae771c4d8391efedba4d261e6d3935d91b54648c320f&",
    "Witch": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853774682558514/witch-512.png?ex=68284936&is=6826f7b6&hm=1491fa773b223745034fd88a86409bbe99754a4a19afe1573f176ef05912fb50&",
    "Hunter": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853304211669054/hunter-512.png?ex=682848c6&is=6826f746&hm=2c6a8b0968442879facea46e89b417a234922ea4ff3a7791b5fb76d50ba34726&",
    "Tough Guy": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853538669199390/touchguy-512.png?ex=682848fe&is=6826f77e&hm=e4d44f6a9993361f46469fb9b2b91f642efab2032697eaf8b4eb9c976e7ce936&",
    "Illusionist": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853384280805446/illusionist-512.png?ex=682848d9&is=6826f759&hm=bbb99c57d8fd36b0cd88babbfc8c9309a31d8c88fd36993740df0a96732db975&",
    "Wolfman": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853876017070120/wolfman-512.png?ex=6828494e&is=6826f7ce&hm=eb72a7ed9bc15e33982364aa2aef1113916038ebac81a8beed94b69ccf8ae0db&",
    "Explorer": "https://cdn.discordapp.com/attachments/1365707789321633813/1372852429489704960/explorer-512.png?ex=682847f5&is=6826f675&hm=c799a97a59fe90b3dfa62804b4ff38f964502ad06e20eea9097174742efa4e78&",
    "Demon Werewolf": "https://cdn.discordapp.com/attachments/1365707789321633813/1372852300435034122/demonwolf-512.png?ex=682847d6&is=6826f656&hm=0f6bf383e2d72d73fb7b0a98ffb5c9cebbf6444fcb9aa16903eba37a66e74424&",
    "Assassin Werewolf": "https://cdn.discordapp.com/attachments/1365707789321633813/1374432785833394186/assassinwolf-512.png?ex=682e07c7&is=682cb647&hm=191deea5033471f7fb2ec86f7a59ebd4f8259a1c53f9e61ac0a5d52593a375a3&",  # Tạm dùng icon Werewolf
    "Detective": "https://cdn.discordapp.com/attachments/1365707789321633813/1374694217527463956/detective-512_2.png?ex=682efb42&is=682da9c2&hm=1763595fbe72496342badea2b85a262c961a7ab05971ba8d036b2fd6a033985b&"
}

# Khởi tạo bot
intents = discord.Intents.all()
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)
#spreadsheet = client.open("Ma Soi Leaderboard")

# Danh sách vai trò và mô tả
ROLES = ["Villager", "Werewolf", "Seer", "Guard", "Witch", "Hunter", "Tough Guy", "Illusionist", "Wolfman", "Explorer", "Demon Werewolf", "Assassin Werewolf", "Detective"]
VILLAGER_SPECIAL_ROLES = ["Seer", "Guard", "Witch", "Hunter", "Tough Guy", "Explorer","Detective"]
WEREWOLF_SPECIAL_ROLES = ["Illusionist", "Wolfman", "Demon Werewolf", "Assassin Werewolf"]
VILLAGER_ROLES = ["Villager", "Seer", "Guard", "Witch", "Hunter", "Tough Guy", "Explorer", "Detective"]
WEREWOLF_ROLES = ["Werewolf", "Illusionist", "Wolfman", "Demon Werewolf", "Assassin Werewolf"]
NO_NIGHT_ACTION_ROLES = ["Villager", "Tough Guy", "Illusionist"]

ROLE_DESCRIPTIONS = {
    "Villager": "Không có chức năng đặc biệt, tham gia thảo luận và bỏ phiếu ban ngày (từ ngày thứ hai). Phải chọn đáp án đúng trong bài toán cộng/trừ vào ban đêm để được quyền bỏ phiếu.",
    "Werewolf": "Mỗi đêm thảo luận trong wolf-chat và chọn giết 1 người bằng nút chọn. Biết ai là Nhà Ảo Giác (nếu có).",
    "Seer": "Mỗi đêm kiểm tra 1 người thuộc phe Dân hoặc Sói bằng nút chọn qua DM. Kết quả có thể bị đảo ngược nếu Nhà Ảo Giác bị soi trước đó.",
    "Guard": "Mỗi đêm bảo vệ 1 người bằng nút chọn qua DM, ngăn họ bị giết bởi Sói, Phù Thủy hoặc Thợ Săn.",
    "Witch": "Mỗi đêm biết ai bị chọn giết, có 1 lần duy nhất để cứu bằng nút 'Save' hoặc giết 1 người bằng nút chọn qua DM. Nhận thông báo muộn hơn để quyết định trong 20 giây cuối. Sau khi sử dụng chức năng, sẽ không còn nhận thông tin về người bị giết và nhận thông báo 'Không ai bị giết đêm nay!' mỗi đêm.",
    "Hunter": "Có 1 lần duy nhất trong đêm để giết 1 người bằng nút chọn qua DM.",
    "Tough Guy": "Thuộc phe Dân, có 2 mạng đối với các hành động giết vào ban đêm (Sói, Phù Thủy, Thợ Săn). Phải bị giết 2 lần vào ban đêm để chết hoàn toàn. Không có thông báo khi mất mạng. Tuy nhiên, nếu bị ngồi ghế điện (loại bởi bỏ phiếu ban ngày), sẽ chết ngay lập tức bất kể còn bao nhiêu mạng. Phải chọn đáp án đúng trong bài toán cộng/trừ vào ban đêm để được quyền bỏ phiếu.",
    "Illusionist": "Thuộc phe Sói, thắng cùng Sói nhưng không thức dậy trong wolf-chat và không biết ai là Sói. Sói biết Nhà Ảo Giác. Được tính vào Phe Dân khi kiểm đếm thắng thua. Nếu bị Tiên Tri soi, ra Phe Dân. Đêm tiếp theo, kết quả soi của Tiên Tri bị đảo ngược (Dân thành Sói, Sói thành Dân). Phải chọn đáp án đúng trong bài toán cộng/trừ vào ban đêm để được quyền bỏ phiếu.",
    "Wolfman": "Thuộc phe Sói, thức dậy cùng bầy Sói trong wolf-chat và tham gia chọn giết. Được tính là Sói khi kiểm đếm thắng thua. Nếu bị Tiên Tri soi, hiển thị thuộc Phe Dân.",
    "Explorer": "Từ đêm thứ hai, mỗi đêm phải chọn giết một người qua DM. Nếu chọn đúng Sói (không tính Nhà Ảo Giác), Sói sẽ chết. Nếu chọn trúng Phe Dân (tính cả Nhà Ảo Giác), Người Khám Phá sẽ chết. Có thể được bảo vệ bởi Bảo Vệ và cứu bởi Phù Thủy theo nguyên tắc game.",
    "Demon Werewolf": "Thuộc phe Sói, thức dậy cùng bầy Sói. Khi một Sói bất kỳ chết, Sói Quỷ có thể nguyền một người chơi duy nhất qua DM, biến họ thành Sói vào đêm tiếp theo. Người bị nguyền mất chức năng cũ và tham gia bầy Sói, ảnh hưởng đến kiểm đếm thắng thua. Trong đêm nguyền, mục tiêu của bầy Sói không chết.",
    "Assassin Werewolf": "Thuộc phe Sói, thức dậy cùng bầy Sói và tham gia chọn giết. Có một lần duy nhất trong game để chọn một người chơi và đoán vai trò của họ vào ban đêm. Nếu đoán đúng, người đó chết; nếu sai, Sói Ám Sát chết. Sói Ám Sát sẽ không ám sát được Dân Làng",
    "Detective": "Một lần duy nhất trong game, vào ban đêm, thám tử có thể chọn hai người chơi để xem họ có cùng phe hay không. Ảo giác và người sói được tính vào phe sói. Thám tử không thể tự chọn chính mình."
}

# Định nghĩa các đường link cho từng vai trò
ROLE_LINKS = {
    "Villager": "https://www.dewolfvie.net/vn/chucnang#h.72xuy5mwxslh",
    "Werewolf": "https://www.dewolfvie.net/vn/chucnang#h.hvhyxzcxp8ha",
    "Seer": "https://www.dewolfvie.net/vn/chucnang#h.2s0avvgyr6t9",
    "Guard": "https://www.dewolfvie.net/vn/chucnang#h.ne683ss63imm",
    "Witch": "https://www.dewolfvie.net/vn/chucnang#h.jb8i4v8ruvpi",
    "Hunter": "https://www.dewolfvie.net/vn/chucnang#h.30wa7yki033k",
    "Tough Guy": "https://www.dewolfvie.net/vn/chucnang#h.8ofxyfsrchwy",
    "Illusionist": "https://www.dewolfvie.net/vn/chucnang#h.22uhems1a6om",
    "Wolfman": "https://www.dewolfvie.net/vn/chucnang#h.4vfb9srnjzej",
    "Explorer": "https://www.dewolfvie.net/vn/chucnang#h.5n2k068a52q0",
    "Demon Werewolf": "https://www.dewolfvie.net/vn/chucnang#h.ln7finvlqa8r",
    "Assassin Werewolf": "https://www.dewolfvie.net/vn/chucnang#h.w0d62d7aiqjw",
    "Detective": "https://www.dewolfvie.net/vn/chucnang#h.g8we49sefmk"
}

# Nhận định role cho detective
def get_player_team(role):
    if role in ["Illusionist", "Wolfman", "Werewolf", "Demon Werewolf", "Assassin Werewolf"]:
        return "werewolves"
    elif role in VILLAGER_ROLES:
        return "villagers"
    else:
        return "unknown"
      
# Đường dẫn đến các tệp âm thanh
AUDIO_FILES = {
    "morning": "day_phase.wav",
    "night": "night_phase.mp3",
    "vote": "vote_phase.mp3",
    "hang": "sad_sound.mp3",
    "end_game": "end_game.mp3" 
}

# Hàm hỗ trợ
def init_game_logs_table():
    try:
        db = get_db_connection()
        cursor = db.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS game_logs (
                id INT AUTO_INCREMENT PRIMARY KEY,
                guild_id BIGINT NOT NULL,
                log_message TEXT NOT NULL,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        """)
        db.commit()
    except mysql.connector.Error as err:
        logger.error(f"Lỗi khi tạo bảng game_logs: {err}")
    finally:
        cursor.close()
        db.close()

async def generate_math_problem(used_problems):
    max_attempts = 100
    for _ in range(max_attempts):
        num1 = random.randint(100, 999)
        num2 = random.randint(100, 999)
        operation = random.choice(['+', '-'])
        problem = f"{num1} {operation} {num2}"
        if problem not in used_problems:
            answer = num1 + num2 if operation == '+' else num1 - num2
            if answer < 100:
                continue
            possible_wrong = []
            for offset in range(-100, 101, 10):
                wrong = answer + offset
                if wrong != answer and wrong >= 0:
                    possible_wrong.append(wrong)
            if len(possible_wrong) < 2:
                continue
            wrong1, wrong2 = random.sample(possible_wrong, 2)
            options = [answer, wrong1, wrong2]
            random.shuffle(options)
            return {"problem": problem, "answer": answer, "options": options}
    raise ValueError("Unable to generate unique math problem after maximum attempts")

async def setup_wolf_channel(guild, game_state):
    wolf_channel = discord.utils.get(guild.text_channels, name="wolf-chat")
    werewolf_role = guild.get_role(game_state["werewolf_role_id"])
    if not wolf_channel:
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            werewolf_role: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }
        wolf_channel = await guild.create_text_channel("wolf-chat", overwrites=overwrites)
    else:
        await wolf_channel.set_permissions(guild.default_role, read_messages=False)
        await wolf_channel.set_permissions(werewolf_role, read_messages=True, send_messages=True)
    game_state["wolf_channel"] = wolf_channel
    return wolf_channel

async def setup_dead_channel(guild, game_state):
    dead_channel = discord.utils.get(guild.text_channels, name="dead-chat")
    dead_role = guild.get_role(game_state["dead_role_id"])
    if not dead_channel:
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            dead_role: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }
        dead_channel = await guild.create_text_channel("dead-chat", overwrites=overwrites)
    else:
        await dead_channel.set_permissions(guild.default_role, read_messages=False)
        await dead_channel.set_permissions(dead_role, read_messages=True, send_messages=True)
    game_state["dead_channel"] = dead_channel
    return dead_channel

async def countdown(channel, seconds, phase, game_state):
    if not game_state["is_game_running"]:
        logger.info(f"Game stopped, skipping countdown for phase: {phase}")
        return
    if game_state["is_game_paused"]:
        logger.info(f"Game paused, skipping countdown for phase: {phase}")
        return

    if channel is None:
        logger.error(f"Cannot send countdown message for phase {phase}: channel is None")
        return

    try:
        if seconds < 5:
            # Gửi tin nhắn kết thúc ngay lập tức nếu thời gian nhỏ hơn 5 giây
            message = await channel.send(f"⏳ *Pha {phase} kết thúc!*")
            return

        # Gửi tin nhắn ban đầu
        current_message = await channel.send(f"⏳ *Đang đếm ngược cho {phase}...*")
        remaining = seconds - 5
        while remaining > 0:
            if not game_state["is_game_running"] or game_state["is_game_paused"]:
                await current_message.edit(content="⏳ *Đếm ngược bị hủy do game dừng hoặc tạm dừng.*")
                return
            await asyncio.sleep(1)
            remaining -= 1

        # Bắt đầu đếm ngược 5 giây cuối bằng cách gửi tin nhắn mới và xóa tin nhắn cũ
        for i in range(5, 0, -1):
            if not game_state["is_game_running"] or game_state["is_game_paused"]:
                await current_message.edit(content="⏳ *Đếm ngược bị hủy do game dừng hoặc tạm dừng.*")
                return
            new_message = await channel.send(f"⏳ *Còn {i}s để {phase}*")
            try:
                await current_message.delete()
            except discord.errors.NotFound:
                logger.warning(f"Message not found to delete during countdown for phase {phase}")
            except Exception as e:
                logger.error(f"Error deleting message during countdown for phase {phase}: {str(e)}")
            current_message = new_message
            await asyncio.sleep(1)

        # Gửi tin nhắn kết thúc
        final_message = await channel.send(f"⏳ *Pha {phase} kết thúc!*")
        try:
            await current_message.delete()
        except discord.errors.NotFound:
            logger.warning(f"Message not found to delete at the end of countdown for phase {phase}")
        except Exception as e:
            logger.error(f"Error deleting final message during countdown for phase {phase}: {str(e)}")
    except Exception as e:
        logger.error(f"Error during countdown for phase {phase}: {str(e)}")

# Hàm hiển thị phiếu vote sau 30 giây
async def display_current_votes(interaction: discord.Interaction, game_state):
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        return
    vote_counts = {}
    skip_votes = 0
    for user_id, data in game_state["players"].items():
        if data["status"] in ["alive", "wounded"]:
            # Kiểm tra điều kiện đủ để vote
            if data["role"] not in NO_NIGHT_ACTION_ROLES or (user_id in game_state["math_results"] and game_state["math_results"][user_id]):
                target_id = game_state["votes"].get(user_id, "skip")
                if target_id == "skip":
                    skip_votes += 1
                elif isinstance(target_id, int):
                    vote_counts[target_id] = vote_counts.get(target_id, 0) + 1
    
    embed = discord.Embed(
        title="🗳️ Phiếu vote hiện tại (sau 30 giây)",
        color=discord.Color.blue()
    )
    
    if not vote_counts and skip_votes == 0:
        embed.add_field(name="Thông tin", value="Chưa có phiếu vote nào hợp lệ.", inline=False)
    else:
        for target_id, count in vote_counts.items():
            target = game_state["member_cache"].get(target_id)
            if target:
                embed.add_field(name=target.display_name, value=f"{count} phiếu", inline=True)
        embed.add_field(name="Bỏ qua + Dốt toán", value=f"{skip_votes} phiếu", inline=True)
    
    if game_state["text_channel"] is not None:
        await game_state["text_channel"].send(embed=embed)
    else:
        logger.error("text_channel is None in game_state during display_current_votes")

# Hàm hiển thị kết quả vote cuối cùng
async def display_final_votes(interaction: discord.Interaction, game_state):
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        return
    vote_counts = {}
    skip_votes = 0
    ineligible_count = 0
    for user_id, data in game_state["players"].items():
        if data["status"] in ["alive", "wounded"]:
            if data["role"] not in NO_NIGHT_ACTION_ROLES or (user_id in game_state["math_results"] and game_state["math_results"][user_id]):
                target_id = game_state["votes"].get(user_id, "skip")
                if target_id == "skip":
                    skip_votes += 1
                elif isinstance(target_id, int):
                    vote_counts[target_id] = vote_counts.get(target_id, 0) + 1
            else:
                ineligible_count += 1
    
    embed = discord.Embed(
        title="🗳️ Kết quả vote cuối cùng",
        color=discord.Color.green()
    )
    
    if not vote_counts and skip_votes == 0 and ineligible_count == 0:
        embed.add_field(name="Thông tin", value="Không có phiếu vote nào được ghi nhận.", inline=False)
    else:
        for target_id, count in vote_counts.items():
            target = game_state["member_cache"].get(target_id)
            if target:
                embed.add_field(name=target.display_name, value=f"{count} phiếu", inline=True)
        
        # Tính và hiển thị tổng của "Bỏ qua" và "Không đủ điều kiện vote"
        total_skip_and_ineligible = skip_votes + ineligible_count
        embed.add_field(name="Bỏ qua + Dốt toán", value=f"{total_skip_and_ineligible} phiếu", inline=True)
    
    if game_state["text_channel"] is not None:
        await game_state["text_channel"].send(embed=embed)
    else:
        logger.error("text_channel is None in game_state during display_final_votes")
  
async def check_win_condition(interaction: discord.Interaction, game_state):
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("check_win_condition: Game is not running or paused, skipping win condition check")
        return False

    werewolves = 0
    villagers = 0
    for data in game_state["players"].values():
        if data["status"] in ["alive", "wounded"]:
            if data["role"] in WEREWOLF_ROLES and data["role"] != "Illusionist":
                werewolves += 1
            elif data["role"] in VILLAGER_ROLES or data["role"] == "Illusionist":
                villagers += 1

    # Phe Dân chỉ thắng nếu không còn Sói và không có lời nguyền đang chờ
    if werewolves == 0 and villagers > 0 and game_state["demon_werewolf_cursed_player"] is None:
        winning_team = "villagers"
        await update_leaderboard(interaction, game_state, winning_team)
        game_logs[interaction.guild.id].append("Phe Dân thắng vì tất cả Sói đã bị tiêu diệt.")
        if game_state["text_channel"] is not None:
            villager_win_embed = discord.Embed(
                title="🎉 Phe Dân Thắng!",
                description="Tất cả Sói đã bị tiêu diệt!",
                color=discord.Color.green()
            )
            villager_win_embed.set_image(url=GIF_URLS["villager_win"])
            await game_state["text_channel"].send(embed=villager_win_embed)
        await handle_game_end(interaction, game_state)
        return True
    elif werewolves >= villagers and werewolves > 0:
        winning_team = "werewolves"
        await update_leaderboard(interaction, game_state, winning_team)
        game_logs[interaction.guild.id].append("Phe Sói thắng vì số Sói bằng hoặc vượt số Dân.")
        if game_state["text_channel"] is not None:
            werewolf_win_embed = discord.Embed(
                title="🐺 Phe Sói Thắng!",
                description="Số Sói còn sống bằng hoặc vượt số Dân!",
                color=discord.Color.red()
            )
            werewolf_win_embed.set_image(url=GIF_URLS["werewolf_win"])
            await game_state["text_channel"].send(embed=werewolf_win_embed)
        await handle_game_end(interaction, game_state)
        return True
    return False

async def get_alive_players(interaction: discord.Interaction, game_state):
    if not game_state["member_cache"]:
        game_state["member_cache"] = {m.id: m for m in await retry_api_call(lambda: interaction.guild.members)}
    alive_players = []
    for user_id, data in game_state["players"].items():
        if data["status"] in ["alive", "wounded"]:
            member = game_state["member_cache"].get(user_id)
            if member:
                alive_players.append(member)
    return alive_players

async def retry_api_call(func, max_attempts=5, initial_delay=2):
    attempt = 1
    delay = initial_delay
    while attempt <= max_attempts:
        try:
            result = func()
            if inspect.iscoroutine(result):
                return await asyncio.wait_for(result, timeout=5)
            return result
        except asyncio.TimeoutError:
            logger.error(f"API call timed out, attempt={attempt}/{max_attempts}, func={func.__name__}")
            if attempt == max_attempts:
                raise discord.errors.HTTPException(response=None, message="API call timed out")
            await asyncio.sleep(delay)
            attempt += 1
            delay *= 2
        except discord.errors.HTTPException as e:
            if e.status == 429:
                logger.warning(f"Rate limit hit, attempt={attempt}/{max_attempts}, retrying in {delay}s")
                await asyncio.sleep(delay)
                attempt += 1
                delay *= 2
            else:
                logger.error(f"HTTPException in API call: {str(e)}, attempt={attempt}, func={func.__name__}")
                raise e
        except Exception as e:
            logger.error(f"API call failed: {str(e)}, attempt={attempt}, func={func.__name__}")
            if attempt == max_attempts:
                raise e
            await asyncio.sleep(delay)
            attempt += 1
            delay *= 2
    raise discord.errors.HTTPException(response=None, message="Max retries exceeded for API call")

# Hàm phát âm thanh (đã sửa)
async def play_audio(file_path, voice_connection):
    if voice_connection and voice_connection.is_connected():
        try:
            audio_source = discord.FFmpegPCMAudio(file_path)
            voice_connection.play(audio_source)
            # Không chờ âm thanh phát xong, trả về ngay để tiếp tục thực thi
        except FileNotFoundError:
            logger.error(f"Audio file not found: {file_path}")
        except Exception as e:
            logger.error(f"Error playing audio {file_path}: {str(e)}")

# View cho lựa chọn kênh voice
class VoiceChannelView(discord.ui.View):
    def __init__(self, guild, admin_id, game_states):
        super().__init__(timeout=180)
        self.add_item(VoiceChannelSelect(guild, admin_id, game_states))

class VoiceChannelSelect(discord.ui.Select):
    def __init__(self, guild, admin_id, game_states):
        voice_channels = [ch for ch in guild.voice_channels if ch.members]
        options = [
            discord.SelectOption(label=ch.name, value=str(ch.id))
            for ch in voice_channels[:25]
        ]
        super().__init__(placeholder="Chọn kênh voice", options=options, min_values=1, max_values=1)
        self.guild = guild
        self.admin_id = admin_id
        self.game_states = game_states

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.admin_id:
            await interaction.response.send_message("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        await interaction.response.defer()
        voice_channel_id = int(self.values[0])
        voice_channel = self.guild.get_channel(voice_channel_id)
        if not voice_channel or not voice_channel.members:
            await interaction.followup.send("Kênh voice này không có người hoặc không tồn tại!", ephemeral=True)
            return
        guild_id = self.guild.id
        if guild_id not in self.game_states:
            self.game_states[guild_id] = {
                "players": {},
                "voice_channel_id": None,
                "guild_id": guild_id,
                "is_game_running": False,
                "is_game_paused": False,
                "phase": "none",
                "is_first_day": True,
                "protected_player_id": None,
                "previous_protected_player_id": None,
                "werewolf_target_id": None,
                "witch_target_id": None,
                "witch_action": None,
                "witch_has_power": True,
                "hunter_target_id": None,
                "hunter_has_power": True,
                "explorer_target_id": None,
                "votes": {},
                "text_channel": None,
                "wolf_channel": None,
                "dead_channel": None,
                "illusionist_scanned": False,
                "illusionist_effect_active": False,
                "illusionist_effect_night": 0,
                "temp_player_count": 0,
                "temp_players": [],
                "temp_roles": {role: 0 for role in ROLES},
                "temp_admin_id": None,
                "reset_in_progress": False,
                "math_problems": {},
                "math_results": {},
                "member_cache": {},
                "player_channels": {},
                "villager_role_id": None,
                "dead_role_id": None,
                "night_count": 0,
                "voice_connection": None,
                "demon_werewolf_activated": False,
                "demon_werewolf_cursed_player": None,
                "demon_werewolf_has_cursed": False,
                "demon_werewolf_cursed_this_night": False,
                "setup_message": None,
                "assassin_werewolf_has_acted": False,  # Theo dõi hành động Sói Ám Sát
                "assassin_werewolf_target_id": None,   # ID mục tiêu của Sói Ám Sát
                "assassin_werewolf_role_guess": None,   # Vai trò đoán của Sói Ám Sát
                "detective_has_used_power": False,
                "detective_target1_id": None,
                "detective_target2_id": None
            }
        game_state = self.game_states[guild_id]
        game_state["voice_channel_id"] = voice_channel_id
        game_state["guild_id"] = self.guild.id
        
        try:
            await interaction.message.edit(
                content=f"Đã chọn kênh voice {voice_channel.name}. Chọn số lượng người chơi (tối thiểu 4, tối đa {len(voice_channel.members)}):",
                view=PlayerCountView(len(voice_channel.members), self.admin_id, game_state)
            )
        except discord.errors.NotFound:
            logger.warning("Tin nhắn không tồn tại để chỉnh sửa, gửi tin nhắn mới.")
            new_message = await interaction.channel.send(
                content=f"Đã chọn kênh voice {voice_channel.name}. Chọn số lượng người chơi (tối thiểu 4, tối đa {len(voice_channel.members)}):",
                view=PlayerCountView(len(voice_channel.members), self.admin_id, game_state)
            )
            game_state["setup_message"] = new_message

# View cho lựa chọn số lượng người chơi
class PlayerCountView(discord.ui.View):
    def __init__(self, max_players, admin_id, game_state):
        super().__init__(timeout=180)
        self.add_item(PlayerCountSelect(max_players, admin_id, game_state))

class PlayerCountSelect(discord.ui.Select):
    def __init__(self, max_players, admin_id, game_state):
        options = [
            discord.SelectOption(label=str(i), value=str(i))
            for i in range(4, min(max_players + 1, 26))
        ]
        super().__init__(placeholder="Chọn số lượng người chơi", options=options, min_values=1, max_values=1)
        self.admin_id = admin_id
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.admin_id:
            await interaction.response.send_message("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        await interaction.response.defer()
        self.game_state["temp_player_count"] = int(self.values[0])
        voice_channel = interaction.guild.get_channel(self.game_state["voice_channel_id"])
        if voice_channel:
            human_members_count = len([m for m in voice_channel.members if not m.bot])
            if human_members_count < self.game_state["temp_player_count"]:
                await interaction.followup.send("Số người (không phải bot) trong kênh voice không đủ cho số lượng đã chọn!", ephemeral=True)
                return
        else:
            await interaction.followup.send("Kênh voice không tồn tại!", ephemeral=True)
            return
        
        try:
            await interaction.message.edit(
                content=f"Đã chọn số lượng người chơi: {self.game_state['temp_player_count']}. Chọn danh sách người chơi:",
                view=PlayerSelectView(interaction.guild, interaction.user.id, self.game_state)
            )
        except discord.errors.NotFound:
            logger.warning("Tin nhắn không tồn tại để chỉnh sửa, gửi tin nhắn mới.")
            new_message = await interaction.channel.send(
                content=f"Đã chọn số lượng người chơi: {self.game_state['temp_player_count']}. Chọn danh sách người chơi:",
                view=PlayerSelectView(interaction.guild, interaction.user.id, self.game_state)
            )
            self.game_state["setup_message"] = new_message

# View cho lựa chọn người chơi
class PlayerSelectView(discord.ui.View):
    def __init__(self, guild, admin_id, game_state):
        super().__init__(timeout=180)
        self.add_item(PlayerSelect(guild, admin_id, game_state))

class PlayerSelect(discord.ui.Select):
    def __init__(self, guild, admin_id, game_state):
        voice_channel = guild.get_channel(game_state["voice_channel_id"])
        logger.info(f"Initializing PlayerSelect: voice_channel_id={game_state.get('voice_channel_id')}, voice_channel={voice_channel}, guild_id={guild.id}")
        # Lọc bỏ các bot khỏi danh sách members
        members = [m for m in voice_channel.members if not m.bot][:25] if voice_channel and hasattr(voice_channel, 'members') else []
        if not members:
            options = [discord.SelectOption(label="Không có người chơi", value="none")]
            min_values = 1
            max_values = 1
        else:
            options = []
            for member in members:
                try:
                    options.append(discord.SelectOption(label=member.display_name, value=str(member.id)))
                except Exception as e:
                    logger.error(f"Error creating SelectOption for player ID={member.id}, DisplayName={repr(member.display_name)}, error={str(e)}")
                    continue
            actual_options = len(options)
            min_values = min(game_state["temp_player_count"], actual_options)
            max_values = min(game_state["temp_player_count"], actual_options)
        super().__init__(
            placeholder="Chọn người chơi",
            options=options,
            min_values=min_values,
            max_values=max_values
        )
        self.admin_id = admin_id
        self.guild = guild
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.admin_id:
            await text_channel.send("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        await interaction.response.defer()
        try:
            voice_channel_id = self.game_state.get("voice_channel_id")
            if not voice_channel_id:
                logger.error(f"No voice_channel_id in game_state, interaction_id={interaction.id}")
                await interaction.followup.send("Lỗi: Không tìm thấy ID kênh voice. Vui lòng chạy lại !start_game!", ephemeral=True)
                return
            voice_channel = self.guild.get_channel(voice_channel_id)
            if not voice_channel:
                logger.error(f"Voice channel not found: ID={voice_channel_id}, interaction_id={interaction.id}")
                await interaction.followup.send("Lỗi: Kênh voice không tồn tại. Vui lòng chạy lại !start_game!", ephemeral=True)
                return
            current_members = await retry_api_call(lambda: {m.id: m for m in voice_channel.members if m}, max_attempts=5, initial_delay=2)
            if not current_members:
                logger.error(f"No members in voice channel: ID={voice_channel_id}, interaction_id={interaction.id}")
                await interaction.followup.send("Lỗi: Kênh voice không có người chơi nào! Vui lòng kiểm tra và thử lại.", ephemeral=True)
                return
            if "none" in self.values:
                logger.error(f"No players available in voice channel, interaction_id={interaction.id}")
                await interaction.followup.send("Không có người chơi trong kênh voice!", ephemeral=True)
                return
            self.game_state["member_cache"] = {m.id: m for m in await retry_api_call(lambda: self.guild.members, max_attempts=5, initial_delay=2)}
            selected_ids = []
            selected_names = []
            for id_str in self.values:
                try:
                    user_id = int(id_str)
                    if user_id not in current_members:
                        logger.warning(f"Player ID={user_id} not in voice channel, interaction_id={interaction.id}")
                        await interaction.followup.send(f"Một người chơi (ID: {id_str}) đã rời kênh voice! Vui lòng chọn lại.", ephemeral=True)
                        return
                    member = self.game_state["member_cache"].get(user_id)
                    if not member or not isinstance(member, discord.Member):
                        logger.error(f"Failed to fetch member: ID={user_id}, member={member}, interaction_id={interaction.id}")
                        await interaction.followup.send(f"Không tìm thấy người chơi với ID {id_str}! Có thể họ đã rời server.", ephemeral=True)
                        return
                    voice_state = member.voice
                    if not voice_state or not voice_state.channel or voice_state.channel.id != voice_channel_id:
                        logger.error(f"Player ID={user_id} has invalid voice state: voice={voice_state}, channel={voice_state.channel if voice_state else None}, interaction_id={interaction.id}")
                        await interaction.followup.send(f"Người chơi {member.display_name} không còn trong kênh voice hợp lệ!", ephemeral=True)
                        return
                    selected_ids.append(user_id)
                    selected_names.append(member.display_name)
                except ValueError as ve:
                    logger.error(f"Invalid ID in PlayerSelect: {id_str}, error={str(ve)}, interaction_id={interaction.id}")
                    await interaction.followup.send("Lỗi: ID người chơi không hợp lệ!", ephemeral=True)
                    return
                except Exception as e:
                    logger.error(f"Error processing player ID={id_str}, error={str(e)}, interaction_id={interaction.id}")
                    await interaction.followup.send(f"Lỗi khi xử lý người chơi ID {id_str}. Vui lòng thử lại!", ephemeral=True)
                    return
            if len(selected_ids) != self.game_state["temp_player_count"]:
                await interaction.followup.send(
                    f"Vui lòng chọn đúng {self.game_state['temp_player_count']} người chơi! Đã chọn: {len(selected_ids)}",
                    ephemeral=True
                )
                return
            self.game_state["temp_players"] = selected_ids
            selected_players_str = ", ".join(selected_names)
            
            try:
                await interaction.message.edit(
                    content=f"Đã chọn người chơi: {selected_players_str}. Chọn số lượng Sói, Dân Làng và vai đặc biệt (tổng phải bằng {self.game_state['temp_player_count']}):",
                    view=RoleSelectView(interaction.user.id, self.game_state)
                )
            except discord.errors.NotFound:
                logger.warning("Tin nhắn không tồn tại để chỉnh sửa, gửi tin nhắn mới.")
                new_message = await interaction.channel.send(
                    content=f"Đã chọn người chơi: {selected_players_str}. Chọn số lượng Sói, Dân Làng và vai đặc biệt (tổng phải bằng {self.game_state['temp_player_count']}):",
                    view=RoleSelectView(interaction.user.id, self.game_state)
                )
                self.game_state["setup_message"] = new_message
        except Exception as e:
            logger.error(f"Unexpected error in PlayerSelect.callback: error={str(e)}, interaction_id={interaction.id}")
            await interaction.followup.send("Lỗi không xác định khi xử lý lựa chọn người chơi. Vui lòng thử lại!", ephemeral=True)

# View cho lựa chọn vai trò
class RoleSelectView(discord.ui.View):
    def __init__(self, admin_id, game_state):
        super().__init__(timeout=180)
        self.admin_id = admin_id
        self.game_state = game_state
        logger.info(f"Initializing RoleSelectView: admin_id={admin_id}, temp_player_count={game_state['temp_player_count']}, temp_roles={game_state['temp_roles']}")
        self.add_item(WerewolfCountSelect(game_state))
        self.add_item(VillagerCountSelect(game_state))
        self.add_item(VillagerSpecialRoleSelect(game_state))
        self.add_item(WerewolfSpecialRoleSelect(game_state))
        self.add_item(ConfirmButton(game_state))
        self.add_item(ResetRolesButton(game_state))

class WerewolfCountSelect(discord.ui.Select):
    def __init__(self, game_state):
        total_roles = sum(game_state["temp_roles"].values())
        remaining = game_state["temp_player_count"] - total_roles
        options = [
            discord.SelectOption(label=str(i), value=str(i))
            for i in range(0, min(remaining + game_state["temp_roles"]["Werewolf"] + 1, game_state["temp_player_count"] + 1))
        ]
        super().__init__(
            placeholder=f"Chọn số lượng Sói (hiện tại: {game_state['temp_roles']['Werewolf']})",
            options=options,
            min_values=1,
            max_values=1
        )
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        count = int(self.values[0])
        self.game_state["temp_roles"]["Werewolf"] = count
        total_roles = sum(self.game_state["temp_roles"].values())
        remaining = self.game_state["temp_player_count"] - total_roles
        logger.info(f"Werewolf count selected: count={count}, total_roles={total_roles}, remaining={remaining}, interaction_id={interaction.id}")
        role_summary = "\n".join([f"{role}: {count}" for role, count in self.game_state["temp_roles"].items()])
        new_content = (f"Chọn số lượng Sói, Dân Làng và vai đặc biệt (tổng phải bằng {self.game_state['temp_player_count']}):\n"
                       f"Trạng thái vai trò:\n{role_summary}\n"
                       f"Tổng vai: {total_roles}/{self.game_state['temp_player_count']} (còn {remaining})")
        new_view = RoleSelectView(self.view.admin_id, self.game_state)
        await interaction.response.edit_message(content=new_content, view=new_view)

class VillagerCountSelect(discord.ui.Select):
    def __init__(self, game_state):
        total_roles = sum(game_state["temp_roles"].values())
        remaining = game_state["temp_player_count"] - total_roles
        options = [
            discord.SelectOption(label=str(i), value=str(i))
            for i in range(0, min(remaining + game_state["temp_roles"]["Villager"] + 1, game_state["temp_player_count"] + 1))
        ]
        super().__init__(
            placeholder=f"Chọn số lượng Dân Làng (hiện tại: {game_state['temp_roles']['Villager']})",
            options=options,
            min_values=1,
            max_values=1
        )
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        count = int(self.values[0])
        self.game_state["temp_roles"]["Villager"] = count
        total_roles = sum(self.game_state["temp_roles"].values())
        remaining = self.game_state["temp_player_count"] - total_roles
        logger.info(f"Villager count selected: count={count}, total_roles={total_roles}, remaining={remaining}, interaction_id={interaction.id}")
        role_summary = "\n".join([f"{role}: {count}" for role, count in self.game_state["temp_roles"].items()])
        new_content = (f"Chọn số lượng Sói, Dân Làng và vai đặc biệt (tổng phải bằng {self.game_state['temp_player_count']}):\n"
                       f"Trạng thái vai trò:\n{role_summary}\n"
                       f"Tổng vai: {total_roles}/{self.game_state['temp_player_count']} (còn {remaining})")
        new_view = RoleSelectView(self.view.admin_id, self.game_state)
        await interaction.response.edit_message(content=new_content, view=new_view)

class VillagerSpecialRoleSelect(discord.ui.Select):
    def __init__(self, game_state):
        total_roles = sum(game_state["temp_roles"].values())
        remaining = game_state["temp_player_count"] - total_roles
        options = []
        for role in VILLAGER_SPECIAL_ROLES:
            if game_state["temp_roles"].get(role, 0) == 0 and remaining > 0:
                options.append(discord.SelectOption(label=role, value=role))
        if not options:
            options.append(discord.SelectOption(label="Không còn vai đặc biệt Phe Dân", value="none"))
        super().__init__(
            placeholder=f"Chọn vai đặc biệt Phe Dân (còn {remaining} vai)",
            options=options,
            min_values=1,
            max_values=1
        )
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        if self.values[0] == "none":
            await text_channel.send("Không còn vai đặc biệt Phe Dân để chọn!", ephemeral=True)
            return
        role = self.values[0]
        self.game_state["temp_roles"][role] = 1
        total_roles = sum(self.game_state["temp_roles"].values())
        remaining = self.game_state["temp_player_count"] - total_roles
        logger.info(f"Villager special role selected: role={role}, count=1, total_roles={total_roles}, remaining={remaining}, interaction_id={interaction.id}")
        role_summary = "\n".join([f"{r}: {count}" for r, count in self.game_state["temp_roles"].items()])
        new_content = (f"Chọn số lượng Sói, Dân Làng và vai đặc biệt (tổng phải bằng {self.game_state['temp_player_count']}):\n"
                       f"Trạng thái vai trò:\n{role_summary}\n"
                       f"Tổng vai: {total_roles}/{self.game_state['temp_player_count']} (còn {remaining})")
        new_view = RoleSelectView(self.view.admin_id, self.game_state)
        await interaction.response.edit_message(content=new_content, view=new_view)

class WerewolfSpecialRoleSelect(discord.ui.Select):
    def __init__(self, game_state):
        total_roles = sum(game_state["temp_roles"].values())
        remaining = game_state["temp_player_count"] - total_roles
        options = []
        for role in WEREWOLF_SPECIAL_ROLES:
            if game_state["temp_roles"].get(role, 0) == 0 and remaining > 0:
                options.append(discord.SelectOption(label=role, value=role))
        if not options:
            options.append(discord.SelectOption(label="Không còn vai đặc biệt Phe Sói", value="none"))
        super().__init__(
            placeholder=f"Chọn vai đặc biệt Phe Sói (còn {remaining} vai)",
            options=options,
            min_values=1,
            max_values=1
        )
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        if self.values[0] == "none":
            await text_channel.send("Không còn vai đặc biệt Phe Sói để chọn!", ephemeral=True)
            return
        role = self.values[0]
        self.game_state["temp_roles"][role] = 1
        total_roles = sum(self.game_state["temp_roles"].values())
        remaining = self.game_state["temp_player_count"] - total_roles
        logger.info(f"Werewolf special role selected: role={role}, count=1, total_roles={total_roles}, remaining={remaining}, interaction_id={interaction.id}")
        role_summary = "\n".join([f"{r}: {count}" for r, count in self.game_state["temp_roles"].items()])
        new_content = (f"Chọn số lượng Sói, Dân Làng và vai đặc biệt (tổng phải bằng {self.game_state['temp_player_count']}):\n"
                       f"Trạng thái vai trò:\n{role_summary}\n"
                       f"Tổng vai: {total_roles}/{self.game_state['temp_player_count']} (còn {remaining})")
        new_view = RoleSelectView(self.view.admin_id, self.game_state)
        await interaction.response.edit_message(content=new_content, view=new_view)

class ConfirmButton(discord.ui.Button):
    def __init__(self, game_state):
        super().__init__(label="Xác nhận", style=discord.ButtonStyle.green)
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        total_roles = sum(self.game_state["temp_roles"].values())
        logger.info(f"ConfirmButton clicked: total_roles={total_roles}, expected={self.game_state['temp_player_count']}, temp_roles={self.game_state['temp_roles']}, interaction_id={interaction.id}")
        if total_roles != self.game_state["temp_player_count"]:
            await text_channel.send(
                f"Tổng số vai ({total_roles}) không khớp với số người chơi ({self.game_state['temp_player_count']})!",
                ephemeral=True
            )
            return
        if self.game_state["temp_roles"]["Werewolf"] + self.game_state["temp_roles"]["Wolfman"] + self.game_state["temp_roles"]["Assassin Werewolf"] < 1:
            await text_channel.send("Phải có ít nhất 1 Sói, Người Sói hoặc Sói Ám Sát!", ephemeral=True)
            return
        if self.game_state["temp_roles"]["Villager"] < 0:
            await text_channel.send("Số Dân Làng không thể âm!", ephemeral=True)
            return
        await interaction.response.edit_message(content="Khởi tạo game!", view=None)
        await start_game_logic(interaction, self.game_state)

class ResetRolesButton(discord.ui.Button):
    def __init__(self, game_state):
        super().__init__(label="Reset Roles", style=discord.ButtonStyle.red)
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        self.game_state["temp_roles"] = {role: 0 for role in ROLES}
        total_roles = sum(self.game_state["temp_roles"].values())
        remaining = self.game_state["temp_player_count"] - total_roles
        logger.info(f"Roles reset: temp_roles={self.game_state['temp_roles']}, interaction_id={interaction.id}")
        role_summary = "\n".join([f"{role}: {count}" for role, count in self.game_state["temp_roles"].items()])
        new_content = (f"Đã reset vai trò. Chọn số lượng Sói, Dân Làng và vai đặc biệt (tổng phải bằng {self.game_state['temp_player_count']}):\n"
                       f"Trạng thái vai trò:\n{role_summary}\n"
                       f"Tổng vai: {total_roles}/{self.game_state['temp_player_count']} (còn {remaining})")
        new_view = RoleSelectView(self.view.admin_id, self.game_state)
        await interaction.response.edit_message(content=new_content, view=new_view)

# View cho bài toán ban đêm
class NightMathView(discord.ui.View):
    def __init__(self, user_id, options, correct_answer, game_state, timeout=40):
        super().__init__(timeout=timeout)
        self.user_id = user_id
        self.correct_answer = correct_answer
        self.game_state = game_state
        for option in options:
            self.add_item(MathAnswerButton(option, option == correct_answer, user_id, game_state))

class MathAnswerButton(discord.ui.Button):
    def __init__(self, answer, is_correct, user_id, game_state):
        super().__init__(label=str(answer), style=discord.ButtonStyle.primary)
        self.answer = answer
        self.is_correct = is_correct
        self.user_id = user_id
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("Đây không phải bài toán của bạn!", ephemeral=True)
            return
        if self.game_state["phase"] != "night":
            await interaction.response.send_message("Chưa phải pha đêm!", ephemeral=True)
            return
        if self.game_state["is_game_paused"]:
            await interaction.response.send_message("Game đang tạm dừng, không thể thực hiện hành động!", ephemeral=True)
            return
        if not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Vui lòng trả lời qua DM!", ephemeral=True)
            return
        if interaction.user.id not in self.game_state["math_problems"]:
            await interaction.response.send_message("Bạn đã trả lời hoặc không có bài toán!", ephemeral=True)
            return

        if self.is_correct:
            self.game_state["math_results"][self.user_id] = True
            await interaction.response.send_message("Đúng! Bạn đã đủ điều kiện để bỏ phiếu vào ban ngày.", ephemeral=True)
        else:
            self.game_state["math_results"][self.user_id] = False
            await interaction.response.send_message("Sai! Bạn sẽ không được bỏ phiếu vào ban ngày.", ephemeral=True)

        del self.game_state["math_problems"][self.user_id]
        for child in self.view.children:
            child.disabled = True
        await interaction.message.edit(view=self.view)

#Leader board
async def update_leaderboard(interaction: discord.Interaction, game_state, winning_team):
    guild_id = interaction.guild.id  # Guild ID as integer
    try:
        db = get_db_connection()
        cursor = db.cursor()

        # Tạo bảng nếu chưa tồn tại
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS leaderboard (
                id INT AUTO_INCREMENT PRIMARY KEY,
                guild_id BIGINT NOT NULL,
                player_id BIGINT NOT NULL,
                player_name VARCHAR(255) NOT NULL,
                score INT DEFAULT 0,
                UNIQUE KEY unique_guild_player (guild_id, player_id)
            )
        """)

        # Chuẩn bị cập nhật cho tất cả người chơi
        updates = []
        for user_id, data in game_state["players"].items():
            member = game_state["member_cache"].get(user_id)
            if not member:
                continue

            player_id = user_id
            player_name = member.display_name

            # Xác định đội của người chơi
            if data["role"] in VILLAGER_ROLES:
                player_team = "villagers"
            elif data["role"] in WEREWOLF_ROLES:
                player_team = "werewolves"
            else:
                continue

            # Tính toán mức tăng điểm
            if player_team == winning_team:
                score_increment = 3 if data["status"] in ["alive", "wounded"] else 1
            else:
                score_increment = -1

            updates.append((guild_id, player_id, player_name, score_increment))

        if updates:
            # Cập nhật hàng loạt bằng executemany
            cursor.executemany("""
                INSERT INTO leaderboard (guild_id, player_id, player_name, score)
                VALUES (%s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE
                player_name = VALUES(player_name),
                score = score + VALUES(score)
            """, updates)
            db.commit()

        logger.info(f"Leaderboard updated for guild {guild_id}")

    except mysql.connector.Error as err:
        logger.error(f"MySQL Error updating leaderboard for guild {guild_id}: {err}")
        if game_state["text_channel"]:
            await game_state["text_channel"].send(f"Lỗi MySQL khi cập nhật leaderboard: {err}")
    except Exception as e:
        logger.error(f"Error updating leaderboard for guild {guild_id}: {e}")
        if game_state["text_channel"]:
            await game_state["text_channel"].send(f"Lỗi khi cập nhật leaderboard: {e}")
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'db' in locals():
            db.close()

# View cho Detective
class DetectiveSelectView(discord.ui.View):
    def __init__(self, detective_id, alive_players, game_state):
        super().__init__(timeout=180)
        self.detective_id = detective_id
        self.game_state = game_state
        options = [
            discord.SelectOption(label=member.display_name, value=str(member.id))
            for member in alive_players if member.id != detective_id
        ]
        self.select = discord.ui.Select(
            placeholder="Chọn hai người chơi để kiểm tra",
            options=options,
            min_values=2,
            max_values=2
        )
        self.select.callback = self.select_callback
        self.add_item(self.select)

    async def select_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.detective_id:
            await interaction.response.send_message("Chỉ thám tử được thao tác!", ephemeral=True)
            return
        if self.game_state["phase"] != "night":
            await interaction.response.send_message("Chưa phải pha đêm!", ephemeral=True)
            return
        if self.game_state["is_game_paused"]:
            await interaction.response.send_message("Game đang tạm dừng, không thể thực hiện hành động!", ephemeral=True)
            return
        if self.game_state["detective_has_used_power"]:
            await interaction.response.send_message("Bạn đã sử dụng quyền của mình!", ephemeral=True)
            return
        target1_id = int(self.select.values[0])
        target2_id = int(self.select.values[1])
        if target1_id == target2_id:
            awaitinteraction.response.send_message("Bạn phải chọn hai người chơi khác nhau!", ephemeral=True)
            return
        target1_role = self.game_state["players"][target1_id]["role"]
        target2_role = self.game_state["players"][target2_id]["role"]
        target1_team = get_player_team(target1_role)
        target2_team = get_player_team(target2_role)
        if target1_team == target2_team:
            result = "Hai người chơi này cùng phe."
        else:
            result = "Hai người chơi này khác phe."
        await interaction.response.send_message(f"Kết quả: {result}", ephemeral=True)
        self.game_state["detective_has_used_power"] = True
        self.game_state["detective_target1_id"] = target1_id
        self.game_state["detective_target2_id"] = target2_id
        for child in self.children:
            child.disabled = True
        await interaction.message.edit(view=self)
        # Thông báo bổ sung cho Thám Tử
        await interaction.followup.send("Bạn đã sử dụng quyền của mình và không còn chức năng nữa.", ephemeral=True)
      
# Hàm xử lý logic bắt đầu game
async def start_game_logic(interaction: discord.Interaction, game_state):
    await interaction.followup.send("Game đang được khởi tạo...", ephemeral=True)
    voice_channel = bot.get_channel(game_state["voice_channel_id"])
    guild = interaction.guild
    text_channel = interaction.channel
    if not text_channel:
        logger.error("morning_phase: text_channel is None, cannot proceed with morning phase")
        return

    # Kiểm tra và ngắt kết nối nếu bot đã ở trong kênh voice
    if game_state["voice_connection"] and game_state["voice_connection"].is_connected():
        await game_state["voice_connection"].disconnect()
        logger.info(f"Bot đã ngắt kết nối khỏi kênh voice cũ: ID={game_state['voice_channel_id']}")

    # Tham gia kênh voice mới
    try:
        game_state["voice_connection"] = await voice_channel.connect()
        logger.info(f"Bot đã tham gia kênh voice: ID={voice_channel.id}, Name={voice_channel.name}")
    except Exception as e:
        logger.error(f"Không thể tham gia kênh voice ID={voice_channel.id}: {str(e)}")
        await text_channel.send(f"Lỗi: Không thể tham gia kênh voice {voice_channel.name}.")
        return

    # Tạo vai trò Discord
    villager_role = await guild.create_role(name="Villager", color=discord.Color.green(), hoist=True, mentionable=False)
    game_state["villager_role_id"] = villager_role.id
    dead_role = await guild.create_role(name="Dead", color=discord.Color.greyple(), hoist=True, mentionable=False)
    game_state["dead_role_id"] = dead_role.id
    werewolf_role = await guild.create_role(name="Werewolf", color=discord.Color.red(), hoist=False, mentionable=False)
    game_state["werewolf_role_id"] = werewolf_role.id

    await voice_channel.set_permissions(dead_role, speak=False)

    # Lấy danh sách người chơi đã chọn
    selected_players = [game_state["member_cache"].get(uid) for uid in game_state["temp_players"]]
    if None in selected_players:
        await text_channel.send("Lỗi: Không tìm thấy một hoặc nhiều người chơi!")
        return

    # Thiết lập kênh
    text_channel = interaction.channel
    await text_channel.set_permissions(guild.default_role, send_messages=False)
    await text_channel.set_permissions(villager_role, send_messages=True)
    await text_channel.set_permissions(dead_role, send_messages=False)
    
    wolf_channel = await setup_wolf_channel(guild, game_state)
    dead_channel = await setup_dead_channel(guild, game_state)
    
    # Tạo các kênh voice riêng biệt cho từng người chơi
    game_state["player_channels"] = {}
    for member in selected_players:
        max_name_length = 100 - len("House of ") - 1  # Đảm bảo tên không vượt quá 100 ký tự
        channel_name = f"House of {member.display_name[:max_name_length]}"
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False, connect=False),
            member: discord.PermissionOverwrite(read_messages=True, connect=True),
            guild.me: discord.PermissionOverwrite(read_messages=True, connect=True)
        }
        channel = await guild.create_voice_channel(channel_name, overwrites=overwrites)
        game_state["player_channels"][member.id] = channel
        logger.info(f"Created private voice channel for player: {member.display_name}, channel_id={channel.id}")
    
    # Gán vai trò và gửi tin nhắn thông báo vai trò
    roles = [role for role, count in game_state["temp_roles"].items() for _ in range(count)]
    random.shuffle(roles)
    game_state["players"] = {}
    for i, member in enumerate(selected_players):
        role = roles[i]
        game_state["players"][member.id] = {"role": role, "status": "alive", "muted": False}
        await member.add_roles(villager_role)
        if role in ["Werewolf", "Wolfman", "Demon Werewolf", "Assassin Werewolf"]:
            await member.add_roles(werewolf_role)
        role_icon_url = ROLE_ICONS.get(role, "https://example.com/default_icon.png")
        embed = discord.Embed(
            title="Vai Trò Của Bạn",
            description=f"Bạn đã được phân vai: **{role}**",
            color=discord.Color.blue()
        )
        embed.set_thumbnail(url=role_icon_url)
        await retry_api_call(lambda: member.send(embed=embed))

    # Cập nhật trạng thái game
    game_state["voice_channel_id"] = voice_channel.id
    game_state["guild_id"] = interaction.guild.id
    game_state["text_channel"] = interaction.channel
    game_state["is_game_running"] = True
    game_state["witch_has_power"] = game_state["temp_roles"]["Witch"] > 0
    game_state["hunter_has_power"] = game_state["temp_roles"]["Hunter"] > 0
    game_state["is_first_day"] = True
    game_state["night_count"] = 0
    game_state["demon_werewolf_activated"] = False
    game_state["demon_werewolf_cursed_player"] = None
    game_state["demon_werewolf_has_cursed"] = False
    game_state["demon_werewolf_cursed_this_night"] = False
    game_state["wolf_channel"] = wolf_channel

    # Ghi log và gửi hướng dẫn cụ thể theo vai trò
    role_counts = {role: 0 for role in ROLES}
    illusionist_id = None
    werewolf_ids = []
    game_logs[interaction.guild.id] = []
    role_log = []
    for member in selected_players:
        role = game_state["players"][member.id]["role"]
        role_counts[role] += 1
        role_log.append(f"{member.display_name}: {role} (Sống)")
        if role == "Werewolf":
            await retry_api_call(lambda: wolf_channel.set_permissions(member, read_messages=True, send_messages=True))
            await retry_api_call(lambda: member.send("Bạn là Sói! Thảo luận với đồng đội trong kênh wolf-chat vào pha đêm và chọn mục tiêu bằng nút chọn."))
            werewolf_ids.append(member.id)
        elif role == "Wolfman":
            await retry_api_call(lambda: wolf_channel.set_permissions(member, read_messages=True, send_messages=True))
            await retry_api_call(lambda: member.send("Bạn là Người Sói! Thức dậy cùng bầy Sói trong kênh wolf-chat và chọn mục tiêu bằng nút chọn. Bạn hiển thị là Phe Dân nếu bị Tiên Tri soi."))
            werewolf_ids.append(member.id)
        elif role == "Witch":
            await retry_api_call(lambda: member.send("Bạn là Phù Thủy! Mỗi đêm, bạn sẽ nhận thông báo muộn hơn về người bị giết và có 20 giây để cứu hoặc giết bằng nút chọn."))
        elif role == "Hunter":
            await retry_api_call(lambda: member.send("Bạn là Thợ Săn! Bạn có 40 giây đầu mỗi đêm để chọn người giết bằng nút chọn qua DM."))
        elif role == "Tough Guy":
            await retry_api_call(lambda: member.send("Bạn là Người Cứng Cỏi! Bạn có 2 mạng đối với các hành động giết vào ban đêm, phải bị giết 2 lần vào ban đêm để chết hoàn toàn. Không có thông báo khi mất mạng. Nếu bị ngồi ghế điện ban ngày, bạn chết ngay lập tức. Bạn phải chọn đáp án đúng trong bài toán cộng/trừ để được quyền bỏ phiếu."))
        elif role == "Illusionist":
            illusionist_id = member.id
            await retry_api_call(lambda: member.send("Bạn là Nhà Ảo Giác! Bạn thuộc phe Sói nhưng không thức dậy trong wolf-chat và không biết ai là Sói. Sói biết bạn là Nhà Ảo Giác. Bạn phải chọn đáp án đúng trong bài toán cộng/trừ vào ban đêm để được quyền bỏ phiếu."))
        elif role == "Explorer":
            game_state["explorer_id"] = member.id
            game_state["explorer_can_act"] = True
            await retry_api_call(lambda: member.send("Bạn là Người Khám Phá! Từ đêm thứ hai, mỗi đêm bạn phải chọn giết một người qua DM. Nếu không chọn, bạn sẽ mất chức năng. Nếu chọn đúng Sói (không tính Nhà Ảo Giác), Sói sẽ chết. Nếu chọn trúng Phe Dân (tính cả Nhà Ảo Giác), bạn sẽ chết."))
        elif role == "Villager":
            await retry_api_call(lambda: member.send("Bạn là Dân Làng! Bạn không có chức năng đặc biệt vào ban đêm, nhưng phải chọn đáp án đúng trong bài toán cộng/trừ để được quyền bỏ phiếu vào ban ngày."))
        elif role == "Demon Werewolf":
            await retry_api_call(lambda: wolf_channel.set_permissions(member, read_messages=True, send_messages=True))
            await retry_api_call(lambda: member.send("Bạn là Sói Quỷ! Khi một Sói bất kỳ chết, bạn có thể nguyền một người qua DM để biến họ thành Sói vào đêm tiếp theo."))
            werewolf_ids.append(member.id)
        elif role == "Assassin Werewolf":
            await retry_api_call(lambda: wolf_channel.set_permissions(member, read_messages=True, send_messages=True))
            await retry_api_call(lambda: member.send("Bạn là Sói Ám Sát! Vào đêm, bạn có 1 cơ hội đoán chức năng của người chơi ngoại trừ Dân Làng. Đoán đúng họ chết, sai bạn chết."))
            werewolf_ids.append(member.id)
        elif role == "Detective":
            await retry_api_call(lambda: member.send("Bạn là Thám Tử! Bạn có 1 lần duy nhất do thám xem 2 người chơi cùng phe hay khác phe."))
        elif role == "Seer":
            await retry_api_call(lambda: member.send("Bạn là Tiên Tri! Chọn một người để biết người đó Phe Sói hay Phe dân. Lưu ý kết quả có thể bị ảnh hưởng bởi Người Sói và Nhà Ảo Giác."))
        elif role == "Guard":
            await retry_api_call(lambda: member.send("Bạn là Bảo Vệ! Chọn một người để bảo vệ mỗi đêm, người đó sẽ không chết. Không thể chọn 1 người 2 đêm liên tiếp"))

    # Thông báo danh sách sói và Nhà Ảo Giác trong wolf-chat
    werewolf_members = [game_state["member_cache"].get(wid) for wid in werewolf_ids if game_state["member_cache"].get(wid)]
    illusionist_member = game_state["member_cache"].get(illusionist_id) if illusionist_id else None

    embed = discord.Embed(
        title="Danh sách Sói phe Sói",
        color=discord.Color.red()
    )

    if werewolf_members:
        werewolf_names = ", ".join([m.display_name for m in werewolf_members])
        embed.add_field(name="Sói", value=werewolf_names, inline=False)

    if illusionist_member:
        embed.add_field(name="Ảo Giác", value=illusionist_member.display_name, inline=False)
        embed.add_field(name="Lưu ý", value="Ảo Giác thuộc phe Sói nhưng không thức dậy cùng các bạn và không biết ai là Sói", inline=False)

    if game_state["wolf_channel"]:
        await game_state["wolf_channel"].send(embed=embed)

    # Thêm thông báo game bắt đầu với số lượng người chơi và vai trò
    if game_state["text_channel"]:
        # Tạo chuỗi danh sách vai trò
        role_list_str = ", ".join([f"{role}: {count}" for role, count in game_state["temp_roles"].items() if count > 0])
        
        start_embed = discord.Embed(
            title="🎮 **Game Ma Sói DeWolfVie Bắt Đầu!**",
            description=(
                f"**🔹 Số lượng người chơi: {len(game_state['players'])}**\n"
                f"**🔹 Các vai trò trong game: {role_list_str}**\n"
                "**🔹 Tất cả người chơi đã được gán vai trò.**\n"
                "**🔹 Kênh wolf-chat và dead-chat đã được thiết lập.**\n"
                "**🔹 Hãy kiểm tra tin nhắn DM để biết vai trò của bạn.**\n"
                "**🔹 Chuẩn bị cho pha ngày đầu tiên!**"
            ),
            color=discord.Color.blue()
        )
        start_embed.set_image(url="https://cdn.discordapp.com/attachments/1365707789321633813/1372536545717780601/Banner_early_acccess_540x320.png?ex=682721c4&is=6825d044&hm=edce6a3e72304cce30f95e30fca1a3c480e7e8b0a340c95fd6d850541cafc7c6&")  # Thêm URL của ảnh banner
        start_embed.set_footer(text="DeWolfVie ver 5.15")
        await game_state["text_channel"].send(embed=start_embed)
    await morning_phase(interaction, game_state)

# View cho hành động đêm (Tiên Tri, Bảo Vệ, Thợ Săn, Sói, Người Khám Phá)
class NightActionView(discord.ui.View):
    def __init__(self, role, players, game_state, timeout=40):
        super().__init__(timeout=timeout)
        self.role = role
        self.game_state = game_state
        self.add_item(NightActionSelect(role, players, game_state))

class NightActionSelect(discord.ui.Select):
    def __init__(self, role, players, game_state):
        options = [
            discord.SelectOption(label=p.display_name, value=str(p.id))
            for p in players
        ]
        options.append(discord.SelectOption(label="Bỏ qua", value="skip"))
        super().__init__(
            placeholder=f"Chọn người để thực hiện hành động ({role})",
            options=options,
            min_values=1,
            max_values=1
        )
        self.role = role
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id not in self.game_state["players"]:
            await interaction.response.send_message("Bạn không phải người chơi!", ephemeral=True)
            return
        if self.game_state["phase"] != "night":
            await interaction.response.send_message("Chưa phải pha đêm!", ephemeral=True)
            return
        if self.game_state["is_game_paused"]:
            await interaction.response.send_message("Game đang tạm dừng, không thể thực hiện hành động!", ephemeral=True)
            return
        if self.role == "Werewolf" and not isinstance(interaction.channel, discord.TextChannel):
            await interaction.response.send_message("Vui lòng thực hiện hành động trong wolf-chat!", ephemeral=True)
            return
        if self.role != "Werewolf" and not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Vui lòng thực hiện hành động qua DM!", ephemeral=True)
            return
        if self.values[0] == "skip":
            await interaction.response.send_message(f"Bạn đã chọn bỏ qua hành động {self.role}.", ephemeral=True)
            return
        user_id = interaction.user.id
        target_id = int(self.values[0])
        selected_id = int(self.values[0])
        if self.role == "Seer":
            self.game_state["seer_target_id"] = target_id
            target_role = self.game_state["players"][target_id]["role"]
            if target_role == "Illusionist":
                if self.game_state["illusionist_effect_active"]:
                    await interaction.response.send_message("Người bạn soi thuộc **Phe Sói**!", ephemeral=True)
                else:
                    await interaction.response.send_message("Người bạn soi thuộc **Phe Dân**!", ephemeral=True)
                self.game_state["illusionist_effect_night"] = self.game_state["night_count"] + 1
                self.game_state["illusionist_scanned"] = True
            else:
                if self.game_state["illusionist_effect_active"]:
                    if target_role in VILLAGER_ROLES or target_role == "Wolfman":
                        await interaction.response.send_message("Người bạn soi thuộc **Phe Sói**!", ephemeral=True)
                    else:
                        await interaction.response.send_message("Người bạn soi thuộc **Phe Dân**!", ephemeral=True)
                else:
                    if target_role in VILLAGER_ROLES or target_role == "Wolfman":
                        await interaction.response.send_message("Người bạn soi thuộc **Phe Dân**!", ephemeral=True)
                    else:
                        await interaction.response.send_message("Người bạn soi thuộc **Phe Sói**!", ephemeral=True)

        elif self.role == "Guard":
            if target_id == self.game_state["previous_protected_player_id"]:
                await interaction.response.send_message("Bạn không thể bảo vệ cùng một người hai đêm liên tiếp!", ephemeral=True)
                return
            self.game_state["protected_player_id"] = target_id
            target = self.game_state["member_cache"].get(target_id)
            if target:
                await interaction.response.send_message(f"Bạn đã chọn bảo vệ {target.display_name}!", ephemeral=True)
        elif self.role == "Werewolf":
            self.game_state["werewolf_target_id"] = target_id
            target = self.game_state["member_cache"].get(target_id)
            if target:
                await interaction.response.send_message(f"Bầy Sói đã chọn giết {target.display_name}!", ephemeral=True)
        elif self.role == "Hunter":
            self.game_state["hunter_target_id"] = target_id
            target = self.game_state["member_cache"].get(target_id)
            if target:
                await interaction.response.send_message(f"Bạn đã chọn giết {target.display_name}!", ephemeral=True)
        elif self.role == "Explorer":
            self.game_state["explorer_target_id"] = target_id
            target = self.game_state["member_cache"].get(target_id)
            if target:
                await interaction.response.send_message(f"Bạn đã chọn khám phá {target.display_name}!", ephemeral=True)
        elif self.role == "Demon Werewolf":
            if self.game_state["demon_werewolf_activated"] and not self.game_state["demon_werewolf_has_cursed"]:
                self.game_state["demon_werewolf_has_cursed"] = True
                self.game_state["demon_werewolf_cursed_player"] = target_id
                self.game_state["demon_werewolf_cursed_this_night"] = True
                target = self.game_state["member_cache"].get(target_id)
                if target:
                  await interaction.response.send_message(f"Bạn đã nguyền {target.display_name}!", ephemeral=True)
                  logger.info(f"Sói Quỷ {interaction.user.id} đã nguyền {target_id}")
            else:
                await interaction.response.send_message("Bạn đã sử dụng chức năng nguyền hoặc chưa được kích hoạt!", ephemeral=True)
              
        for child in self.view.children:
            child.disabled = True
        await interaction.message.edit(view=self.view)

# View cho hành động của Sói Ám Sát
class AssassinActionView(discord.ui.View):
    def __init__(self, game_state, assassin_id):
        super().__init__(timeout=40)
        self.game_state = game_state
        self.assassin_id = assassin_id
        self.add_item(PlayerSelectDropdown(self.game_state, self.assassin_id))
        self.add_item(RoleSelectDropdown(self.game_state, self.assassin_id))

class PlayerSelectDropdown(discord.ui.Select):
    def __init__(self, game_state, assassin_id):
        options = [
            discord.SelectOption(label=game_state["member_cache"][pid].display_name, value=str(pid))
            for pid, data in game_state["players"].items()
            if data["status"] in ["alive", "wounded"] and pid != assassin_id
        ]
        super().__init__(placeholder="Chọn người chơi", options=options, min_values=1, max_values=1)
        self.game_state = game_state
        self.assassin_id = assassin_id

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.assassin_id:
            await interaction.response.send_message("Chỉ Sói Ám Sát được thao tác!", ephemeral=True)
            return
        self.game_state["assassin_werewolf_target_id"] = int(self.values[0])
        await interaction.response.defer()

class RoleSelectDropdown(discord.ui.Select):
    def __init__(self, game_state, assassin_id):
        # Loại bỏ "Villager" khỏi danh sách vai trò có thể chọn
        options = [discord.SelectOption(label=role, value=role) for role in ROLES if role != "Villager"]
        super().__init__(placeholder="Chọn vai trò", options=options, min_values=1, max_values=1)
        self.game_state = game_state
        self.assassin_id = assassin_id
      
    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.assassin_id:
            await interaction.response.send_message("Chỉ Sói Ám Sát được thao tác!", ephemeral=True)
            return
        self.game_state["assassin_werewolf_role_guess"] = self.values[0]
        self.game_state["assassin_werewolf_has_acted"] = True
        await interaction.response.send_message("Bạn đã chọn xong. Kết quả sẽ được xử lý cuối pha đêm.", ephemeral=True)
        for child in self.view.children:
            child.disabled = True
        await interaction.message.edit(view=self.view)
      
# View cho Phù Thủy
class WitchActionView(discord.ui.View):
    def __init__(self, alive_players, potential_targets, game_state, timeout):
        super().__init__(timeout=timeout)
        self.game_state = game_state
        self.alive_players = alive_players
        self.potential_targets = potential_targets
        if potential_targets:
            self.add_item(WitchSaveSelect(potential_targets, game_state))
        self.add_item(WitchKillSelect(alive_players, game_state))
        self.add_item(WitchSkipButton(game_state))

class WitchSaveSelect(discord.ui.Select):
    def __init__(self, potential_targets, game_state):
        options = [
            discord.SelectOption(label=member.display_name, value=str(member.id))
            for member in potential_targets
        ]
        super().__init__(
            placeholder="Chọn người để cứu",
            options=options,
            min_values=1,
            max_values=1
        )
        self.potential_targets = potential_targets
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id not in self.view.game_state["players"] or self.view.game_state["players"][interaction.user.id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("Bạn không phải người chơi hoặc đã chết!", ephemeral=True)
            return
        if self.view.game_state["is_game_paused"]:
            await interaction.response.send_message("Game đang tạm dừng, không thể thực hiện hành động!", ephemeral=True)
            return
        if self.view.game_state["players"][interaction.user.id]["role"] != "Witch":
            await interaction.response.send_message("Chỉ Phù Thủy mới có thể thực hiện hành động này!", ephemeral=True)
            return
        if self.view.game_state["phase"] != "night":
            await interaction.response.send_message("Chưa phải pha đêm!", ephemeral=True)
            return
        if not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Vui lòng thực hiện hành động qua DM!", ephemeral=True)
            return
        if not self.view.game_state["witch_has_power"]:
            await interaction.response.send_message("Bạn đã sử dụng chức năng!", ephemeral=True)
            return
        target_id = int(self.values[0])
        if target_id not in [m.id for m in self.potential_targets]:
            await interaction.response.send_message("Mục tiêu không hợp lệ!", ephemeral=True)
            return
        self.view.game_state["witch_action_save"] = True
        self.view.game_state["witch_target_save_id"] = target_id
        target_member = next((m for m in self.potential_targets if m.id == target_id), None)
        if target_member:
            await interaction.response.send_message(f"Bạn đã chọn cứu {target_member.display_name}!", ephemeral=True)
        else:
            await interaction.response.send_message("Bạn đã chọn cứu một người, nhưng không tìm thấy mục tiêu!", ephemeral=True)
        logger.info(f"Witch chose to save player: target_id={target_id}, target_name={target_member.display_name if target_member else 'Unknown'}, interaction_id={interaction.id}")
        for child in self.view.children:
            child.disabled = True
        try:
            await interaction.message.edit(view=self.view)
        except discord.errors.NotFound:
            logger.warning(f"Message not found when editing WitchSaveSelect view for interaction_id={interaction.id}")

class WitchKillSelect(discord.ui.Select):
    def __init__(self, alive_players, game_state):
        options = [
            discord.SelectOption(label=member.display_name, value=str(member.id))
            for member in alive_players
        ]
        super().__init__(
            placeholder="Chọn người để giết",
            options=options,
            min_values=1,
            max_values=1
        )
        self.alive_players = alive_players
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id not in self.view.game_state["players"] or self.view.game_state["players"][interaction.user.id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("Bạn không phải người chơi hoặc đã chết!", ephemeral=True)
            return
        if self.view.game_state["is_game_paused"]:
            await interaction.response.send_message("Game đang tạm dừng, không thể thực hiện hành động!", ephemeral=True)
            return
        if self.view.game_state["players"][interaction.user.id]["role"] != "Witch":
            await interaction.response.send_message("Chỉ Phù Thủy mới có thể thực hiện hành động này!", ephemeral=True)
            return
        if self.view.game_state["phase"] != "night":
            await interaction.response.send_message("Chưa phải pha đêm!", ephemeral=True)
            return
        if not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Vui lòng thực hiện hành động qua DM!", ephemeral=True)
            return
        if not self.view.game_state["witch_has_power"]:
            await interaction.response.send_message("Bạn đã sử dụng chức năng!", ephemeral=True)
            return
        target_id = int(self.values[0])
        if target_id not in self.view.game_state["players"] or self.view.game_state["players"][target_id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("Mục tiêu không hợp lệ!", ephemeral=True)
            return
        self.view.game_state["witch_action_kill"] = True
        self.view.game_state["witch_target_kill_id"] = target_id
        target_member = next((m for m in self.alive_players if m.id == target_id), None)
        if target_member:
            await interaction.response.send_message(f"Bạn đã chọn giết {target_member.display_name}!", ephemeral=True)
        else:
            await interaction.response.send_message("Bạn đã chọn giết một người, nhưng không tìm thấy mục tiêu!", ephemeral=True)
        logger.info(f"Witch chose to kill player: target_id={target_id}, target_name={target_member.display_name if target_member else 'Unknown'}, interaction_id={interaction.id}")
        for child in self.view.children:
            child.disabled = True
        try:
            await interaction.message.edit(view=self.view)
        except discord.errors.NotFound:
            logger.warning(f"Message not found when editing WitchKillSelect view for interaction_id={interaction.id}")

class WitchSkipButton(discord.ui.Button):
    def __init__(self, game_state):
        super().__init__(label="Bỏ qua", style=discord.ButtonStyle.grey)
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id not in self.view.game_state["players"] or self.view.game_state["players"][interaction.user.id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("Bạn không phải người chơi hoặc đã chết!", ephemeral=True)
            return
        if self.view.game_state["is_game_paused"]:
            await interaction.response.send_message("Game đang tạm dừng, không thể thực hiện hành động!", ephemeral=True)
            return
        if self.view.game_state["players"][interaction.user.id]["role"] != "Witch":
            await interaction.response.send_message("Chỉ Phù Thủy mới có thể thực hiện hành động này!", ephemeral=True)
            return
        if self.view.game_state["phase"] != "night":
            await interaction.response.send_message("Chưa phải pha đêm!", ephemeral=True)
            return
        if not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Vui lòng thực hiện hành động qua DM!", ephemeral=True)
            return
        self.view.game_state["witch_action_save"] = False
        self.view.game_state["witch_action_kill"] = False
        self.view.game_state["witch_target_save_id"] = None
        self.view.game_state["witch_target_kill_id"] = None
        await interaction.response.send_message("Bạn đã chọn bỏ qua hành động đêm nay.", ephemeral=True)
        logger.info(f"Witch skipped action: interaction_id={interaction.id}")
        for child in self.view.children:
            child.disabled = True
        try:
            await interaction.message.edit(view=self.view)
        except discord.errors.NotFound:
            logger.warning(f"Message not found when editing WitchSkipButton view for interaction_id={interaction.id}")

# View cho bỏ phiếu ban ngày
import asyncio
import discord

async def morning_phase(interaction: discord.Interaction, game_state):
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("morning_phase: Game stopped or paused, skipping")
        return
    game_state["phase"] = "morning"
    main_channel = bot.get_channel(game_state["voice_channel_id"])
  
    text_channel = game_state.get("text_channel")
    if not text_channel:
        logger.error("morning_phase: text_channel is None, cannot proceed with morning phase")
        return
        logger.info(f"Đã khôi phục text_channel: ID={text_channel.id}, Name={text_channel.name}")
    voice_channel = bot.get_channel(game_state["voice_channel_id"])
    villager_role = interaction.guild.get_role(game_state["villager_role_id"])

    # Khôi phục quyền cho kênh text: cho phép chat cho @everyone và vai trò Dân Làng
    if text_channel and villager_role:
        try:
            await text_channel.set_permissions(interaction.guild.default_role, send_messages=True)
            await text_channel.set_permissions(villager_role, send_messages=True)
            logger.info(f"Set text_channel permissions: default_role send_messages=True, villager_role send_messages=True")
        except Exception as e:
            logger.error(f"Failed to restore text channel permissions: {str(e)}")
            await text_channel.send(f"Lỗi: Không thể khôi phục chat trong kênh text: {str(e)}")

    # Khôi phục quyền chat cho từng người chơi trong kênh text
    #for user_id in game_state["players"]:
        #if game_state["players"][user_id]["status"] in ["alive", "wounded"]:
            #member = game_state["member_cache"].get(user_id)
            #if member:
                #try:
                    #await text_channel.set_permissions(member, send_messages=True)
                    #logger.info(f"Set text_channel permissions for player {member.display_name}: send_messages=True")
                #except Exception as e:
                    #logger.error(f"Failed to restore text channel permissions for player ID={member.id}: {str(e)}")

    # Di chuyển tất cả người chơi về kênh chính
    tasks = []
    for user_id in game_state["players"]:
        member = game_state["member_cache"].get(user_id)
        if member:  # Bỏ điều kiện kiểm tra status để di chuyển tất cả
            tasks.append(member.move_to(main_channel))
    await asyncio.gather(*tasks)
    
    # Đảm bảo người chơi đã chết bị mute
    #mute_tasks = []
    #for user_id in game_state["players"]:
        #if game_state["players"][user_id]["status"] == "dead":
            #member = game_state["member_cache"].get(user_id)
            #if member and member.voice:  # Kiểm tra xem người chơi có trong voice không
                #mute_tasks.append(member.edit(mute=True))
    #await asyncio.gather(*mute_tasks)

    # Xử lý người chơi bị nguyền từ đêm trước
    if game_state["demon_werewolf_cursed_player"]:
        cursed_id = game_state["demon_werewolf_cursed_player"]
        if cursed_id in game_state["players"] and game_state["players"][cursed_id]["status"] in ["alive", "wounded"]:
            game_state["players"][cursed_id]["role"] = "Werewolf"
            member = game_state["member_cache"].get(cursed_id)
            if member:
                await retry_api_call(lambda: member.send("Bạn đã bị nguyền và trở thành Sói! Bạn sẽ thức dậy cùng bầy Sói và mất chức năng cũ."))
                await retry_api_call(lambda: game_state["wolf_channel"].set_permissions(member, read_messages=True, send_messages=True))
        #game_state["demon_werewolf_cursed_player"] = None  # Reset sau khi xử lý

    embed = discord.Embed(
        title="☀️ Bình Minh",
        description="Mọi người thức dậy! Thảo luận trong 120 giây trước khi bỏ phiếu (30 giây nếu là ngày đầu tiên).",
        color=discord.Color.gold()
    )
    embed.set_image(url=GIF_URLS["morning"])
    await text_channel.send(embed=embed)
    await play_audio(AUDIO_FILES["morning"], game_state["voice_connection"])
    discussion_time = 30 if game_state["is_first_day"] else 120
    await countdown(text_channel, discussion_time, "thảo luận", game_state)
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused after discussion, skipping voting phase")
        return
    if game_state["is_first_day"]:
        game_state["is_first_day"] = False
        await night_phase(interaction, game_state)
        return
    alive_players = await get_alive_players(interaction, game_state)
    vote_embed = discord.Embed(
        title="🗳️ Pha Bỏ Phiếu",
        description="Chọn người để loại trong 45 giây.",
        color=discord.Color.gold()
    )
    vote_embed.set_image(url=GIF_URLS["vote"])
    vote_message = await text_channel.send(embed=vote_embed, view=VoteView(alive_players, game_state, 45))
    
    # Ghim tin nhắn vote khi bắt đầu voting phase
    await vote_message.pin()
    
    await play_audio(AUDIO_FILES["vote"], game_state["voice_connection"])
    game_state["phase"] = "voting"
    
    # Chờ 15 giây và gửi nhắc nhở đầu tiên
    await asyncio.sleep(15)
    if game_state["is_game_running"] and not game_state["is_game_paused"]:
        await vote_message.reply("🗳️ **Nhắc nhở:** Còn thời gian để bỏ phiếu! Hãy chọn người để loại.")
    
    # Chờ thêm 15 giây (tổng 30 giây), gửi nhắc nhở thứ hai và hiển thị phiếu hiện tại
    await asyncio.sleep(15)
    if game_state["is_game_running"] and not game_state["is_game_paused"]:
        await vote_message.reply("🗳️ **Nhắc nhở:** Còn thời gian để bỏ phiếu! Hãy chọn người để loại.")
        await display_current_votes(interaction, game_state)
    
    # Đếm ngược 15 giây cuối, với đếm ngược 5 giây cuối được hiển thị
    await countdown(game_state["text_channel"], 15, "bỏ phiếu", game_state)
    
    if game_state["is_game_running"] and not game_state["is_game_paused"]:
        await display_final_votes(interaction, game_state)
    
        # Hàm đếm vote (giữ nguyên logic của bạn)
        vote_counts = {}
        skip_votes = 0
        for voter_id in game_state["players"]:
            if game_state["players"][voter_id]["status"] in ["alive", "wounded"]:
                if game_state["players"][voter_id]["role"] in ["Villager", "Tough Guy", "Illusionist"]:
                    if not game_state["math_results"].get(voter_id, False):
                        continue
                target_id = game_state["votes"].get(voter_id, "skip")
                if target_id == "skip":
                    skip_votes += 1
                else:
                    vote_counts[target_id] = vote_counts.get(target_id, 0) + 1
    
        if vote_counts or skip_votes > 0:
            player_vote_counts = {k: v for k, v in vote_counts.items() if k != "skip"}
            if player_vote_counts:
                max_votes = max(player_vote_counts.values())
                candidates = [k for k, v in player_vote_counts.items() if v == max_votes]
                if len(candidates) == 1 and max_votes > skip_votes:
                    eliminated_id = candidates[0]
                    eliminated_member = game_state["member_cache"].get(eliminated_id)
                    if (eliminated_member and eliminated_id in game_state["players"] and
                        game_state["players"][eliminated_id]["status"] in ["alive", "wounded"]):
                        game_state["players"][eliminated_id]["status"] = "dead"
                        await handle_player_death(interaction, eliminated_member, eliminated_id, game_state)
                        hang_embed = discord.Embed(
                            title="⚰️ Kết Quả Bỏ Phiếu",
                            description=f"{eliminated_member.display_name} đã bị ngồi ghế điện với {max_votes} phiếu!)",
                            color=discord.Color.red()
                        )
                        hang_embed.set_image(url=GIF_URLS["hang"])
                        await text_channel.send(embed=hang_embed)
                        await play_audio(AUDIO_FILES["hang"], game_state["voice_connection"])
                        game_logs[interaction.guild.id].append(f"{eliminated_member.display_name} bị ngồi ghế điện với {max_votes} phiếu.")
                elif len(candidates) > 1:
                    await text_channel.send("Có đồng phiếu giữa nhiều người, không ai bị loại!")
                else:
                    await text_channel.send(f"Không ai bị loại! Số phiếu 'bỏ qua' cao hơn hoặc bằng số phiếu cao nhất cho người chơi ({max_votes}).")
            else:
                await text_channel.send(f"Không ai bị loại! Tất cả phiếu đều chọn 'bỏ qua' hoặc dốt toán).")
        else:
            await text_channel.send("Không ai bị loại vì không có phiếu bầu nào!")
    
    # Bỏ ghim tin nhắn vote khi kết thúc voting phase
    await vote_message.unpin()
    
    game_state["votes"].clear()
    if await check_win_condition(interaction, game_state):
        return
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused after voting, skipping night phase")
        return
    # Thêm 10 giây chờ trước khi bắt đầu pha đêm
    await text_channel.send("Pha bỏ phiếu đã kết thúc. Chuẩn bị chuyển sang pha đêm trong 10 giây...")
    await play_audio(AUDIO_FILES["night"], game_state["voice_connection"])
    await countdown(game_state["text_channel"], 10, "chuẩn bị pha đêm", game_state)
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused during pre-night countdown, skipping night phase")
        return
    await night_phase(interaction, game_state)

class VoteView(discord.ui.View):
    def __init__(self, alive_players, game_state, timeout):
        super().__init__(timeout=timeout)
        self.alive_players = alive_players
        self.game_state = game_state
        self.add_item(VoteSelect(alive_players, game_state))
        self.add_item(SkipButton(game_state))

class VoteSelect(discord.ui.Select):
    def __init__(self, alive_players, game_state):
        options = [
            discord.SelectOption(label=member.display_name, value=str(member.id))
            for member in alive_players
        ]
        super().__init__(placeholder="Chọn người để loại", options=options, min_values=1, max_values=1)
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        # Kiểm tra điều kiện cơ bản
        if interaction.user.id not in self.game_state["players"] or self.game_state["players"][interaction.user.id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("Bạn không thể bỏ phiếu!", ephemeral=True)
            return
        if self.game_state["phase"] != "voting":
            await interaction.response.send_message("Chưa phải pha bỏ phiếu!", ephemeral=True)
            return
        if self.game_state["is_game_paused"]:
            await interaction.response.send_message("Game đang tạm dừng, không thể bỏ phiếu!", ephemeral=True)
            return

        # Ghi nhận phiếu bầu
        target_id = int(self.values[0])
        self.game_state["votes"][interaction.user.id] = target_id
        target_member = next((m for m in self.options if m.value == self.values[0]), None)
        target_name = target_member.label if target_member else "Unknown"

        # Kiểm tra điều kiện để hiển thị thông báo phù hợp
        player_data = self.game_state["players"][interaction.user.id]
        # Người chơi đủ điều kiện nếu: vai trò không yêu cầu toán HOẶC đã giải toán đúng
        if player_data["role"] not in NO_NIGHT_ACTION_ROLES or (interaction.user.id in self.game_state["math_results"] and self.game_state["math_results"][interaction.user.id]):
            await interaction.response.send_message(f"Bạn đã bỏ phiếu cho {target_name}!", ephemeral=True)
        else:
            await interaction.response.send_message(f"Bạn đã bỏ phiếu cho {target_name}, nhưng vote của bạn không được tính do không giải đúng bài toán!", ephemeral=True)

class SkipButton(discord.ui.Button):
    def __init__(self, game_state):
        super().__init__(label="Bỏ qua", style=discord.ButtonStyle.grey)
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id not in self.game_state["players"] or self.game_state["players"][interaction.user.id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("Bạn không thể bỏ phiếu!", ephemeral=True)
            return
        if self.game_state["phase"] != "voting":
            await interaction.response.send_message("Chưa phải pha bỏ phiếu!", ephemeral=True)
            return
        if self.game_state["is_game_paused"]:
            await interaction.response.send_message("Game đang tạm dừng, không thể bỏ phiếu!", ephemeral=True)
            return
        if interaction.user.id in self.game_state["math_results"] and not self.game_state["math_results"][interaction.user.id]:
            await interaction.response.send_message("Bạn không có quyền bỏ phiếu do trả lời sai bài toán đêm qua!", ephemeral=True)
            return
        self.game_state["votes"][interaction.user.id] = "skip"
        await interaction.response.send_message("Bạn đã chọn bỏ qua!", ephemeral=True)

async def handle_player_death(interaction: discord.Interaction, member, user_id, game_state):
    guild = bot.get_guild(game_state["guild_id"])
    dead_role = guild.get_role(game_state["dead_role_id"])
    villager_role = guild.get_role(game_state["villager_role_id"])
    wolf_channel = game_state["wolf_channel"]
    dead_channel = game_state["dead_channel"]
    voice_channel = bot.get_channel(game_state["voice_channel_id"])

    # Gán vai trò Người Chết và xóa vai trò Dân Làng
    try:
        if villager_role in member.roles:
            await member.remove_roles(villager_role)
        await member.add_roles(dead_role)
        logger.info(f"Assigned Dead role to member: ID={member.id}, Name={member.display_name}")
    except Exception as e:
        logger.error(f"Failed to assign Dead role to member ID={member.id}: {str(e)}")
        await text_channel.send(f"Lỗi: Không thể gán vai trò Người Chết cho {member.display_name}.")

    # Cấp quyền truy cập kênh dead-chat
    try:
        await dead_channel.set_permissions(member, read_messages=True, send_messages=True)
        await dead_channel.send(f"{member.mention} đã tham gia kênh người chết! Chào mừng đến với nghĩa địa!")
        logger.info(f"Granted access to dead-chat for member: ID={member.id}, Name={member.display_name}")
    except Exception as e:
        logger.error(f"Failed to grant access to dead-chat for member ID={member.id}: {str(e)}")
        await text_channel.send(f"Lỗi: Không thể cấp quyền dead-chat cho {member.display_name}.")

    # Thu hồi quyền truy cập wolf-chat nếu là sói
    player_role = game_state["players"][user_id]["role"]
    if player_role in WEREWOLF_ROLES:
        try:
            await wolf_channel.set_permissions(member, read_messages=False, send_messages=False)
            logger.info(f"Revoked access to wolf-chat for dead werewolf: ID={member.id}, Name={member.display_name}")
        except Exception as e:
            logger.error(f"Failed to revoke access to wolf-chat for member ID={member.id}: {str(e)}")
            await text_channel.send(f"Lỗi: Không thể thu hồi quyền wolf-chat cho {member.display_name}.")

    # Cập nhật trạng thái người chơi
    game_state["players"][user_id]["status"] = "dead"

async def night_phase(interaction: discord.Interaction, game_state):
  
    if not game_state["is_game_running"]:
        logger.info("night_phase: Game is not running, skipping night phase")
        return
    if game_state["is_game_paused"]:
        logger.info("night_phase: Game is paused, skipping night phase")
        return
    if game_state["demon_werewolf_cursed_player"] is not None:
        cursed_id = game_state["demon_werewolf_cursed_player"]
        if cursed_id in game_state["players"] and game_state["players"][cursed_id]["status"] in ["alive", "wounded"]:
            game_state["players"][cursed_id]["role"] = "Werewolf"
            member = game_state["member_cache"].get(cursed_id)
            if member:
                await retry_api_call(lambda: member.send("Bạn đã bị nguyền và trở thành Sói!"))
                await retry_api_call(lambda: game_state["wolf_channel"].set_permissions(member, read_messages=True, send_messages=True))
            game_state["demon_werewolf_cursed_player"] = None
            logger.info(f"Player {cursed_id} transformed into Werewolf")

    game_state["phase"] = "night"
    game_state["night_count"] += 1
    guild = interaction.guild
    main_channel = bot.get_channel(game_state["voice_channel_id"])
  
    text_channel = game_state["text_channel"]
    voice_channel = bot.get_channel(game_state["voice_channel_id"])
    villager_role = interaction.guild.get_role(game_state["villager_role_id"])

    # Thiết lập quyền cho kênh text: cấm chat cho @everyone và vai trò Dân Làng
    if text_channel and villager_role:
        try:
            await text_channel.set_permissions(interaction.guild.default_role, send_messages=False)  # Sửa lỗi defaxult_role
            await text_channel.set_permissions(villager_role, send_messages=False)
            logger.info(f"Set text_channel permissions: default_role send_messages=False, villager_role send_messages=False")
        except Exception as e:
            logger.error(f"Failed to set text channel permissions: {str(e)}")
            await text_channel.send(f"Lỗi: Không thể chặn chat trong kênh text: {str(e)}")

    # Cấm chat cho từng người chơi còn sống trong kênh text
    #for user_id in game_state["players"]:
        #if game_state["players"][user_id]["status"] in ["alive", "wounded"]:
            #member = game_state["member_cache"].get(user_id)
            #if member:
                #try:
                    #await text_channel.set_permissions(member, send_messages=False)
                    #logger.info(f"Set text_channel permissions for player {member.display_name}: send_messages=False")
                #except Exception as e:
                    #logger.error(f"Failed to set text channel permissions for player ID={member.id}: {str(e)}")

    # Di chuyển người chơi vào kênh riêng
    tasks = []
    alive_players = await get_alive_players(interaction, game_state)
    for member in alive_players:
        if member.id in game_state["player_channels"]:
            temp_channel = game_state["player_channels"][member.id]
            tasks.append(member.move_to(temp_channel))
    await asyncio.gather(*tasks)
    
    
    night_embed = discord.Embed(
        title="🌙 Pha Đêm Bắt Đầu",
        description="Mọi người đã bị cô lập để thực hiện hành động đêm!",
        color=discord.Color.dark_blue()
    )
    night_embed.set_image(url=GIF_URLS["night"])
    await game_state["text_channel"].send(embed=night_embed)

    alive_players = await get_alive_players(interaction, game_state)
    if not alive_players:
        logger.error("No alive players found for night phase")
        await text_channel.send("Lỗi: Không tìm thấy người chơi còn sống để tiếp tục pha đêm!")
        return
    game_state["werewolf_target_id"] = None
    game_state["witch_target_save_id"] = None
    game_state["witch_target_kill_id"] = None
    game_state["witch_action_save"] = False
    game_state["witch_action_kill"] = False
    game_state["hunter_target_id"] = None
    game_state["explorer_target_id"] = None
    game_state["math_problems"] = {}
    game_state["math_results"] = {}
    game_state["demon_werewolf_cursed_this_night"] = False    
    ###game_state["demon_werewolf_has_cursed"] = False  # Thêm khai báo này

    if game_state["illusionist_scanned"] and game_state["night_count"] == game_state["illusionist_effect_night"]:
        game_state["illusionist_effect_active"] = True
    else:
        game_state["illusionist_effect_active"] = False

    # Kiểm tra nếu có Sói chết để kích hoạt Sói Quỷ
    werewolf_dead = any(data["role"] in WEREWOLF_ROLES and data["status"] == "dead" for data in game_state["players"].values())
    if werewolf_dead and not game_state["demon_werewolf_activated"]:
        game_state["demon_werewolf_activated"] = True
        for user_id, data in game_state["players"].items():
            if data["role"] == "Demon Werewolf" and data["status"] in ["alive", "wounded"]:
                member = game_state["member_cache"].get(user_id)
                if member:
                    await retry_api_call(lambda: member.send("Một Sói đã chết! Bạn có thể nguyền một người chơi trong đêm này hoặc các đêm tiếp theo."))

    # Gửi thông báo chung cho phe Sói trong wolf-chat
    if game_state["wolf_channel"]:
        await retry_api_call(lambda: game_state["wolf_channel"].send(
            "Phe Sói thức dậy! Chọn người để giết trong 40 giây:",
            view=NightActionView("Werewolf", alive_players, game_state, 40)
        ))

    # Xử lý hành động đêm cho các vai trò khác
    for user_id, data in game_state["players"].items():
        if data["status"] not in ["alive", "wounded"] or data["role"] in NO_NIGHT_ACTION_ROLES:
            continue
        member = game_state["member_cache"].get(user_id)
        if not member or member not in alive_players:
            continue
        if data["role"] == "Seer":
            await retry_api_call(lambda: member.send("Bạn là Tiên Tri! Chọn người để soi trong 40 giây:", view=NightActionView("Seer", alive_players, game_state, 40)))
        elif data["role"] == "Guard":
            await retry_api_call(lambda: member.send("Bạn là Bảo Vệ! Chọn người để bảo vệ trong 40 giây:", view=NightActionView("Guard", alive_players, game_state, 40)))
        elif data["role"] == "Hunter" and game_state["hunter_has_power"]:
            await retry_api_call(lambda: member.send("Bạn là Thợ Săn! Chọn người để giết trong 40 giây (chỉ 1 lần):", view=NightActionView("Hunter", alive_players, game_state, 40)))
        elif data["role"] == "Explorer" and game_state["night_count"] >= 2 and game_state.get("explorer_can_act", False):
            await retry_api_call(lambda: member.send("Bạn là Người Khám Phá! Chọn người để giết trong 40 giây:", view=NightActionView("Explorer", alive_players, game_state, 40)))
        elif data["role"] == "Demon Werewolf":
            if game_state["demon_werewolf_activated"] and not game_state["demon_werewolf_has_cursed"] and game_state["demon_werewolf_cursed_player"]==None:
                try:
                    await retry_api_call(lambda: member.send(
                        "Bạn là Sói Quỷ! Chọn người để nguyền trong 40 giây (chỉ 1 lần duy nhất):",
                        view=NightActionView("Demon Werewolf", alive_players, game_state, 40)
                    ))
                    logger.info(f"Đã gửi lựa chọn nguyền cho Sói Quỷ: {member.id}")
                except discord.errors.Forbidden:
                    logger.error(f"Không có quyền gửi DM cho Sói Quỷ: {member.id}")
                except Exception as e:
                    logger.error(f"Lỗi gửi view cho Sói Quỷ {member.id}: {str(e)}")
            elif game_state["demon_werewolf_has_cursed"]:
                try:
                    await retry_api_call(lambda: member.send("Bạn đã nguyền một người trước đó! Chức năng nguyền của bạn đã bị vô hiệu hóa."))
                    logger.info(f"Thông báo Sói Quỷ đã mất chức năng nguyền: {member.id}")
                except discord.errors.Forbidden:
                    logger.error(f"Không có quyền gửi DM cho Sói Quỷ: {member.id}")
                except Exception as e:
                    logger.error(f"Lỗi gửi thông báo cho Sói Quỷ {member.id}: {str(e)}")
    
    # Xử lý hành động của Sói Ám Sát
    for user_id, data in game_state["players"].items():
        if data["role"] == "Assassin Werewolf" and data["status"] in ["alive", "wounded"] and not game_state["assassin_werewolf_has_acted"]:
            assassin_member = game_state["member_cache"].get(user_id)
            if assassin_member:
                view = AssassinActionView(game_state, user_id)
                await assassin_member.send("Bạn là Sói Ám Sát. Chọn một người chơi và đoán vai trò của họ:", view=view)
    
    # Thêm hành động cho Detective
    detective_id = next((uid for uid, data in game_state["players"].items() if data["role"] == "Detective"), None)
    if detective_id and not game_state["detective_has_used_power"]:
        detective_member = game_state["member_cache"].get(detective_id)
        if detective_member:
            alive_players = await get_alive_players(interaction, game_state)
            view = DetectiveSelectView(detective_id, alive_players, game_state)
            await detective_member.send("Chọn hai người chơi để kiểm tra phe:", view=view)
                  
    # Gửi bài toán cho các vai không có hành động đêm
    for user_id, data in game_state["players"].items():
        if data["status"] not in ["alive", "wounded"] or data["role"] not in ["Villager", "Tough Guy", "Illusionist"]:
            continue
        member = game_state["member_cache"].get(user_id)
        if not member or member not in alive_players:
            continue
        try:
            math_problem = await generate_math_problem(game_state["math_problems"])
            game_state["math_problems"][user_id] = math_problem
            options_str = "\n".join([f"{i+1}. {opt}" for i, opt in enumerate(math_problem["options"])])
            await retry_api_call(lambda: member.send(
                f"Bạn phải giải bài toán sau để được quyền bỏ phiếu vào ban ngày: **{math_problem['problem']}**.\n"
                f"Chọn đáp án đúng trong 40 giây:\n{options_str}",
                view=NightMathView(user_id, math_problem["options"], math_problem["answer"], game_state)
            ))
        except Exception as e:
            logger.error(f"Failed to generate math problem for user_id={user_id}: {str(e)}")
            await retry_api_call(lambda: member.send("Lỗi: Không thể tạo bài toán. Bạn được quyền bỏ phiếu mặc định."))
            game_state["math_results"][user_id] = True

    await countdown(game_state["text_channel"], 40, "hành động đêm", game_state)
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused during night phase, skipping further actions")
        return

    # Lưu mục tiêu ban đầu của Hunter
    original_hunter_target_id = game_state["hunter_target_id"]

    # Xác định các mục tiêu tiềm năng cho Phù Thủy
    potential_targets = []
    target_ids = set()
    kill_counts = {}  # Từ điển để đếm số lần bị giết của mỗi người chơi
    
    # Thu thập tất cả các hành động giết
    actions = []
    
    # Hành động của Sói
    if game_state["werewolf_target_id"] and not game_state["demon_werewolf_cursed_this_night"]:
        actions.append(("werewolf", game_state["werewolf_target_id"]))
    
    # Hành động của Thợ Săn
    if game_state["hunter_target_id"]:
        actions.append(("hunter", game_state["hunter_target_id"]))
    
    # Hành động của Người Khám Phá
    if game_state["night_count"] >= 2 and game_state["explorer_target_id"]:
        explorer_target_id = game_state["explorer_target_id"]
        target_role = game_state["players"][explorer_target_id]["role"]
        if target_role in ["Werewolf", "Wolfman", "Assassin Werewolf", "Demon Werewolf"]:
            actions.append(("explorer", explorer_target_id))
        else:
            explorer_id = next(uid for uid, d in game_state["players"].items() if d["role"] == "Explorer" and d["status"] in ["alive", "wounded"])
            actions.append(("explorer", explorer_id))
    
    # Hành động của Sói Ám Sát
    assassin_id = next((uid for uid, d in game_state["players"].items() if d["role"] == "Assassin Werewolf" and d["status"] in ["alive", "wounded"]), None)
    if assassin_id and game_state["assassin_werewolf_has_acted"]:
        target_id = game_state["assassin_werewolf_target_id"]
        role_guess = game_state["assassin_werewolf_role_guess"]
        if target_id in game_state["players"] and game_state["players"][target_id]["status"] in ["alive", "wounded"]:
            actual_role = game_state["players"][target_id]["role"]
            if actual_role == role_guess:
                actions.append(("assassin", target_id))
            else:
                actions.append(("assassin", assassin_id))
    
    # Đếm số lần bị giết, bỏ qua người được Bảo Vệ
    protected_id = game_state["protected_player_id"]
    for action_type, target_id in actions:
        if target_id != protected_id:
            kill_counts[target_id] = kill_counts.get(target_id, 0) + 1
    
    # Xác định ai sẽ chết và thêm vào potential targets
    for user_id, count in kill_counts.items():
        data = game_state["players"].get(user_id)
        if data and data["status"] in ["alive", "wounded"]:
            if data["role"] == "Tough Guy":
                # Touch Guy chết nếu: alive + >=2 lần giết, hoặc wounded + >=1 lần giết
                if (data["status"] == "alive" and count >= 2) or (data["status"] == "wounded" and count >= 1):
                    target = game_state["member_cache"].get(user_id)
                    if target:
                        potential_targets.append(target)
                        target_ids.add(user_id)
            else:
                # Người thường chết nếu bị giết ít nhất 1 lần
                if count >= 1:
                    target = game_state["member_cache"].get(user_id)
                    if target:
                        potential_targets.append(target)
                        target_ids.add(user_id)
    
    logger.info(f"Potential targets for Witch: {target_ids}")
    for user_id, data in game_state["players"].items():
        if data["role"] == "Witch" and data["status"] in ["alive", "wounded"]:
            member = game_state["member_cache"].get(user_id)
            if not member:
                continue
            if game_state["witch_has_power"]:
                if potential_targets:
                    target_names = ", ".join([t.display_name for t in potential_targets])
                    await retry_api_call(lambda: member.send(
                        f"Đêm nay, {target_names} sẽ bị úp sọt. Chọn hành động trong 20 giây:",
                        view=WitchActionView(alive_players, potential_targets, game_state, timeout=20)
                    ))
                    logger.info(f"Sent Witch notification: targets={target_names}, user_id={user_id}")
                else:
                    await retry_api_call(lambda: member.send(
                        "Không ai lên dĩa đêm nay! Chọn người để bắt uống rượu độc hoặc bỏ qua trong 20 giây:",
                        view=WitchActionView(alive_players, [], game_state, timeout=20)
                    ))
                    logger.info(f"Sent Witch notification: no targets, user_id={user_id}")
            else:
                await retry_api_call(lambda: member.send("Không ai lên dĩa đêm nay!"))
                logger.info(f"Sent Witch no-power notification: user_id={user_id}")
            break
    await countdown(game_state["text_channel"], 20, "đêm", game_state)
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused after Witch phase, skipping further actions")
        return

    # Xử lý hành động của Phù Thủy
    dead_players = []
    if game_state["witch_has_power"]:
        if game_state["witch_action_save"] and game_state["witch_target_save_id"]:
            target_id = game_state["witch_target_save_id"]
            if target_id in game_state["players"] and game_state["players"][target_id]["status"] in ["alive", "wounded"]:
                target_data = game_state["players"][target_id]
                logger.info(f"Witch saving player: target_id={target_id}")
                # Kiểm tra nếu là Touch Guy và sẽ chết
                if target_data["role"] == "Tough Guy":
                    count = kill_counts.get(target_id, 0)
                    if (target_data["status"] == "alive" and count >= 2) or (target_data["status"] == "wounded" and count >= 1):
                        target_data["status"] = "wounded"
                        logger.info(f"Witch saved Tough Guy: target_id={target_id}, status set to wounded")
                    else:
                        logger.info(f"Witch saved Tough Guy but no status change needed: target_id={target_id}")
                # Hủy các hành động giết
                if game_state["werewolf_target_id"] == target_id:
                    game_state["werewolf_target_id"] = None
                if game_state["hunter_target_id"] == target_id:
                    game_state["hunter_target_id"] = None
                if game_state["explorer_target_id"] == target_id:
                    game_state["explorer_target_id"] = None
                witch_member = next((m for uid, d in game_state["players"].items() if d["role"] == "Witch" and d["status"] in ["alive", "wounded"] and (m := game_state["member_cache"].get(uid))), None)
                if witch_member:
                    target_member = game_state["member_cache"].get(target_id)
                    if target_member:
                        await retry_api_call(lambda: witch_member.send(f"Bạn đã cứu {target_member.display_name} thành công! Từ đêm sau, bạn sẽ không nhận thông tin về người bị lên dĩa nữa."))
                    else:
                        await retry_api_call(lambda: witch_member.send("Bạn đã cứu một người thành công! Từ đêm sau, bạn sẽ không nhận thông tin về người bị lên dĩa nữa."))
            game_state["witch_has_power"] = False

        if game_state["witch_action_kill"] and game_state["witch_target_kill_id"]:
            target_id = game_state["witch_target_kill_id"]
            if target_id in game_state["players"] and game_state["players"][target_id]["status"] in ["alive", "wounded"]:
                target_data = game_state["players"][target_id]
                member = game_state["member_cache"].get(target_id)
                if member:
                    if target_id == game_state["protected_player_id"]:
                        logger.info(f"Witch kill failed: target_id={target_id} is protected")
                        witch_member = next((m for uid, d in game_state["players"].items() if d["role"] == "Witch" and d["status"] in ["alive", "wounded"] and (m := game_state["member_cache"].get(uid))), None)
                        if witch_member:
                            await retry_api_call(lambda: witch_member.send("Bạn đã sử dụng quyền năng! Từ đêm sau, bạn sẽ không nhận thông tin về người bị lên dĩa nữa."))
                    else:
                        logger.info(f"Witch killing player: target_id={target_id}, target_name={member.display_name}")
                        if target_data["role"] == "Tough Guy" and target_data["status"] == "alive":
                            target_data["status"] = "wounded"
                            logger.info(f"Tough Guy wounded by Witch: target_id={target_id}")
                        else:
                            target_data["status"] = "dead"
                            dead_players.append(member.display_name)
                            await handle_player_death(interaction, member, target_id, game_state)
                            logger.info(f"Witch killed player: target_id={target_id}")
                        witch_member = next((m for uid, d in game_state["players"].items() if d["role"] == "Witch" and d["status"] in ["alive", "wounded"] and (m := game_state["member_cache"].get(uid))), None)
                        if witch_member:
                            await retry_api_call(lambda: witch_member.send("Bạn đã sử dụng quyền năng! Từ đêm sau, bạn sẽ không nhận thông tin về người bị lên dĩa nữa."))
            game_state["witch_has_power"] = False

    # Xử lý các cái chết từ Sói và Thợ Săn
    for target_id, source in [(game_state["werewolf_target_id"], "Werewolf"), (game_state["hunter_target_id"], "Hunter")]:
        if target_id and target_id != game_state["protected_player_id"] and target_id in game_state["players"]:
            target_data = game_state["players"].get(target_id)
            if target_data["status"] in ["alive", "wounded"]:
                member = game_state["member_cache"].get(target_id)
                if member:
                    logger.info(f"Processing death by {source}: target_id={target_id}, target_name={member.display_name}")
                    if source == "Werewolf" and game_state["demon_werewolf_cursed_this_night"]:
                        logger.info(f"Werewolf target not killed because Demon Werewolf cursed this night: target_id={target_id}")
                    elif target_data["role"] == "Tough Guy" and target_data["status"] == "alive":
                        target_data["status"] = "wounded"
                        logger.info(f"Tough Guy wounded by {source}: target_id={target_id}")
                    else:
                        target_data["status"] = "dead"
                        dead_players.append(member.display_name)
                        await handle_player_death(interaction, member, target_id, game_state)

    # Cập nhật trạng thái Hunter sau khi xử lý tất cả hành động
    if original_hunter_target_id is not None:
        game_state["hunter_has_power"] = False
        for user_id_hunter, data_hunter in game_state["players"].items():
            if data_hunter["role"] == "Hunter" and data_hunter["status"] in ["alive", "wounded"]:
                hunter_member = game_state["member_cache"].get(user_id_hunter)
                if hunter_member:
                    await retry_api_call(lambda: hunter_member.send("Bạn đã sử dụng quyền năng của mình! Bạn không còn chức năng nữa."))
                break
    # Xử lý các cái chết của Khám phá
    if game_state["night_count"] >= 2 and game_state.get("explorer_id") in game_state["players"] and game_state["players"][game_state["explorer_id"]]["status"] in ["alive", "wounded"]:
        if game_state["explorer_target_id"] is None:
            game_state["explorer_can_act"] = False
            explorer_member = game_state["member_cache"].get(game_state["explorer_id"])
            if explorer_member:
                await retry_api_call(lambda: explorer_member.send("Bạn đã không chọn ai để khám phá, bạn đã mất chức năng của mình!"))
        else:
            target_id = game_state["explorer_target_id"]
            if target_id in game_state["players"] and game_state["players"][target_id]["status"] in ["alive", "wounded"]:
                target_role = game_state["players"][target_id]["role"]
                explorer_id = game_state["explorer_id"]
                explorer_member = game_state["member_cache"].get(explorer_id)
                if target_role in ["Werewolf", "Wolfman", "Assassin Werewolf", "Demon Werewolf"]:
                    if target_id == game_state["witch_target_save_id"]:
                        if explorer_member:
                            await retry_api_call(lambda: explorer_member.send("Bạn và mục tiêu không chết! Bạn vẫn giữ chức năng."))
                    elif target_id != game_state["protected_player_id"]:
                        target_data = game_state["players"][target_id]
                        member = game_state["member_cache"].get(target_id)
                        if member:
                            if target_data["role"] == "Tough Guy" and target_data["status"] == "alive":
                                target_data["status"] = "wounded"
                            else:
                                target_data["status"] = "dead"
                                dead_players.append(member.display_name)
                                await handle_player_death(interaction, member, target_id, game_state)
                            if explorer_member:
                                await retry_api_call(lambda: explorer_member.send(f"Bạn đã khám phá và giết {member.display_name}!"))
                else:
                    if explorer_id == game_state["witch_target_save_id"]:
                        if explorer_member:
                            await retry_api_call(lambda: explorer_member.send("Bạn và mục tiêu không chết! Bạn vẫn giữ chức năng."))
                    elif explorer_id != game_state["protected_player_id"]:
                        explorer_data = game_state["players"][explorer_id]
                        if explorer_data["role"] == "Tough Guy" and explorer_data["status"] == "alive":
                            explorer_data["status"] = "wounded"
                        else:
                            explorer_data["status"] = "dead"
                            dead_players.append(explorer_member.display_name)
                            await handle_player_death(interaction, explorer_member, explorer_id, game_state)
                        if explorer_member:
                            await retry_api_call(lambda: explorer_member.send("Bạn đã khám phá sai và tự sát!"))
    
    # Xử lý hành động của Sói Ám Sát
    if game_state["assassin_werewolf_has_acted"] and game_state["assassin_werewolf_target_id"] and game_state["assassin_werewolf_role_guess"]:
        target_id = game_state["assassin_werewolf_target_id"]
        role_guess = game_state["assassin_werewolf_role_guess"]
        assassin_id = next((uid for uid, d in game_state["players"].items() if d["role"] == "Assassin Werewolf"), None)
        if target_id in game_state["players"] and game_state["players"][target_id]["status"] in ["alive", "wounded"]:
            actual_role = game_state["players"][target_id]["role"]
            target_member = game_state["member_cache"].get(target_id)
            assassin_member = game_state["member_cache"].get(assassin_id)
            if actual_role == role_guess:
                # Đoán đúng, kiểm tra xem mục tiêu có được cứu hay không
                if target_id != game_state["witch_target_save_id"] and target_id != game_state["protected_player_id"]:
                    target_data = game_state["players"][target_id]
                    if target_data["role"] == "Tough Guy" and target_data["status"] == "alive":
                        target_data["status"] = "wounded"
                    else:
                        target_data["status"] = "dead"
                        dead_players.append(target_member.display_name)
                        await handle_player_death(interaction, target_member, target_id, game_state)
            else:
                # Đoán sai, kiểm tra xem Sói Ám Sát có được cứu hay không
                if assassin_id != game_state["witch_target_save_id"] and assassin_id != game_state["protected_player_id"]:
                    assassin_data = game_state["players"][assassin_id]
                    if assassin_data["role"] == "Tough Guy" and assassin_data["status"] == "alive":
                        assassin_data["status"] = "wounded"
                    else:
                        assassin_data["status"] = "dead"
                        dead_players.append(assassin_member.display_name)
                        await handle_player_death(interaction, assassin_member, assassin_id, game_state)
        game_state["assassin_werewolf_target_id"] = None
        game_state["assassin_werewolf_role_guess"] = None
    # Xử lý các nguyền Demon Werewolf
    

    if game_state["text_channel"]:
        if dead_players:
            death_embed = discord.Embed(
                title="💀 Thông Báo Người Ra Đi",
                description=f"{', '.join(dead_players)} đã lên bàn thờ ngắm gà ăn xôi nếp!",
                color=discord.Color.red()
            )
            death_embed.set_image(url=GIF_URLS["death"])
            await text_channel.send(embed=death_embed)
            logger.info(f"Announced deaths: {dead_players}")
        else:
            no_death_embed = discord.Embed(
                title="💀 Thông Báo Người Ra Đi",
                description="Không ai từ bỏ làng trong đêm nay!",
                color=discord.Color.red()
            )
            await text_channel.send(embed=no_death_embed)
            logger.info("No deaths announced")
          
    # Log trạng thái của Demon Werewolf sau mỗi đêm
    logger.info(f"Demon Werewolf cursed player: {game_state['demon_werewolf_cursed_player']}")
  
    game_state["previous_protected_player_id"] = game_state["protected_player_id"]
    game_state["protected_player_id"] = None
    game_state["demon_werewolf_cursed_this_night"] = False
    if await check_win_condition(interaction, game_state):
        return
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused, skipping morning phase")
        return
    if text_channel:
        await text_channel.set_permissions(interaction.guild.default_role, send_messages=True)
    if voice_channel:
        await voice_channel.set_permissions(interaction.guild.default_role, speak=True)
    await morning_phase(interaction, game_state)

# Hàm reset game state mà không xóa thông tin tạm thời
async def reset_game_state(interaction: discord.Interaction, game_state):
    if not isinstance(interaction, discord.Interaction):
        logger.error(f"reset_game_state called with invalid type: {type(interaction)}")
        logger.error(f"Call stack: {''.join(traceback.format_stack())}")
        if hasattr(interaction, 'channel'):
            await interaction.channel.send("Lỗi: Hàm này chỉ hỗ trợ slash commands!")
        return
    
    guild_id = interaction.guild.id
    if game_state["reset_in_progress"]:
        logger.warning(f"Reset already in progress, ignoring reset request by {interaction.user.id}")
        await interaction.channel.send("Đang thực hiện reset, vui lòng chờ!")
        return
    if not game_state["is_game_running"]:
        logger.info(f"No game running to reset, requested by {interaction.user.id}")
        await interaction.channel.send("Chưa có game nào để reset!")
        return
    game_state["reset_in_progress"] = True
    logger.info(f"Resetting game state: is_game_running={game_state['is_game_running']}, guild_id={game_state.get('guild_id')}")

    try:
        # Gửi log kết quả game
        if guild_id in game_logs:
            embed = discord.Embed(title="Kết Quả Game", color=discord.Color.blue())
            role_list = []
            for user_id, data in game_state["players"].items():
                member = game_state["member_cache"].get(user_id)
                if member:
                    status = "Sống" if data["status"] in ["alive", "wounded"] else "Chết"
                    role_list.append(f"{member.display_name}: {data['role']} ({status})")
            log_text = "\n".join(game_logs[guild_id] + ["Danh sách cuối game:"] + role_list)
            if len(log_text) > 1024:
                log_text = log_text[-1024:]
            embed.add_field(name="Tình trạng", value=log_text or "Không có dữ liệu", inline=False)
            embed.set_footer(text=f"Log được gửi bởi {interaction.user.name}")
            await interaction.channel.send(embed=embed)
        else:
            await interaction.channel.send("Không có dữ liệu nào được ghi lại trong game.")

        # Lấy các kênh và vai trò
        dead_channel = game_state.get("dead_channel") or discord.utils.get(interaction.guild.text_channels, name="dead-chat")
        wolf_channel = game_state.get("wolf_channel") or discord.utils.get(interaction.guild.text_channels, name="wolf-chat")
        voice_channel = bot.get_channel(game_state["voice_channel_id"])
        main_channel = bot.get_channel(game_state["voice_channel_id"])
        guild = bot.get_guild(game_state["guild_id"])
        villager_role = guild.get_role(game_state["villager_role_id"]) if game_state.get("villager_role_id") else None
        dead_role = guild.get_role(game_state["dead_role_id"]) if game_state.get("dead_role_id") else None
        werewolf_role = guild.get_role(game_state["werewolf_role_id"]) if game_state.get("werewolf_role_id") else None

        # Làm mới member_cache
        try:
            game_state["member_cache"] = {m.id: m for m in await retry_api_call(lambda: interaction.guild.members)}
            logger.info(f"Refreshed member_cache with {len(game_state['member_cache'])} members")
        except Exception as e:
            logger.error(f"Failed to refresh member_cache: {str(e)}")
            await text_channel.send("Lỗi: Không thể làm mới danh sách thành viên server.")
        
        # Di chuyển tất cả người chơi về kênh chính và unmute
        move_tasks = []
        for user_id in game_state["players"]:
            member = game_state["member_cache"].get(user_id)
            if member:
                move_tasks.append(member.move_to(main_channel))
                if member.voice:  # Unmute nếu người chơi đang ở trong voice
                    move_tasks.append(member.edit(mute=False))
        await asyncio.gather(*move_tasks)

        # Xóa vai trò khỏi người chơi
        for user_id in game_state["players"]:
            member = game_state["member_cache"].get(user_id)
            if member:
                try:
                    if villager_role and villager_role in member.roles:
                        await member.remove_roles(villager_role)
                    if dead_role and dead_role in member.roles:
                        await member.remove_roles(dead_role)
                    logger.info(f"Removed Villager/Dead roles from member: ID={member.id}, Name={member.display_name}")
                except Exception as e:
                    logger.error(f"Failed to remove roles from member ID={member.id}: {str(e)}")
                    await text_channel.send(f"Lỗi: Không thể xóa vai trò khỏi {member.display_name}: {str(e)}")

        # Unmute và khôi phục quyền cho người chơi trong kênh voice
        if voice_channel:
            for user_id in game_state["players"]:
                member = game_state["member_cache"].get(user_id)
                if member and member in voice_channel.members:
                    try:
                        await member.edit(mute=False)
                        logger.info(f"Unmuted member: ID={member.id}, Name={member.display_name}")
                    except Exception as e:
                        logger.error(f"Failed to unmute member ID={member.id}: {str(e)}")
                        await text_channel.send(f"Lỗi: Không thể unmute {member.display_name}: {str(e)}")
                      
            # Khôi phục quyền nói cho @everyone trong kênh voice
            try:
                await voice_channel.set_permissions(interaction.guild.default_role, speak=True)
                logger.info(f"Restored speak permission for @everyone in voice_channel: ID={voice_channel.id}")
            except Exception as e:
                logger.error(f"Failed to restore speak permission in voice_channel: {str(e)}")
                await text_channel.send(f"Lỗi: Không thể khôi phục quyền voice cho @everyone: {str(e)}")

        # Xóa các kênh voice riêng biệt
        if "player_channels" in game_state:
            for channel in game_state["player_channels"].values():
                try:
                    await channel.delete()
                    logger.info(f"Deleted player channel: ID={channel.id}")
                except Exception as e:
                    logger.error(f"Failed to delete player channel ID={channel.id}: {str(e)}")
                    await text_channel.send(f"Lỗi: Không thể xóa kênh voice riêng: {str(e)}")
            game_state["player_channels"].clear()

        # Đồng bộ hoặc khôi phục quyền của kênh văn bản
        text_channel = game_state.get("text_channel") or interaction.channel
        if text_channel:
            try:
                if text_channel.category:
                    await text_channel.edit(sync_permissions=True)
                    logger.info(f"Synchronized permissions for channel {text_channel.name} with category {text_channel.category.name}")
                else:
                    await text_channel.set_permissions(interaction.guild.default_role, send_messages=True)
                    logger.info(f"Restored default send_messages permission for channel {text_channel.name}")
            except Exception as e:
                logger.error(f"Failed to synchronize or restore permissions for channel {text_channel.name}: {str(e)}")
                await text_channel.send(f"Lỗi: Không thể đồng bộ hoặc khôi phục quyền cho kênh {text_channel.name}: {str(e)}")

        # Đồng bộ hoặc khôi phục quyền của kênh voice
        voice_channel = bot.get_channel(game_state["voice_channel_id"])
        if voice_channel:
            # Unmute người chơi
            for user_id in game_state["players"]:
                member = game_state["member_cache"].get(user_id)
                if member and member in voice_channel.members:
                    try:
                        await member.edit(mute=False)
                        logger.info(f"Unmuted member: ID={member.id}, Name={member.display_name}")
                    except Exception as e:
                        logger.error(f"Failed to unmute member ID={member.id}: {str(e)}")
                        await text_channel.send(f"Lỗi: Không thể unmute {member.display_name}: {str(e)}")
            
            # Khôi phục quyền cho @everyone
            try:
                if voice_channel.category:
                    # Nếu kênh thuộc category, đồng bộ quyền với category
                    await voice_channel.edit(sync_permissions=True)
                    logger.info(f"Synchronized permissions for voice channel {voice_channel.name} with category {voice_channel.category.name}")
                else:
                    # Nếu không có category, đặt quyền mặc định
                    await voice_channel.set_permissions(interaction.guild.default_role, speak=True, connect=True)
                    logger.info(f"Restored default permissions (speak=True, connect=True) for @everyone in voice_channel: ID={voice_channel.id}")
            except Exception as e:
                logger.error(f"Failed to restore permissions for voice channel {voice_channel.name}: {str(e)}")
                await text_channel.send(f"Lỗi: Không thể khôi phục quyền cho kênh voice {voice_channel.name}: {str(e)}")

        # Xóa kênh dead-chat và wolf-chat
        if dead_channel:
            try:
                await dead_channel.delete()
                logger.info(f"Deleted dead-chat: ID={dead_channel.id}")
            except Exception as e:
                logger.error(f"Failed to delete dead-chat: {str(e)}")
                await text_channel.send(f"Lỗi: Không thể xóa kênh dead-chat: {str(e)}")
        if wolf_channel:
            try:
                await wolf_channel.delete()
                logger.info(f"Deleted wolf-chat: ID={wolf_channel.id}")
            except Exception as e:
                logger.error(f"Failed to delete wolf-chat: {str(e)}")
                await text_channel.send(f"Lỗi: Không thể xóa kênh wolf-chat: {str(e)}")

        # Xóa vai trò game
        if villager_role:
            try:
                await villager_role.delete()
                logger.info(f"Deleted Villager role: ID={villager_role.id}")
            except Exception as e:
                logger.error(f"Failed to delete Villager role: {str(e)}")
                await text_channel.send(f"Lỗi: Không thể xóa vai trò Dân Làng: {str(e)}")
        if dead_role:
            try:
                await dead_role.delete()
                logger.info(f"Deleted Dead role: ID={dead_role.id}")
            except Exception as e:
                logger.error(f"Failed to delete Dead role: {str(e)}")
                await text_channel.send(f"Lỗi: Không thể xóa vai trò Người Chết: {str(e)}")
        if werewolf_role:
            try:
                await werewolf_role.delete()
                logger.info(f"Deleted Werewolf role: ID={werewolf_role.id}")
            except Exception as e:
                logger.error(f"Failed to delete Werewolf role: {str(e)}")
                await text_channel.send(f"Lỗi: Không thể xóa vai trò Werewolf: {str(e)}")

        # Reset game_state
        game_state["players"].clear()
        game_state["is_game_running"] = False
        game_state["is_game_paused"] = False
        game_state["phase"] = "none"
        game_state["text_channel"] = interaction.channel
        game_state["is_first_day"] = True
        game_state["protected_player_id"] = None
        game_state["previous_protected_player_id"] = None
        game_state["werewolf_target_id"] = None
        game_state["witch_target_id"] = None
        game_state["witch_action"] = None
        game_state["witch_has_power"] = True
        game_state["hunter_target_id"] = None
        game_state["hunter_has_power"] = True
        game_state["explorer_target_id"] = None
        game_state["votes"] = {}
        game_state["wolf_channel"] = None
        game_state["dead_channel"] = None
        game_state["illusionist_scanned"] = False
        game_state["illusionist_effect_active"] = False
        game_state["illusionist_effect_night"] = 0
        game_state["villager_role_id"] = None
        game_state["dead_role_id"] = None
        game_state["werewolf_role_id"] = None
        game_state["night_count"] = 0
        game_state["demon_werewolf_activated"] = False
        game_state["demon_werewolf_cursed_player"] = None
        game_state["demon_werewolf_cursed_this_night"] = False
        game_state["demon_werewolf_has_cursed"] = False
        game_state["assassin_werewolf_has_acted"] = False
        game_state["assassin_werewolf_target_id"] = None
        game_state["assassin_werewolf_role_guess"] = None
        game_state["detective_has_used_power"] = False
        game_state["detective_target1_id"] = None
        game_state["detective_target2_id"] = None
        game_logs[guild_id].clear()

        await text_channel.send("Game đã được reset thành công! Tất cả trạng thái đã được khôi phục.")
    finally:
        game_state["reset_in_progress"] = False

# Hàm xử lý khi game kết thúc và cung cấp tùy chọn
async def handle_game_end(interaction: discord.Interaction, game_state):
    if game_state["text_channel"] is not None:
        await game_state["text_channel"].send("Game đang kết thúc và dữ liệu đang được xóa, vui lòng chờ...")
    else:
        logger.warning("Text channel not set, cannot send game ending message")
    # Reset game state trước
    await reset_game_state(interaction, game_state)
    
    # Thêm khoảng thời gian chờ 5 giây để đảm bảo các tác vụ trong reset_game_state hoàn tất
    await asyncio.sleep(5)
    
    # Phát âm thanh end_game.mp3 trước khi bot rời kênh voice
    if game_state["voice_connection"] and game_state["voice_connection"].is_connected():
        await play_audio(AUDIO_FILES["end_game"], game_state["voice_connection"])
    
    # Bot rời kênh voice sau khi phát âm thanh
    if game_state["voice_connection"] and game_state["voice_connection"].is_connected():
        try:
            await game_state["voice_connection"].disconnect()
            logger.info(f"Bot disconnected from voice channel: ID={game_state['voice_channel_id']}")
        except Exception as e:
            logger.error(f"Failed to disconnect from voice channel ID={game_state['voice_channel_id']}: {str(e)}")
        game_state["voice_connection"] = None
    
    if game_state["text_channel"] is not None:
        await game_state["text_channel"].send("Game đã kết thúc. Chọn hành động tiếp theo:", view=GameEndView(game_state["temp_admin_id"], interaction, game_state))
    else:
        logger.warning("Text channel not set, cannot send game end options message")

# View cho tùy chọn khi game kết thúc
class GameEndView(discord.ui.View):
    def __init__(self, admin_id, interaction: discord.Interaction, game_state):
        super().__init__(timeout=60)
        self.admin_id = admin_id
        self.interaction = interaction
        self.game_state = game_state

    @discord.ui.button(label="Start New Game", style=discord.ButtonStyle.green)
    async def start_new_game(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.admin_id:
            await interaction.response.send_message("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        await interaction.response.send_message("Bắt đầu game mới...", ephemeral=True)
        await start_new_game_with_same_setup(self.interaction, self.game_state)

    @discord.ui.button(label="End Game", style=discord.ButtonStyle.red)
    async def end_game(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.admin_id:
            await interaction.response.send_message("Chỉ người chạy lệnh !start_game được thao tác!", ephemeral=True)
            return
        await interaction.response.send_message("Kết thúc game.", ephemeral=True)
        self.game_state["temp_players"] = []
        self.game_state["temp_roles"] = {role: 0 for role in ROLES}
        self.game_state["temp_admin_id"] = None
        self.game_state["voice_channel_id"] = None
        self.game_state["guild_id"] = None
        self.game_state["text_channel"] = None
        self.game_state["member_cache"].clear()

# Hàm bắt đầu game mới với cùng người chơi và vai trò
async def start_new_game_with_same_setup(interaction: discord.Interaction, game_state):
    if not game_state["temp_players"] or not game_state["temp_roles"]:
        await game_state["text_channel"].send("Lỗi: Không có thông tin người chơi hoặc vai trò để khởi động lại game!")
        return
    guild = bot.get_guild(game_state["guild_id"])
    voice_channel = bot.get_channel(game_state["voice_channel_id"])
    
    # Làm mới member_cache
    game_state["member_cache"] = {m.id: m for m in await retry_api_call(lambda: guild.members)}
    
    # Kiểm tra trạng thái voice của người chơi
    current_members = {m.id for m in voice_channel.members if not m.bot}
    missing_players = [uid for uid in game_state["temp_players"] if uid not in current_members]
    if missing_players:
        await game_state["text_channel"].send(f"Các người chơi sau không còn trong kênh voice: {', '.join([str(uid) for uid in missing_players])}")
        return
    
    # Bot tham gia lại kênh voice
    try:
        game_state["voice_connection"] = await voice_channel.connect()
        logger.info(f"Bot joined voice channel: ID={voice_channel.id}, Name={voice_channel.name}")
    except Exception as e:
        logger.error(f"Failed to join voice channel ID={voice_channel.id}: {str(e)}")
        await game_state["text_channel"].send(f"Lỗi: Không thể tham gia kênh voice {voice_channel.name}.")
        return
    
    # Tạo vai trò Discord
    villager_role = await guild.create_role(
        name="Dân Làng",
        color=discord.Color.green(),
        hoist=True,
        mentionable=False
    )
    game_state["villager_role_id"] = villager_role.id
    dead_role = await guild.create_role(
        name="Người Chết",
        color=discord.Color.greyple(),
        hoist=True,
        mentionable=False
    )
    game_state["dead_role_id"] = dead_role.id
    werewolf_role = await guild.create_role(
        name="Werewolf",
        color=discord.Color.red(),
        hoist=False,
        mentionable=False
    )
    game_state["werewolf_role_id"] = werewolf_role.id

    await voice_channel.set_permissions(dead_role, speak=False)
    
    # Thiết lập quyền cho kênh văn bản
    text_channel = interaction.channel
    await text_channel.set_permissions(guild.default_role, send_messages=False)
    await text_channel.set_permissions(villager_role, send_messages=True)
    await text_channel.set_permissions(dead_role, send_messages=False)
    game_state["text_channel"] = text_channel
    
    # Tạo các kênh voice riêng cho người chơi
    game_state["player_channels"] = {}
    for uid in game_state["temp_players"]:
        member = game_state["member_cache"].get(uid)
        if member:
            max_name_length = 100 - len("House of ") - 1
            channel_name = f"House of {member.display_name[:max_name_length]}"
            overwrites = {
                guild.default_role: discord.PermissionOverwrite(read_messages=False, connect=False),
                member: discord.PermissionOverwrite(read_messages=True, connect=True),
                guild.me: discord.PermissionOverwrite(read_messages=True, connect=True)
            }
            channel = await guild.create_voice_channel(channel_name, overwrites=overwrites)
            game_state["player_channels"][member.id] = channel
            logger.info(f"Đã tạo phòng voice riêng cho người chơi: {member.display_name}, channel_id={channel.id}")
    
    # Tạo kênh wolf-chat và dead-chat
    game_state["wolf_channel"] = await setup_wolf_channel(guild, game_state)
    game_state["dead_channel"] = await setup_dead_channel(guild, game_state)
    
    # Phân vai ngẫu nhiên
    roles = []
    for role, count in game_state["temp_roles"].items():
        roles.extend([role] * count)
    random.shuffle(roles)
    game_state["players"] = {}
    werewolf_ids = []
    illusionist_id = None
    for i, uid in enumerate(game_state["temp_players"]):
        member = game_state["member_cache"].get(uid)
        if member:
            role = roles[i]
            game_state["players"][uid] = {"role": role, "status": "alive", "muted": False}
            await member.add_roles(villager_role)
            if role in ["Werewolf", "Wolfman", "Demon Werewolf", "Assassin Werewolf"]:
                werewolf_ids.append(uid)
                await member.add_roles(werewolf_role)
                await game_state["wolf_channel"].set_permissions(member, read_messages=True, send_messages=True)
            elif role == "Illusionist":
                illusionist_id = uid
            # Gửi thông báo vai trò qua DM
            role_icon_url = ROLE_ICONS.get(role, "https://example.com/default_icon.png")
            embed = discord.Embed(
                title="Vai Trò Của Bạn",
                description=f"Bạn đã được phân vai: **{role}**",
                color=discord.Color.blue()
            )
            embed.set_thumbnail(url=role_icon_url)
            await retry_api_call(lambda: member.send(embed=embed))
    
    # Thông báo danh sách sói và Nhà Ảo Giác trong wolf-chat
    werewolf_members = [game_state["member_cache"].get(wid) for wid in werewolf_ids if game_state["member_cache"].get(wid)]
    illusionist_member = game_state["member_cache"].get(illusionist_id) if illusionist_id else None

    embed = discord.Embed(
        title="Danh sách Sói phe Sói",
        color=discord.Color.red()
    )

    if werewolf_members:
        werewolf_names = ", ".join([m.display_name for m in werewolf_members])
        embed.add_field(name="Sói", value=werewolf_names, inline=False)

    if illusionist_member:
        embed.add_field(name="Ảo Giác", value=illusionist_member.display_name, inline=False)
        embed.add_field(name="Lưu ý", value="Ảo Giác thuộc phe Sói nhưng không thức dậy cùng các bạn và không biết sói là ai", inline=False)

    if game_state["wolf_channel"]:
        await game_state["wolf_channel"].send(embed=embed)

    # Thêm thông báo game bắt đầu với số lượng người chơi và vai trò
    if game_state["text_channel"]:
        # Tạo chuỗi danh sách vai trò
        role_list_str = ", ".join([f"{role}: {count}" for role, count in game_state["temp_roles"].items() if count > 0])
        
        start_embed = discord.Embed(
            title="🎮 **Game Ma Sói DeWolfVie Bắt Đầu!**",
            description=(
                f"**🔹 Số lượng người chơi: {len(game_state['players'])}**\n"
                f"**🔹 Các vai trò trong game: {role_list_str}**\n"
                "**🔹 Tất cả người chơi đã được gán vai trò.**\n"
                "**🔹 Kênh wolf-chat và dead-chat đã được thiết lập.**\n"
                "**🔹 Hãy kiểm tra tin nhắn DM để biết vai trò của bạn.**\n"
                "**🔹 Chuẩn bị cho pha ngày đầu tiên!**"
            ),
            color=discord.Color.blue()
        )
        start_embed.set_image(url="https://cdn.discordapp.com/attachments/1365707789321633813/1372536545717780601/Banner_early_acccess_540x320.png?ex=682721c4&is=6825d044&hm=edce6a3e72304cce30f95e30fca1a3c480e7e8b0a340c95fd6d850541cafc7c6&")  # Thêm URL của ảnh banner
        start_embed.set_footer(text="DeWolfVie ver 5.15")
        await game_state["text_channel"].send(embed=start_embed)
    
    # Reset trạng thái game
    game_state["is_game_running"] = True
    game_state["is_first_day"] = True
    game_state["witch_has_power"] = game_state["temp_roles"]["Witch"] > 0
    game_state["hunter_has_power"] = game_state["temp_roles"]["Hunter"] > 0
    game_state["phase"] = "none"
    game_state["text_channel"] = interaction.channel
    game_state["votes"] = {}
    game_state["illusionist_scanned"] = False
    game_state["illusionist_effect_active"] = False
    game_state["illusionist_effect_night"] = 0
    game_state["night_count"] = 0
    game_state["math_problems"] = {}
    game_state["math_results"] = {}
    game_state["demon_werewolf_activated"] = False
    game_state["demon_werewolf_cursed_player"] = None
    game_state["demon_werewolf_has_cursed"] = False
    game_state["demon_werewolf_cursed_this_night"] = False
    game_state["assassin_werewolf_has_acted"] = False
    game_state["assassin_werewolf_target_id"] = None
    game_state["assassin_werewolf_role_guess"] = None
    game_state["detective_has_used_power"] = False
    game_state["detective_target1_id"] = None
    game_state["detective_target2_id"] = None
    
    await morning_phase(interaction, game_state)

# Lệnh và sự kiện
@bot.event
async def on_ready():
    print("Commands in tree before sync:")
    for command in bot.tree.get_commands():
        print(f"- {command.name}")
    init_game_logs_table()  # Thêm dòng này
    await bot.tree.sync()
    print(f"Bot đã sẵn sàng với tên {bot.user}")

@bot.tree.command(name="help_masoi", description="Hiển thị hướng dẫn chơi Ma Sói")
async def help_masoi(interaction: discord.Interaction):
    await interaction.response.defer()
    text_channel = interaction.channel
    embed = discord.Embed(
        title="Hướng Dẫn Bot Ma Sói",
        description="Danh sách lệnh và cách sử dụng để chơi Ma Sói.",
        color=discord.Color.blue()
    )
    embed.add_field(
        name="/start_game",
        value="Bắt đầu game mới, chọn kênh voice, số lượng người chơi, danh sách người chơi và vai trò. Người chơi sẽ được cấp vai trò Dân Làng trong Discord. Bot sẽ tham gia kênh voice cùng người chơi.",
        inline=False
    )
    embed.add_field(
        name="/pause_game",
        value="Tạm dừng game hiện tại. Các pha sẽ dừng lại, người chơi không thể thực hiện hành động cho đến khi tiếp tục.",
        inline=False
    )
    embed.add_field(
        name="/resume_game",
        value="Tiếp tục game đã bị tạm dừng.",
        inline=False
    )
    embed.add_field(
        name="/reset_game",
        value="Reset game hiện tại, xóa kênh wolf-chat và dead-chat, bật lại mic, xóa vai trò Dân Làng/Người Chết, gửi log trạng thái người chơi, sau đó tự động bắt đầu lại game với cùng người chơi và vai trò (chỉ xáo trộn vai trò).",
        inline=False
    )
    embed.add_field(
        name="/end_game",
        value="Kết thúc game, xóa vai trò Dân Làng/Người Chết, gửi log trạng thái người chơi, reset game và bot rời kênh voice.",
        inline=False
    )
    embed.add_field(
        name="/roles_list",
        value="Hiển thị danh sách các vai trò và mô tả chức năng của chúng trong game, phân chia theo Phe Dân và Phe Sói.",
        inline=False
    )
    embed.add_field(
        name="/status",
        value="Kiểm tra trạng thái hiện tại của bot (game đang chạy, số người chơi, pha hiện tại, trạng thái tạm dừng).",
        inline=False
    )
    embed.add_field(
        name="/check_mute",
        value="Kiểm tra xem có người chơi nào đang bị mute trong game hay không.",
        inline=False
    )
    embed.add_field(
        name="/help_masoi",
        value="Hiển thị hướng dẫn này.",
        inline=False
    )
    embed.set_footer(text="DeWolfVie ver 5.15")
    await interaction.followup.send(embed=embed)

# Lệnh roles_list đã được sửa
@bot.tree.command(name="roles_list", description="Hiển thị danh sách vai trò trong game")
async def roles_list(interaction: discord.Interaction):
    await interaction.response.defer()
    embed = discord.Embed(
        title="Danh Sách Vai Trò Ma Sói",
        description="Danh sách các vai trò trong game, phân chia theo phe. Chi tiết về các vai trò có thể xem tại [đây](https://www.dewolfvie.net/vn/chucnang).",
        color=discord.Color.blue()
    )

    # Danh sách vai trò Phe Dân
    villager_roles = "\n".join([f"**{role}**" for role in VILLAGER_ROLES])
    embed.add_field(name="Phe Dân", value=villager_roles, inline=False)

    # Danh sách vai trò Phe Sói
    werewolf_roles = "\n".join([f"**{role}**" for role in WEREWOLF_ROLES])
    embed.add_field(name="Phe Sói", value=werewolf_roles, inline=False)

    embed.set_footer(text="DeWolfVie ver 5.15")
    await interaction.followup.send(embed=embed)

# Lệnh roles mới
@bot.tree.command(name="roles", description="Xem mô tả chi tiết của một vai trò cụ thể")
@app_commands.describe(role="Chọn vai trò để xem chi tiết")
@app_commands.choices(role=[
    app_commands.Choice(name=role, value=role) for role in ROLES
])
async def roles(interaction: discord.Interaction, role: str):
    await interaction.response.defer()
    if role not in ROLE_LINKS:
        await interaction.followup.send("Vai trò không hợp lệ!")
        return
    link = ROLE_LINKS[role]
    embed = discord.Embed(
        title=f"Chi Tiết Vai Trò: {role}",
        description=f"Xem chi tiết về vai trò **{role}** tại [đây]({link}).",
        color=discord.Color.blue()
    )
    embed.set_footer(text="DeWolfVie ver 5.15")
    await interaction.followup.send(embed=embed)

@bot.tree.command(name="start_game", description="Bắt đầu một game Ma Sói mới")
async def start_game(interaction: discord.Interaction):
    await interaction.response.defer()
    text_channel = interaction.channel
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        game_states[guild_id] = {
            "players": {},
            "voice_channel_id": None,
            "guild_id": guild_id,
            "is_game_running": False,
            "is_game_paused": False,
            "phase": "none",
            "is_first_day": True,
            "protected_player_id": None,
            "previous_protected_player_id": None,
            "werewolf_target_id": None,
            "witch_target_id": None,
            "witch_action": None,
            "witch_has_power": True,
            "hunter_target_id": None,
            "hunter_has_power": True,
            "votes": {},
            "text_channel": text_channel,
            "wolf_channel": None,
            "dead_channel": None,
            "illusionist_scanned": False,
            "illusionist_effect_active": False,
            "illusionist_effect_night": 0,
            "temp_player_count": 0,
            "temp_players": [],
            "temp_roles": {role: 0 for role in ROLES},
            "temp_admin_id": None,
            "reset_in_progress": False,
            "math_problems": {},
            "math_results": {},
            "member_cache": {},
            "player_channels": {},
            "villager_role_id": None,
            "dead_role_id": None,
            "werewolf_role_id": None,
            "night_count": 0,
            "voice_connection": None,
            "demon_werewolf_activated": False,
            "demon_werewolf_cursed_player": None,
            "demon_werewolf_cursed_this_night": False,
            "demon_werewolf_cursed_this_night": False,
            "setup_message": None,
            "assassin_werewolf_has_acted": False,
            "assassin_werewolf_target_id": None,
            "assassin_werewolf_role_guess": None,
            "detective_has_used_power": False,
            "detective_target1_id": None,
            "detective_target2_id": None
        }
    game_state = game_states[guild_id]
    if game_state["is_game_running"]:
        await interaction.followup.send("Game đang chạy trên server này! Dùng /reset_game hoặc /end_game để kết thúc game hiện tại.")
        return
    game_state["temp_admin_id"] = interaction.user.id
    guild = interaction.guild
    voice_channels = [ch for ch in guild.voice_channels if ch.members]
    if not voice_channels:
        await interaction.followup.send("Không có kênh voice nào có người chơi!")
        return
    await interaction.followup.send(
        "Chọn kênh voice để bắt đầu game:",
        view=VoiceChannelView(guild, interaction.user.id, game_states)
    )

@bot.tree.command(name="pause_game", description="Tạm dừng game")
async def pause_game(interaction: discord.Interaction):
    await interaction.response.defer()
    text_channel = interaction.channel
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        await interaction.followup.send("Chưa có game nào để tạm dừng trên server này!")
        return
    game_state = game_states[guild_id]
    if not game_state["is_game_running"]:
        await interaction.followup.send("Chưa có game nào để tạm dừng!")
        return
    if game_state["is_game_paused"]:
        await interaction.followup.send("Game đã đang tạm dừng rồi! Dùng !resume_game để tiếp tục.")
        return
    game_state["is_game_paused"] = True
    logger.info(f"Game paused by {interaction.user.id} on guild {guild_id}")
    await interaction.followup.send("Game đã được tạm dừng! Dùng !resume_game để tiếp tục.")

@bot.tree.command(name="resume_game", description="Tiếp tục game")
async def resume_game(interaction: discord.Interaction):
    await interaction.response.defer()
    text_channel = interaction.channel
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        await interaction.followup.send("Chưa có game nào để tiếp tục trên server này!")
        return
    game_state = game_states[guild_id]
    if not game_state["is_game_running"]:
        await interaction.followup.sendd("Chưa có game nào để tiếp tục!")
        return
    if not game_state["is_game_paused"]:
        await interaction.followup.send("Game không đang tạm dừng! Dùng !pause_game để tạm dừng.")
        return
    game_state["is_game_paused"] = False
    logger.info(f"Game resumed by {interaction.user.id} on guild {guild_id}")
    await interaction.followup.send("Game đã được tiếp tục! Trò chơi sẽ tiếp tục từ pha hiện tại.")
    if game_state["phase"] == "morning":
        await morning_phase(interaction, game_state)
    elif game_state["phase"] == "night":
        await night_phase(interaction, game_state)
    elif game_state["phase"] == "voting":
        alive_players = await get_alive_players(interaction, game_state)
        vote_embed = discord.Embed(
            title="🗳️ Pha Bỏ Phiếu Tiếp Tục",
            description="Chọn người để loại trong 45 giây.",
            color=discord.Color.gold()
        )
        await game_state["text_channel"].send(embed=vote_embed, view=VoteView(alive_players, game_state, 45))
        await countdown(game_state["text_channel"], 30, "bỏ phiếu (30 giây đầu)", game_state)
        await display_current_votes(interaction, game_state)
        await countdown(game_state["text_channel"], 15, "bỏ phiếu (15 giây cuối)", game_state)
        await morning_phase(interaction, game_state)

@bot.tree.command(name="reset_game", description="Khởi động lại game")
async def reset_game(interaction: discord.Interaction):
    await interaction.response.defer()
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        await interaction.followup.send("Chưa có game nào để reset trên server này!")
        return
    game_state = game_states[guild_id]
    if not game_state["is_game_running"]:
        await interaction.followup.send("Chưa có game nào để reset!")
        return
    await reset_game_state(interaction, game_state)

# Lệnh kết thúc game
@bot.tree.command(name="end_game", description="Kết thúc game")
async def end_game(interaction: discord.Interaction):
    await interaction.response.defer()
    guild_id = interaction.guild.id
    text_channel = interaction.channel
    if guild_id not in game_states:
        await interaction.followup.send("Chưa có game nào để kết thúc trên server này!")
        return
    game_state = game_states[guild_id]
    if not game_state["is_game_running"]:
        await interaction.followup.send("Chưa có game nào để kết thúc!")
        return

    game_state["reset_in_progress"] = True
    error_messages = []
    
    try:
        # Gửi log kết quả game đến text_channel
        text_channel = game_state.get("text_channel") or interaction.channel
        if guild_id in game_logs and text_channel:
            embed = discord.Embed(title="Kết Quả Game", color=discord.Color.blue())
            role_list = []
            for user_id, data in game_state["players"].items():
                member = game_state["member_cache"].get(user_id)
                if member:
                    status = "Sống" if data["status"] in ["alive", "wounded"] else "Chết"
                    role_list.append(f"{member.display_name}: {data['role']} ({status})")
            log_text = "\n".join(game_logs[guild_id] + ["Danh sách cuối game:"] + role_list)
            if len(log_text) > 1024:
                log_text = log_text[-1024:]
            embed.add_field(name="Tình trạng", value=log_text or "Không có dữ liệu", inline=False)
            user_name = interaction.user.name
            embed.set_footer(text=f"Log được gửi bởi {user_name}")
            await interaction.followup.send(embed=embed)
        elif text_channel:
            await interaction.followup.send("Không có dữ liệu nào được ghi lại trong game.")

        # Làm mới member_cache
        try:
            game_state["member_cache"] = {m.id: m for m in await retry_api_call(lambda: interaction.guild.members)}
            logger.info(f"Refreshed member_cache with {len(game_state['member_cache'])} members")
        except Exception as e:
            error_messages.append(f"Không thể làm mới danh sách thành viên server: {str(e)}")

        # Di chuyển người chơi về kênh chính và unmute
        main_voice_channel = bot.get_channel(game_state["voice_channel_id"])
        if main_voice_channel:
            for user_id in game_state["players"]:
                member = game_state["member_cache"].get(user_id)
                if member and member.voice and member.voice.channel:
                    try:
                        await member.move_to(main_voice_channel)
                        await member.edit(mute=False)
                    except Exception as e:
                        error_messages.append(f"Không thể di chuyển hoặc unmute {member.display_name}: {str(e)}")

        # Xóa vai trò khỏi người chơi
        villager_role = interaction.guild.get_role(game_state["villager_role_id"])
        dead_role = interaction.guild.get_role(game_state["dead_role_id"])
        werewolf_role = interaction.guild.get_role(game_state["werewolf_role_id"])
        for user_id in game_state["players"]:
            member = game_state["member_cache"].get(user_id)
            if member:
                try:
                    if villager_role and villager_role in member.roles:
                        await member.remove_roles(villager_role)
                    if dead_role and dead_role in member.roles:
                        await member.remove_roles(dead_role)
                    if werewolf_role and werewolf_role in member.roles:
                        await member.remove_roles(werewolf_role)
                except Exception as e:
                    error_messages.append(f"Không thể xóa vai trò khỏi {member.display_name}: {str(e)}")

        # Xóa các kênh voice riêng
        if "player_channels" in game_state:
            for channel in game_state["player_channels"].values():
                try:
                    await channel.delete()
                except Exception as e:
                    error_messages.append(f"Không thể xóa kênh voice riêng: {str(e)}")
            game_state["player_channels"].clear()

        # Xóa kênh dead-chat và wolf-chat
        dead_channel = game_state.get("dead_channel")
        wolf_channel = game_state.get("wolf_channel")
        if dead_channel:
            try:
                await dead_channel.delete()
            except Exception as e:
                error_messages.append(f"Không thể xóa dead-chat: {str(e)}")
        if wolf_channel:
            try:
                await wolf_channel.delete()
            except Exception as e:
                error_messages.append(f"Không thể xóa wolf-chat: {str(e)}")

        # Xóa vai trò game
        if villager_role:
            try:
                await villager_role.delete()
            except Exception as e:
                error_messages.append(f"Không thể xóa vai trò Dân Làng: {str(e)}")
        if dead_role:
            try:
                await dead_role.delete()
            except Exception as e:
                error_messages.append(f"Không thể xóa vai trò Người Chết: {str(e)}")
        if werewolf_role:
            try:
                await werewolf_role.delete()
            except Exception as e:
                error_messages.append(f"Không thể xóa vai trò Werewolf: {str(e)}")

        # Khôi phục quyền kênh văn bản
        if text_channel:
            try:
                if text_channel.category:
                    await text_channel.edit(sync_permissions=True)
                else:
                    await text_channel.set_permissions(interaction.guild.default_role, send_messages=True)
            except Exception as e:
                error_messages.append(f"Không thể khôi phục quyền kênh văn bản: {str(e)}")

        # Bot rời kênh voice
        if game_state["voice_connection"] and game_state["voice_connection"].is_connected():
            try:
                await game_state["voice_connection"].disconnect()
            except Exception as e:
                error_messages.append(f"Không thể ngắt kết nối bot khỏi kênh voice: {str(e)}")
            game_state["voice_connection"] = None

        # Reset game_state
        game_state["players"].clear()
        game_state["is_game_running"] = False
        game_state["is_game_paused"] = False
        game_state["phase"] = "none"
        game_state["is_first_day"] = True
        game_state["voice_channel_id"] = None
        game_state["guild_id"] = None
        game_state["protected_player_id"] = None
        game_state["previous_protected_player_id"] = None
        game_state["werewolf_target_id"] = None
        game_state["witch_target_id"] = None
        game_state["witch_action"] = None
        game_state["witch_has_power"] = True
        game_state["hunter_target_id"] = None
        game_state["hunter_has_power"] = True
        game_state["votes"] = {}
        game_state["text_channel"] = None
        game_state["wolf_channel"] = None
        game_state["dead_channel"] = None
        game_state["illusionist_scanned"] = False
        game_state["illusionist_effect_active"] = False
        game_state["illusionist_effect_night"] = 0
        game_state["temp_player_count"] = 0
        game_state["temp_players"] = []
        game_state["temp_roles"] = {role: 0 for role in ROLES}
        game_state["temp_admin_id"] = None
        game_state["reset_in_progress"] = False
        game_state["villager_role_id"] = None
        game_state["dead_role_id"] = None
        game_state["werewolf_role_id"] = None
        game_state["member_cache"].clear()
        game_state["night_count"] = 0
        game_state["demon_werewolf_activated"] = False
        game_state["demon_werewolf_cursed_player"] = None
        game_state["demon_werewolf_has_cursed"] = False
        game_state["demon_werewolf_cursed_this_night"] = False
        game_state["assassin_werewolf_has_acted"] = False
        game_state["assassin_werewolf_target_id"] = None
        game_state["assassin_werewolf_role_guess"] = None
        game_state["detective_has_used_power"] = False
        game_state["detective_target1_id"] = None
        game_state["detective_target2_id"] = None
        game_logs[guild_id].clear()

        # Gửi phản hồi duy nhất
        if error_messages:
            error_text = "\n".join(error_messages)
            await interaction.followup.send(f"Game đã được kết thúc với một số lỗi:\n{error_text}")
        else:
            await interaction.followup.send("Game đã được kết thúc thành công! Tất cả trạng thái đã được khôi phục.")
    finally:
        game_state["reset_in_progress"] = False

@bot.tree.command(name="status", description="Tình trạng game trên server")
async def status(interaction: discord.Interaction):
    await interaction.response.defer()
    guild_id = interaction.guild.id
    text_channel = interaction.channel
    if guild_id not in game_states:
        embed = discord.Embed(
            title="Trạng thái Bot Ma Sói",
            description="Chưa có game nào đang chạy trên server này.",
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed)
        return
    game_state = game_states[guild_id]
    embed = discord.Embed(title="Trạng thái Bot Ma Sói", color=discord.Color.green())
    embed.add_field(name="Game đang chạy", value=str(game_state["is_game_running"]), inline=False)
    embed.add_field(name="Game đang tạm dừng", value=str(game_state["is_game_paused"]), inline=False)
    embed.add_field(name="Số người chơi", value=str(len(game_state["players"])), inline=False)
    embed.add_field(name="Pha hiện tại", value=game_state["phase"], inline=False)
    await interaction.followup.send(embed=embed)
  
@bot.tree.command(name="leaderboard", description="Hiển thị bảng vinh danh")
async def leaderboard(interaction: discord.Interaction):
    await interaction.response.defer()
    guild_id = interaction.guild.id
    try:
        db = get_db_connection()
        cursor = db.cursor(dictionary=True)

        # Đảm bảo bảng tồn tại
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS leaderboard (
                id INT AUTO_INCREMENT PRIMARY KEY,
                guild_id BIGINT NOT NULL,
                player_id BIGINT NOT NULL,
                player_name VARCHAR(255) NOT NULL,
                score INT DEFAULT 0,
                UNIQUE KEY unique_guild_player (guild_id, player_id)
            )
        """)

        # Lấy top 10 người chơi
        cursor.execute("""
            SELECT player_name, score FROM leaderboard
            WHERE guild_id = %s
            ORDER BY score DESC
            LIMIT 10
        """, (guild_id,))
        records = cursor.fetchall()

        if not records:
            await interaction.followup.send("Chưa có dữ liệu leaderboard cho server này.")
            return

        embed = discord.Embed(
            title=f"🏆 Leaderboard - Top 10 (Server: {interaction.guild.name})",
            color=discord.Color.gold()
        )
        for i, record in enumerate(records, start=1):
            embed.add_field(name=f"{i}. {record['player_name']}", value=f"Điểm: {record['score']}", inline=False)

        await interaction.followup.send(embed=embed)

    except mysql.connector.Error as err:
        logger.error(f"MySQL Error fetching leaderboard for guild {guild_id}: {err}")
        await interaction.followup.send(f"Lỗi MySQL khi lấy leaderboard: {err}")
    except Exception as e:
        logger.error(f"Error fetching leaderboard for guild {guild_id}: {e}")
        await interaction.followup.send(f"Lỗi khi lấy leaderboard: {e}")
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'db' in locals():
            db.close()

@bot.tree.command(name="check_mute", description="Kiểm tra tình trạng mic")
async def check_mute(interaction: discord.Interaction):
    await interaction.response.defer()
    text_channel = interaction.channel
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        await interaction.followup.send("Chưa có game nào đang chạy trên server này!")
        return
    game_state = game_states[guild_id]
    muted_players = []
    for user_id in game_state["players"]:
        member = game_state["member_cache"].get(user_id)
        if member and member.voice and member.voice.mute:
            muted_players.append(f"{member.display_name} (ID: {member.id})")
    if muted_players:
        await interaction.followup.send(f"Người chơi đang bị mute: {', '.join(muted_players)}")
    else:
        await interaction.followup.send("Không có người chơi nào đang bị mute.")

@bot.tree.command(name="check_player", description="Kiểm tra người chơi")
async def check_player(interaction: discord.Interaction):
    await interaction.response.defer()
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        await interaction.followup.send("Chưa có game nào đang chạy trên server này!")
        return
    game_state = game_states[guild_id]
    if player_id not in game_state["players"]:
        await interaction.followup.send("Người chơi không có trong game!")
        return
    player_data = game_state["players"][player_id]
    member = game_state["member_cache"].get(player_id)
    if member:
        await interaction.followup.send(f"Người chơi {member.display_name} (ID: {player_id})\n"
                       f"Vai trò: {player_data['role']}\n"
                       f"Trạng thái: {player_data['status']}\n"
                       f"Muted: {player_data['muted']}")
    else:
        await interaction.followup.send(f"Không tìm thấy người chơi với ID {player_id}")

# Khởi động bot
if __name__ == "__main__":
    print("Starting script...")
    load_dotenv()
    db = get_db_connection()
    print("Kết nối MySQL thành công!")
    db.close()
    token = os.getenv("TOKEN")
    print(f"Token: {token}")
    if not token:
        print("Error: TOKEN not found in .env file")
        sys.exit(1)
    print("Running bot...")
    try:
        bot.run(token)
    except Exception as e:
        print(f"Error starting bot: {str(e)}")
        logger.error(f"Error starting bot: {str(e)}")
        sys.exit(1)
