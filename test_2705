from dotenv import load_dotenv
import os

load_dotenv()
import discord
from discord.ext import commands
from discord import app_commands
import random
import asyncio
import logging
import sys
import traceback
import inspect
from collections import deque
import gspread
from oauth2client.service_account import ServiceAccountCredentials
import mysql.connector

def get_db_connection():
    return mysql.connector.connect(
        host=os.getenv("MYSQL_HOST"),
        port=os.getenv("MYSQL_PORT"),
        user=os.getenv("MYSQL_USER"),
        password=os.getenv("MYSQL_PASSWORD"),
        database=os.getenv("MYSQL_DATABASE"),
        charset='utf8mb4',
        collation='utf8mb4_unicode_ci'
    )

# C·∫•u h√¨nh logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Log ho·∫°t ƒë·ªông vai tr√≤
game_logs = {}
game_states = {}

# Thi·∫øt l·∫≠p Google Sheets
#scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
#creds = ServiceAccountCredentials.from_json_keyfile_name("credentials.json", scope)
#client = gspread.authorize(creds)
#spreadsheet = client.open("Ma Soi Leaderboard")

# Th√™m URL c·ªßa c√°c GIF
GIF_URLS = {
    "morning": "https://cdn.discordapp.com/attachments/1365707789321633813/1372115998525620335/Phase_day.gif?ex=68259a1a&is=6824489a&hm=c01364ba79cba7d7aed13a993a24850c2e0d17a2cf27af95a95389789d79a7a6&",
    "night": "https://cdn.discordapp.com/attachments/1365707789321633813/1372117342380621855/Phase_night.gif?ex=68259b5b&is=682449db&hm=1bafb461bb02b41ed95b43de2753d09254bed7bd052bbf5d2136f397f89850b0&",
    "hang": "https://cdn.discordapp.com/attachments/1365707789321633813/1372117715707232266/Phase_deadbyvote.gif?ex=68259bb4&is=68244a34&hm=6cb3e2864efd785a39be137defbcc2fe4a27636a83b80192602bc378a95666e7&",
    "vote": "https://cdn.discordapp.com/attachments/1365707789321633813/1372117883957678080/Phase_vote.gif?ex=68259bdc&is=68244a5c&hm=1c16c879de3730319169681f6325fced29953b63d688433c9baa0b44dc683ef7&",
    "villager_win": "https://cdn.discordapp.com/attachments/1365707789321633813/1372118299856474184/Phase_humanwin.gif?ex=68259c3f&is=68244abf&hm=64f37b2b28a0790a990469bf14c6bcddf36b438629c1902b21d8ab425f6c2f5d&",
    "werewolf_win": "https://cdn.discordapp.com/attachments/1365707789321633813/1372118396673458217/Phase_wolfwin.gif?ex=68259c56&is=68244ad6&hm=e1e53652db3548081e3e3a5ea419ff785d7e1e434cd168284da334682e1083e6&",
    "death": "https://cdn.discordapp.com/attachments/1365707789321633813/1372118623287509002/Phase_deadbynight.gif?ex=68259c8c&is=68244b0c&hm=ea2f732c04d7bae102f00612f75c81ec5b0c54db7a65ea4f034cdd4626ff0c1a&"  # URL GIF th·ª±c t·∫ø cho th√¥ng b√°o ng∆∞·ªùi ch·∫øt
}

# Th√™m URL c·ªßa c√°c h√¨nh ·∫£nh icon cho vai tr√≤
ROLE_ICONS = {
    "Villager": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853615445676143/villager-512.png?ex=68284910&is=6826f790&hm=21ba4ed9e3293b568f09edf5861a92f5472c11cef09db470c9400e813cf9c180&",
    "Werewolf": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853692226736128/werewolf-512.png?ex=68284922&is=6826f7a2&hm=f931eea427ae3a00a1a2c7f8cf38b41d3c3fa77774b3ff262c031eedf687e1c5&",
    "Seer": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853452555943966/seer-512.png?ex=682848e9&is=6826f769&hm=98e371c02b99c848a39c3267f14eb166bcf4c5a687ed9a9e24f39e35e5900afd&",
    "Guard": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853215065931867/guard-512.png?ex=682848b0&is=6826f730&hm=afc74125559a3d35912aae771c4d8391efedba4d261e6d3935d91b54648c320f&",
    "Witch": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853774682558514/witch-512.png?ex=68284936&is=6826f7b6&hm=1491fa773b223745034fd88a86409bbe99754a4a19afe1573f176ef05912fb50&",
    "Hunter": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853304211669054/hunter-512.png?ex=682848c6&is=6826f746&hm=2c6a8b0968442879facea46e89b417a234922ea4ff3a7791b5fb76d50ba34726&",
    "Tough Guy": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853538669199390/touchguy-512.png?ex=682848fe&is=6826f77e&hm=e4d44f6a9993361f46469fb9b2b91f642efab2032697eaf8b4eb9c976e7ce936&",
    "Illusionist": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853384280805446/illusionist-512.png?ex=682848d9&is=6826f759&hm=bbb99c57d8fd36b0cd88babbfc8c9309a31d8c88fd36993740df0a96732db975&",
    "Wolfman": "https://cdn.discordapp.com/attachments/1365707789321633813/1372853876017070120/wolfman-512.png?ex=6828494e&is=6826f7ce&hm=eb72a7ed9bc15e33982364aa2aef1113916038ebac81a8beed94b69ccf8ae0db&",
    "Explorer": "https://cdn.discordapp.com/attachments/1365707789321633813/1372852429489704960/explorer-512.png?ex=682847f5&is=6826f675&hm=c799a97a59fe90b3dfa62804b4ff38f964502ad06e20eea9097174742efa4e78&",
    "Demon Werewolf": "https://cdn.discordapp.com/attachments/1365707789321633813/1372852300435034122/demonwolf-512.png?ex=682847d6&is=6826f656&hm=0f6bf383e2d72d73fb7b0a98ffb5c9cebbf6444fcb9aa16903eba37a66e74424&",
    "Assassin Werewolf": "https://cdn.discordapp.com/attachments/1365707789321633813/1374432785833394186/assassinwolf-512.png?ex=682e07c7&is=682cb647&hm=191deea5033471f7fb2ec86f7a59ebd4f8259a1c53f9e61ac0a5d52593a375a3&",  # T·∫°m d√πng icon Werewolf
    "Detective": "https://cdn.discordapp.com/attachments/1365707789321633813/1374694217527463956/detective-512_2.png?ex=682efb42&is=682da9c2&hm=1763595fbe72496342badea2b85a262c961a7ab05971ba8d036b2fd6a033985b&"
}

# Kh·ªüi t·∫°o bot
intents = discord.Intents.all()
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)
#spreadsheet = client.open("Ma Soi Leaderboard")

# Danh s√°ch vai tr√≤ v√† m√¥ t·∫£
ROLES = ["Villager", "Werewolf", "Seer", "Guard", "Witch", "Hunter", "Tough Guy", "Illusionist", "Wolfman", "Explorer", "Demon Werewolf", "Assassin Werewolf", "Detective"]
VILLAGER_SPECIAL_ROLES = ["Seer", "Guard", "Witch", "Hunter", "Tough Guy", "Explorer","Detective"]
WEREWOLF_SPECIAL_ROLES = ["Illusionist", "Wolfman", "Demon Werewolf", "Assassin Werewolf"]
VILLAGER_ROLES = ["Villager", "Seer", "Guard", "Witch", "Hunter", "Tough Guy", "Explorer", "Detective"]
WEREWOLF_ROLES = ["Werewolf", "Illusionist", "Wolfman", "Demon Werewolf", "Assassin Werewolf"]
NO_NIGHT_ACTION_ROLES = ["Villager", "Tough Guy", "Illusionist"]

ROLE_DESCRIPTIONS = {
    "Villager": "Kh√¥ng c√≥ ch·ª©c nƒÉng ƒë·∫∑c bi·ªát, tham gia th·∫£o lu·∫≠n v√† b·ªè phi·∫øu ban ng√†y (t·ª´ ng√†y th·ª© hai). Ph·∫£i ch·ªçn ƒë√°p √°n ƒë√∫ng trong b√†i to√°n c·ªông/tr·ª´ v√†o ban ƒë√™m ƒë·ªÉ ƒë∆∞·ª£c quy·ªÅn b·ªè phi·∫øu.",
    "Werewolf": "M·ªói ƒë√™m th·∫£o lu·∫≠n trong wolf-chat v√† ch·ªçn gi·∫øt 1 ng∆∞·ªùi b·∫±ng n√∫t ch·ªçn. Bi·∫øt ai l√† Nh√† ·∫¢o Gi√°c (n·∫øu c√≥).",
    "Seer": "M·ªói ƒë√™m ki·ªÉm tra 1 ng∆∞·ªùi thu·ªôc phe D√¢n ho·∫∑c S√≥i b·∫±ng n√∫t ch·ªçn qua DM. K·∫øt qu·∫£ c√≥ th·ªÉ b·ªã ƒë·∫£o ng∆∞·ª£c n·∫øu Nh√† ·∫¢o Gi√°c b·ªã soi tr∆∞·ªõc ƒë√≥.",
    "Guard": "M·ªói ƒë√™m b·∫£o v·ªá 1 ng∆∞·ªùi b·∫±ng n√∫t ch·ªçn qua DM, ngƒÉn h·ªç b·ªã gi·∫øt b·ªüi S√≥i, Ph√π Th·ªßy ho·∫∑c Th·ª£ SƒÉn.",
    "Witch": "M·ªói ƒë√™m bi·∫øt ai b·ªã ch·ªçn gi·∫øt, c√≥ 1 l·∫ßn duy nh·∫•t ƒë·ªÉ c·ª©u b·∫±ng n√∫t 'Save' ho·∫∑c gi·∫øt 1 ng∆∞·ªùi b·∫±ng n√∫t ch·ªçn qua DM. Nh·∫≠n th√¥ng b√°o mu·ªôn h∆°n ƒë·ªÉ quy·∫øt ƒë·ªãnh trong 20 gi√¢y cu·ªëi. Sau khi s·ª≠ d·ª•ng ch·ª©c nƒÉng, s·∫Ω kh√¥ng c√≤n nh·∫≠n th√¥ng tin v·ªÅ ng∆∞·ªùi b·ªã gi·∫øt v√† nh·∫≠n th√¥ng b√°o 'Kh√¥ng ai b·ªã gi·∫øt ƒë√™m nay!' m·ªói ƒë√™m.",
    "Hunter": "C√≥ 1 l·∫ßn duy nh·∫•t trong ƒë√™m ƒë·ªÉ gi·∫øt 1 ng∆∞·ªùi b·∫±ng n√∫t ch·ªçn qua DM.",
    "Tough Guy": "Thu·ªôc phe D√¢n, c√≥ 2 m·∫°ng ƒë·ªëi v·ªõi c√°c h√†nh ƒë·ªông gi·∫øt v√†o ban ƒë√™m (S√≥i, Ph√π Th·ªßy, Th·ª£ SƒÉn). Ph·∫£i b·ªã gi·∫øt 2 l·∫ßn v√†o ban ƒë√™m ƒë·ªÉ ch·∫øt ho√†n to√†n. Kh√¥ng c√≥ th√¥ng b√°o khi m·∫•t m·∫°ng. Tuy nhi√™n, n·∫øu b·ªã ng·ªìi gh·∫ø ƒëi·ªán (lo·∫°i b·ªüi b·ªè phi·∫øu ban ng√†y), s·∫Ω ch·∫øt ngay l·∫≠p t·ª©c b·∫•t k·ªÉ c√≤n bao nhi√™u m·∫°ng. Ph·∫£i ch·ªçn ƒë√°p √°n ƒë√∫ng trong b√†i to√°n c·ªông/tr·ª´ v√†o ban ƒë√™m ƒë·ªÉ ƒë∆∞·ª£c quy·ªÅn b·ªè phi·∫øu.",
    "Illusionist": "Thu·ªôc phe S√≥i, th·∫Øng c√πng S√≥i nh∆∞ng kh√¥ng th·ª©c d·∫≠y trong wolf-chat v√† kh√¥ng bi·∫øt ai l√† S√≥i. S√≥i bi·∫øt Nh√† ·∫¢o Gi√°c. ƒê∆∞·ª£c t√≠nh v√†o Phe D√¢n khi ki·ªÉm ƒë·∫øm th·∫Øng thua. N·∫øu b·ªã Ti√™n Tri soi, ra Phe D√¢n. ƒê√™m ti·∫øp theo, k·∫øt qu·∫£ soi c·ªßa Ti√™n Tri b·ªã ƒë·∫£o ng∆∞·ª£c (D√¢n th√†nh S√≥i, S√≥i th√†nh D√¢n). Ph·∫£i ch·ªçn ƒë√°p √°n ƒë√∫ng trong b√†i to√°n c·ªông/tr·ª´ v√†o ban ƒë√™m ƒë·ªÉ ƒë∆∞·ª£c quy·ªÅn b·ªè phi·∫øu.",
    "Wolfman": "Thu·ªôc phe S√≥i, th·ª©c d·∫≠y c√πng b·∫ßy S√≥i trong wolf-chat v√† tham gia ch·ªçn gi·∫øt. ƒê∆∞·ª£c t√≠nh l√† S√≥i khi ki·ªÉm ƒë·∫øm th·∫Øng thua. N·∫øu b·ªã Ti√™n Tri soi, hi·ªÉn th·ªã thu·ªôc Phe D√¢n.",
    "Explorer": "T·ª´ ƒë√™m th·ª© hai, m·ªói ƒë√™m ph·∫£i ch·ªçn gi·∫øt m·ªôt ng∆∞·ªùi qua DM. N·∫øu ch·ªçn ƒë√∫ng S√≥i (kh√¥ng t√≠nh Nh√† ·∫¢o Gi√°c), S√≥i s·∫Ω ch·∫øt. N·∫øu ch·ªçn tr√∫ng Phe D√¢n (t√≠nh c·∫£ Nh√† ·∫¢o Gi√°c), Ng∆∞·ªùi Kh√°m Ph√° s·∫Ω ch·∫øt. C√≥ th·ªÉ ƒë∆∞·ª£c b·∫£o v·ªá b·ªüi B·∫£o V·ªá v√† c·ª©u b·ªüi Ph√π Th·ªßy theo nguy√™n t·∫Øc game.",
    "Demon Werewolf": "Thu·ªôc phe S√≥i, th·ª©c d·∫≠y c√πng b·∫ßy S√≥i. Khi m·ªôt S√≥i b·∫•t k·ª≥ ch·∫øt, S√≥i Qu·ª∑ c√≥ th·ªÉ nguy·ªÅn m·ªôt ng∆∞·ªùi ch∆°i duy nh·∫•t qua DM, bi·∫øn h·ªç th√†nh S√≥i v√†o ƒë√™m ti·∫øp theo. Ng∆∞·ªùi b·ªã nguy·ªÅn m·∫•t ch·ª©c nƒÉng c≈© v√† tham gia b·∫ßy S√≥i, ·∫£nh h∆∞·ªüng ƒë·∫øn ki·ªÉm ƒë·∫øm th·∫Øng thua. Trong ƒë√™m nguy·ªÅn, m·ª•c ti√™u c·ªßa b·∫ßy S√≥i kh√¥ng ch·∫øt.",
    "Assassin Werewolf": "Thu·ªôc phe S√≥i, th·ª©c d·∫≠y c√πng b·∫ßy S√≥i v√† tham gia ch·ªçn gi·∫øt. C√≥ m·ªôt l·∫ßn duy nh·∫•t trong game ƒë·ªÉ ch·ªçn m·ªôt ng∆∞·ªùi ch∆°i v√† ƒëo√°n vai tr√≤ c·ªßa h·ªç v√†o ban ƒë√™m. N·∫øu ƒëo√°n ƒë√∫ng, ng∆∞·ªùi ƒë√≥ ch·∫øt; n·∫øu sai, S√≥i √Åm S√°t ch·∫øt. S√≥i √Åm S√°t s·∫Ω kh√¥ng √°m s√°t ƒë∆∞·ª£c D√¢n L√†ng",
    "Detective": "M·ªôt l·∫ßn duy nh·∫•t trong game, v√†o ban ƒë√™m, th√°m t·ª≠ c√≥ th·ªÉ ch·ªçn hai ng∆∞·ªùi ch∆°i ƒë·ªÉ xem h·ªç c√≥ c√πng phe hay kh√¥ng. ·∫¢o gi√°c v√† ng∆∞·ªùi s√≥i ƒë∆∞·ª£c t√≠nh v√†o phe s√≥i. Th√°m t·ª≠ kh√¥ng th·ªÉ t·ª± ch·ªçn ch√≠nh m√¨nh."
}

# ƒê·ªãnh nghƒ©a c√°c ƒë∆∞·ªùng link cho t·ª´ng vai tr√≤
ROLE_LINKS = {
    "Villager": "https://www.dewolfvie.net/vn/chucnang#h.72xuy5mwxslh",
    "Werewolf": "https://www.dewolfvie.net/vn/chucnang#h.hvhyxzcxp8ha",
    "Seer": "https://www.dewolfvie.net/vn/chucnang#h.2s0avvgyr6t9",
    "Guard": "https://www.dewolfvie.net/vn/chucnang#h.ne683ss63imm",
    "Witch": "https://www.dewolfvie.net/vn/chucnang#h.jb8i4v8ruvpi",
    "Hunter": "https://www.dewolfvie.net/vn/chucnang#h.30wa7yki033k",
    "Tough Guy": "https://www.dewolfvie.net/vn/chucnang#h.8ofxyfsrchwy",
    "Illusionist": "https://www.dewolfvie.net/vn/chucnang#h.22uhems1a6om",
    "Wolfman": "https://www.dewolfvie.net/vn/chucnang#h.4vfb9srnjzej",
    "Explorer": "https://www.dewolfvie.net/vn/chucnang#h.5n2k068a52q0",
    "Demon Werewolf": "https://www.dewolfvie.net/vn/chucnang#h.ln7finvlqa8r",
    "Assassin Werewolf": "https://www.dewolfvie.net/vn/chucnang#h.w0d62d7aiqjw",
    "Detective": "https://www.dewolfvie.net/vn/chucnang#h.g8we49sefmk"
}

# Nh·∫≠n ƒë·ªãnh role cho detective
def get_player_team(role):
    if role in ["Illusionist", "Wolfman", "Werewolf", "Demon Werewolf", "Assassin Werewolf"]:
        return "werewolves"
    elif role in VILLAGER_ROLES:
        return "villagers"
    else:
        return "unknown"
      
# ƒê∆∞·ªùng d·∫´n ƒë·∫øn c√°c t·ªáp √¢m thanh
AUDIO_FILES = {
    "morning": "day_phase.wav",
    "night": "night_phase.mp3",
    "vote": "vote_phase.mp3",
    "hang": "sad_sound.mp3",
    "end_game": "end_game.mp3" 
}

# H√†m h·ªó tr·ª£
def init_game_logs_table():
    try:
        db = get_db_connection()
        cursor = db.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS game_logs (
                id INT AUTO_INCREMENT PRIMARY KEY,
                guild_id BIGINT NOT NULL,
                log_message TEXT NOT NULL,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        """)
        db.commit()
    except mysql.connector.Error as err:
        logger.error(f"L·ªói khi t·∫°o b·∫£ng game_logs: {err}")
    finally:
        cursor.close()
        db.close()

async def generate_math_problem(used_problems):
    max_attempts = 100
    for _ in range(max_attempts):
        num1 = random.randint(100, 999)
        num2 = random.randint(100, 999)
        operation = random.choice(['+', '-'])
        problem = f"{num1} {operation} {num2}"
        if problem not in used_problems:
            answer = num1 + num2 if operation == '+' else num1 - num2
            if answer < 100:
                continue
            possible_wrong = []
            for offset in range(-100, 101, 10):
                wrong = answer + offset
                if wrong != answer and wrong >= 0:
                    possible_wrong.append(wrong)
            if len(possible_wrong) < 2:
                continue
            wrong1, wrong2 = random.sample(possible_wrong, 2)
            options = [answer, wrong1, wrong2]
            random.shuffle(options)
            return {"problem": problem, "answer": answer, "options": options}
    raise ValueError("Unable to generate unique math problem after maximum attempts")

async def setup_wolf_channel(guild, game_state):
    wolf_channel = discord.utils.get(guild.text_channels, name="wolf-chat")
    werewolf_role = guild.get_role(game_state["werewolf_role_id"])
    if not wolf_channel:
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            werewolf_role: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }
        wolf_channel = await guild.create_text_channel("wolf-chat", overwrites=overwrites)
    else:
        await wolf_channel.set_permissions(guild.default_role, read_messages=False)
        await wolf_channel.set_permissions(werewolf_role, read_messages=True, send_messages=True)
    game_state["wolf_channel"] = wolf_channel
    return wolf_channel

async def setup_dead_channel(guild, game_state):
    dead_channel = discord.utils.get(guild.text_channels, name="dead-chat")
    dead_role = guild.get_role(game_state["dead_role_id"])
    if not dead_channel:
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            dead_role: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }
        dead_channel = await guild.create_text_channel("dead-chat", overwrites=overwrites)
    else:
        await dead_channel.set_permissions(guild.default_role, read_messages=False)
        await dead_channel.set_permissions(dead_role, read_messages=True, send_messages=True)
    game_state["dead_channel"] = dead_channel
    return dead_channel

async def countdown(channel, seconds, phase, game_state):
    if not game_state["is_game_running"]:
        logger.info(f"Game stopped, skipping countdown for phase: {phase}")
        return
    if game_state["is_game_paused"]:
        logger.info(f"Game paused, skipping countdown for phase: {phase}")
        return

    if channel is None:
        logger.error(f"Cannot send countdown message for phase {phase}: channel is None")
        return

    try:
        if seconds < 5:
            # G·ª≠i tin nh·∫Øn k·∫øt th√∫c ngay l·∫≠p t·ª©c n·∫øu th·ªùi gian nh·ªè h∆°n 5 gi√¢y
            message = await channel.send(f"‚è≥ *Pha {phase} k·∫øt th√∫c!*")
            return

        # G·ª≠i tin nh·∫Øn ban ƒë·∫ßu
        current_message = await channel.send(f"‚è≥ *ƒêang ƒë·∫øm ng∆∞·ª£c cho {phase}...*")
        remaining = seconds - 5
        while remaining > 0:
            if not game_state["is_game_running"] or game_state["is_game_paused"]:
                await current_message.edit(content="‚è≥ *ƒê·∫øm ng∆∞·ª£c b·ªã h·ªßy do game d·ª´ng ho·∫∑c t·∫°m d·ª´ng.*")
                return
            await asyncio.sleep(1)
            remaining -= 1

        # B·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c 5 gi√¢y cu·ªëi b·∫±ng c√°ch g·ª≠i tin nh·∫Øn m·ªõi v√† x√≥a tin nh·∫Øn c≈©
        for i in range(5, 0, -1):
            if not game_state["is_game_running"] or game_state["is_game_paused"]:
                await current_message.edit(content="‚è≥ *ƒê·∫øm ng∆∞·ª£c b·ªã h·ªßy do game d·ª´ng ho·∫∑c t·∫°m d·ª´ng.*")
                return
            new_message = await channel.send(f"‚è≥ *C√≤n {i}s ƒë·ªÉ {phase}*")
            try:
                await current_message.delete()
            except discord.errors.NotFound:
                logger.warning(f"Message not found to delete during countdown for phase {phase}")
            except Exception as e:
                logger.error(f"Error deleting message during countdown for phase {phase}: {str(e)}")
            current_message = new_message
            await asyncio.sleep(1)

        # G·ª≠i tin nh·∫Øn k·∫øt th√∫c
        final_message = await channel.send(f"‚è≥ *Pha {phase} k·∫øt th√∫c!*")
        try:
            await current_message.delete()
        except discord.errors.NotFound:
            logger.warning(f"Message not found to delete at the end of countdown for phase {phase}")
        except Exception as e:
            logger.error(f"Error deleting final message during countdown for phase {phase}: {str(e)}")
    except Exception as e:
        logger.error(f"Error during countdown for phase {phase}: {str(e)}")

# H√†m hi·ªÉn th·ªã phi·∫øu vote sau 30 gi√¢y
async def display_current_votes(interaction: discord.Interaction, game_state):
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        return
    vote_counts = {}
    skip_votes = 0
    for user_id, data in game_state["players"].items():
        if data["status"] in ["alive", "wounded"]:
            # Ki·ªÉm tra ƒëi·ªÅu ki·ªán ƒë·ªß ƒë·ªÉ vote
            if data["role"] not in NO_NIGHT_ACTION_ROLES or (user_id in game_state["math_results"] and game_state["math_results"][user_id]):
                target_id = game_state["votes"].get(user_id, "skip")
                if target_id == "skip":
                    skip_votes += 1
                elif isinstance(target_id, int):
                    vote_counts[target_id] = vote_counts.get(target_id, 0) + 1
    
    embed = discord.Embed(
        title="üó≥Ô∏è Phi·∫øu vote hi·ªán t·∫°i (sau 30 gi√¢y)",
        color=discord.Color.blue()
    )
    
    if not vote_counts and skip_votes == 0:
        embed.add_field(name="Th√¥ng tin", value="Ch∆∞a c√≥ phi·∫øu vote n√†o h·ª£p l·ªá.", inline=False)
    else:
        for target_id, count in vote_counts.items():
            target = game_state["member_cache"].get(target_id)
            if target:
                embed.add_field(name=target.display_name, value=f"{count} phi·∫øu", inline=True)
        embed.add_field(name="B·ªè qua + D·ªët to√°n", value=f"{skip_votes} phi·∫øu", inline=True)
    
    if game_state["text_channel"] is not None:
        await game_state["text_channel"].send(embed=embed)
    else:
        logger.error("text_channel is None in game_state during display_current_votes")

# H√†m hi·ªÉn th·ªã k·∫øt qu·∫£ vote cu·ªëi c√πng
async def display_final_votes(interaction: discord.Interaction, game_state):
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        return
    vote_counts = {}
    skip_votes = 0
    ineligible_count = 0
    for user_id, data in game_state["players"].items():
        if data["status"] in ["alive", "wounded"]:
            if data["role"] not in NO_NIGHT_ACTION_ROLES or (user_id in game_state["math_results"] and game_state["math_results"][user_id]):
                target_id = game_state["votes"].get(user_id, "skip")
                if target_id == "skip":
                    skip_votes += 1
                elif isinstance(target_id, int):
                    vote_counts[target_id] = vote_counts.get(target_id, 0) + 1
            else:
                ineligible_count += 1
    
    embed = discord.Embed(
        title="üó≥Ô∏è K·∫øt qu·∫£ vote cu·ªëi c√πng",
        color=discord.Color.green()
    )
    
    if not vote_counts and skip_votes == 0 and ineligible_count == 0:
        embed.add_field(name="Th√¥ng tin", value="Kh√¥ng c√≥ phi·∫øu vote n√†o ƒë∆∞·ª£c ghi nh·∫≠n.", inline=False)
    else:
        for target_id, count in vote_counts.items():
            target = game_state["member_cache"].get(target_id)
            if target:
                embed.add_field(name=target.display_name, value=f"{count} phi·∫øu", inline=True)
        
        # T√≠nh v√† hi·ªÉn th·ªã t·ªïng c·ªßa "B·ªè qua" v√† "Kh√¥ng ƒë·ªß ƒëi·ªÅu ki·ªán vote"
        total_skip_and_ineligible = skip_votes + ineligible_count
        embed.add_field(name="B·ªè qua + D·ªët to√°n", value=f"{total_skip_and_ineligible} phi·∫øu", inline=True)
    
    if game_state["text_channel"] is not None:
        await game_state["text_channel"].send(embed=embed)
    else:
        logger.error("text_channel is None in game_state during display_final_votes")
  
async def check_win_condition(interaction: discord.Interaction, game_state):
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("check_win_condition: Game is not running or paused, skipping win condition check")
        return False

    werewolves = 0
    villagers = 0
    for data in game_state["players"].values():
        if data["status"] in ["alive", "wounded"]:
            if data["role"] in WEREWOLF_ROLES and data["role"] != "Illusionist":
                werewolves += 1
            elif data["role"] in VILLAGER_ROLES or data["role"] == "Illusionist":
                villagers += 1

    # Phe D√¢n ch·ªâ th·∫Øng n·∫øu kh√¥ng c√≤n S√≥i v√† kh√¥ng c√≥ l·ªùi nguy·ªÅn ƒëang ch·ªù
    if werewolves == 0 and villagers > 0 and game_state["demon_werewolf_cursed_player"] is None:
        winning_team = "villagers"
        await update_leaderboard(interaction, game_state, winning_team)
        game_logs[interaction.guild.id].append("Phe D√¢n th·∫Øng v√¨ t·∫•t c·∫£ S√≥i ƒë√£ b·ªã ti√™u di·ªát.")
        if game_state["text_channel"] is not None:
            villager_win_embed = discord.Embed(
                title="üéâ Phe D√¢n Th·∫Øng!",
                description="T·∫•t c·∫£ S√≥i ƒë√£ b·ªã ti√™u di·ªát!",
                color=discord.Color.green()
            )
            villager_win_embed.set_image(url=GIF_URLS["villager_win"])
            await game_state["text_channel"].send(embed=villager_win_embed)
        await handle_game_end(interaction, game_state)
        return True
    elif werewolves >= villagers and werewolves > 0:
        winning_team = "werewolves"
        await update_leaderboard(interaction, game_state, winning_team)
        game_logs[interaction.guild.id].append("Phe S√≥i th·∫Øng v√¨ s·ªë S√≥i b·∫±ng ho·∫∑c v∆∞·ª£t s·ªë D√¢n.")
        if game_state["text_channel"] is not None:
            werewolf_win_embed = discord.Embed(
                title="üê∫ Phe S√≥i Th·∫Øng!",
                description="S·ªë S√≥i c√≤n s·ªëng b·∫±ng ho·∫∑c v∆∞·ª£t s·ªë D√¢n!",
                color=discord.Color.red()
            )
            werewolf_win_embed.set_image(url=GIF_URLS["werewolf_win"])
            await game_state["text_channel"].send(embed=werewolf_win_embed)
        await handle_game_end(interaction, game_state)
        return True
    return False

async def get_alive_players(interaction: discord.Interaction, game_state):
    if not game_state["member_cache"]:
        game_state["member_cache"] = {m.id: m for m in await retry_api_call(lambda: interaction.guild.members)}
    alive_players = []
    for user_id, data in game_state["players"].items():
        if data["status"] in ["alive", "wounded"]:
            member = game_state["member_cache"].get(user_id)
            if member:
                alive_players.append(member)
    return alive_players

async def retry_api_call(func, max_attempts=5, initial_delay=2):
    attempt = 1
    delay = initial_delay
    while attempt <= max_attempts:
        try:
            result = func()
            if inspect.iscoroutine(result):
                return await asyncio.wait_for(result, timeout=5)
            return result
        except asyncio.TimeoutError:
            logger.error(f"API call timed out, attempt={attempt}/{max_attempts}, func={func.__name__}")
            if attempt == max_attempts:
                raise discord.errors.HTTPException(response=None, message="API call timed out")
            await asyncio.sleep(delay)
            attempt += 1
            delay *= 2
        except discord.errors.HTTPException as e:
            if e.status == 429:
                logger.warning(f"Rate limit hit, attempt={attempt}/{max_attempts}, retrying in {delay}s")
                await asyncio.sleep(delay)
                attempt += 1
                delay *= 2
            else:
                logger.error(f"HTTPException in API call: {str(e)}, attempt={attempt}, func={func.__name__}")
                raise e
        except Exception as e:
            logger.error(f"API call failed: {str(e)}, attempt={attempt}, func={func.__name__}")
            if attempt == max_attempts:
                raise e
            await asyncio.sleep(delay)
            attempt += 1
            delay *= 2
    raise discord.errors.HTTPException(response=None, message="Max retries exceeded for API call")

# H√†m ph√°t √¢m thanh (ƒë√£ s·ª≠a)
async def play_audio(file_path, voice_connection):
    if voice_connection and voice_connection.is_connected():
        try:
            audio_source = discord.FFmpegPCMAudio(file_path)
            voice_connection.play(audio_source)
            # Kh√¥ng ch·ªù √¢m thanh ph√°t xong, tr·∫£ v·ªÅ ngay ƒë·ªÉ ti·∫øp t·ª•c th·ª±c thi
        except FileNotFoundError:
            logger.error(f"Audio file not found: {file_path}")
        except Exception as e:
            logger.error(f"Error playing audio {file_path}: {str(e)}")

# View cho l·ª±a ch·ªçn k√™nh voice
class VoiceChannelView(discord.ui.View):
    def __init__(self, guild, admin_id, game_states):
        super().__init__(timeout=180)
        self.add_item(VoiceChannelSelect(guild, admin_id, game_states))

class VoiceChannelSelect(discord.ui.Select):
    def __init__(self, guild, admin_id, game_states):
        voice_channels = [ch for ch in guild.voice_channels if ch.members]
        options = [
            discord.SelectOption(label=ch.name, value=str(ch.id))
            for ch in voice_channels[:25]
        ]
        super().__init__(placeholder="Ch·ªçn k√™nh voice", options=options, min_values=1, max_values=1)
        self.guild = guild
        self.admin_id = admin_id
        self.game_states = game_states

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.admin_id:
            await interaction.response.send_message("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        await interaction.response.defer()
        voice_channel_id = int(self.values[0])
        voice_channel = self.guild.get_channel(voice_channel_id)
        if not voice_channel or not voice_channel.members:
            await interaction.followup.send("K√™nh voice n√†y kh√¥ng c√≥ ng∆∞·ªùi ho·∫∑c kh√¥ng t·ªìn t·∫°i!", ephemeral=True)
            return
        guild_id = self.guild.id
        if guild_id not in self.game_states:
            self.game_states[guild_id] = {
                "players": {},
                "voice_channel_id": None,
                "guild_id": guild_id,
                "is_game_running": False,
                "is_game_paused": False,
                "phase": "none",
                "is_first_day": True,
                "protected_player_id": None,
                "previous_protected_player_id": None,
                "werewolf_target_id": None,
                "witch_target_id": None,
                "witch_action": None,
                "witch_has_power": True,
                "hunter_target_id": None,
                "hunter_has_power": True,
                "explorer_target_id": None,
                "votes": {},
                "text_channel": None,
                "wolf_channel": None,
                "dead_channel": None,
                "illusionist_scanned": False,
                "illusionist_effect_active": False,
                "illusionist_effect_night": 0,
                "temp_player_count": 0,
                "temp_players": [],
                "temp_roles": {role: 0 for role in ROLES},
                "temp_admin_id": None,
                "reset_in_progress": False,
                "math_problems": {},
                "math_results": {},
                "member_cache": {},
                "player_channels": {},
                "villager_role_id": None,
                "dead_role_id": None,
                "night_count": 0,
                "voice_connection": None,
                "demon_werewolf_activated": False,
                "demon_werewolf_cursed_player": None,
                "demon_werewolf_has_cursed": False,
                "demon_werewolf_cursed_this_night": False,
                "setup_message": None,
                "assassin_werewolf_has_acted": False,  # Theo d√µi h√†nh ƒë·ªông S√≥i √Åm S√°t
                "assassin_werewolf_target_id": None,   # ID m·ª•c ti√™u c·ªßa S√≥i √Åm S√°t
                "assassin_werewolf_role_guess": None,   # Vai tr√≤ ƒëo√°n c·ªßa S√≥i √Åm S√°t
                "detective_has_used_power": False,
                "detective_target1_id": None,
                "detective_target2_id": None
            }
        game_state = self.game_states[guild_id]
        game_state["voice_channel_id"] = voice_channel_id
        game_state["guild_id"] = self.guild.id
        
        try:
            await interaction.message.edit(
                content=f"ƒê√£ ch·ªçn k√™nh voice {voice_channel.name}. Ch·ªçn s·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i (t·ªëi thi·ªÉu 4, t·ªëi ƒëa {len(voice_channel.members)}):",
                view=PlayerCountView(len(voice_channel.members), self.admin_id, game_state)
            )
        except discord.errors.NotFound:
            logger.warning("Tin nh·∫Øn kh√¥ng t·ªìn t·∫°i ƒë·ªÉ ch·ªânh s·ª≠a, g·ª≠i tin nh·∫Øn m·ªõi.")
            new_message = await interaction.channel.send(
                content=f"ƒê√£ ch·ªçn k√™nh voice {voice_channel.name}. Ch·ªçn s·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i (t·ªëi thi·ªÉu 4, t·ªëi ƒëa {len(voice_channel.members)}):",
                view=PlayerCountView(len(voice_channel.members), self.admin_id, game_state)
            )
            game_state["setup_message"] = new_message

# View cho l·ª±a ch·ªçn s·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i
class PlayerCountView(discord.ui.View):
    def __init__(self, max_players, admin_id, game_state):
        super().__init__(timeout=180)
        self.add_item(PlayerCountSelect(max_players, admin_id, game_state))

class PlayerCountSelect(discord.ui.Select):
    def __init__(self, max_players, admin_id, game_state):
        options = [
            discord.SelectOption(label=str(i), value=str(i))
            for i in range(4, min(max_players + 1, 26))
        ]
        super().__init__(placeholder="Ch·ªçn s·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i", options=options, min_values=1, max_values=1)
        self.admin_id = admin_id
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.admin_id:
            await interaction.response.send_message("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        await interaction.response.defer()
        self.game_state["temp_player_count"] = int(self.values[0])
        voice_channel = interaction.guild.get_channel(self.game_state["voice_channel_id"])
        if voice_channel:
            human_members_count = len([m for m in voice_channel.members if not m.bot])
            if human_members_count < self.game_state["temp_player_count"]:
                await interaction.followup.send("S·ªë ng∆∞·ªùi (kh√¥ng ph·∫£i bot) trong k√™nh voice kh√¥ng ƒë·ªß cho s·ªë l∆∞·ª£ng ƒë√£ ch·ªçn!", ephemeral=True)
                return
        else:
            await interaction.followup.send("K√™nh voice kh√¥ng t·ªìn t·∫°i!", ephemeral=True)
            return
        
        try:
            await interaction.message.edit(
                content=f"ƒê√£ ch·ªçn s·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i: {self.game_state['temp_player_count']}. Ch·ªçn danh s√°ch ng∆∞·ªùi ch∆°i:",
                view=PlayerSelectView(interaction.guild, interaction.user.id, self.game_state)
            )
        except discord.errors.NotFound:
            logger.warning("Tin nh·∫Øn kh√¥ng t·ªìn t·∫°i ƒë·ªÉ ch·ªânh s·ª≠a, g·ª≠i tin nh·∫Øn m·ªõi.")
            new_message = await interaction.channel.send(
                content=f"ƒê√£ ch·ªçn s·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i: {self.game_state['temp_player_count']}. Ch·ªçn danh s√°ch ng∆∞·ªùi ch∆°i:",
                view=PlayerSelectView(interaction.guild, interaction.user.id, self.game_state)
            )
            self.game_state["setup_message"] = new_message

# View cho l·ª±a ch·ªçn ng∆∞·ªùi ch∆°i
class PlayerSelectView(discord.ui.View):
    def __init__(self, guild, admin_id, game_state):
        super().__init__(timeout=180)
        self.add_item(PlayerSelect(guild, admin_id, game_state))

class PlayerSelect(discord.ui.Select):
    def __init__(self, guild, admin_id, game_state):
        voice_channel = guild.get_channel(game_state["voice_channel_id"])
        logger.info(f"Initializing PlayerSelect: voice_channel_id={game_state.get('voice_channel_id')}, voice_channel={voice_channel}, guild_id={guild.id}")
        # L·ªçc b·ªè c√°c bot kh·ªèi danh s√°ch members
        members = [m for m in voice_channel.members if not m.bot][:25] if voice_channel and hasattr(voice_channel, 'members') else []
        if not members:
            options = [discord.SelectOption(label="Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i", value="none")]
            min_values = 1
            max_values = 1
        else:
            options = []
            for member in members:
                try:
                    options.append(discord.SelectOption(label=member.display_name, value=str(member.id)))
                except Exception as e:
                    logger.error(f"Error creating SelectOption for player ID={member.id}, DisplayName={repr(member.display_name)}, error={str(e)}")
                    continue
            actual_options = len(options)
            min_values = min(game_state["temp_player_count"], actual_options)
            max_values = min(game_state["temp_player_count"], actual_options)
        super().__init__(
            placeholder="Ch·ªçn ng∆∞·ªùi ch∆°i",
            options=options,
            min_values=min_values,
            max_values=max_values
        )
        self.admin_id = admin_id
        self.guild = guild
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.admin_id:
            await text_channel.send("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        await interaction.response.defer()
        try:
            voice_channel_id = self.game_state.get("voice_channel_id")
            if not voice_channel_id:
                logger.error(f"No voice_channel_id in game_state, interaction_id={interaction.id}")
                await interaction.followup.send("L·ªói: Kh√¥ng t√¨m th·∫•y ID k√™nh voice. Vui l√≤ng ch·∫°y l·∫°i !start_game!", ephemeral=True)
                return
            voice_channel = self.guild.get_channel(voice_channel_id)
            if not voice_channel:
                logger.error(f"Voice channel not found: ID={voice_channel_id}, interaction_id={interaction.id}")
                await interaction.followup.send("L·ªói: K√™nh voice kh√¥ng t·ªìn t·∫°i. Vui l√≤ng ch·∫°y l·∫°i !start_game!", ephemeral=True)
                return
            current_members = await retry_api_call(lambda: {m.id: m for m in voice_channel.members if m}, max_attempts=5, initial_delay=2)
            if not current_members:
                logger.error(f"No members in voice channel: ID={voice_channel_id}, interaction_id={interaction.id}")
                await interaction.followup.send("L·ªói: K√™nh voice kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o! Vui l√≤ng ki·ªÉm tra v√† th·ª≠ l·∫°i.", ephemeral=True)
                return
            if "none" in self.values:
                logger.error(f"No players available in voice channel, interaction_id={interaction.id}")
                await interaction.followup.send("Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i trong k√™nh voice!", ephemeral=True)
                return
            self.game_state["member_cache"] = {m.id: m for m in await retry_api_call(lambda: self.guild.members, max_attempts=5, initial_delay=2)}
            selected_ids = []
            selected_names = []
            for id_str in self.values:
                try:
                    user_id = int(id_str)
                    if user_id not in current_members:
                        logger.warning(f"Player ID={user_id} not in voice channel, interaction_id={interaction.id}")
                        await interaction.followup.send(f"M·ªôt ng∆∞·ªùi ch∆°i (ID: {id_str}) ƒë√£ r·ªùi k√™nh voice! Vui l√≤ng ch·ªçn l·∫°i.", ephemeral=True)
                        return
                    member = self.game_state["member_cache"].get(user_id)
                    if not member or not isinstance(member, discord.Member):
                        logger.error(f"Failed to fetch member: ID={user_id}, member={member}, interaction_id={interaction.id}")
                        await interaction.followup.send(f"Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i v·ªõi ID {id_str}! C√≥ th·ªÉ h·ªç ƒë√£ r·ªùi server.", ephemeral=True)
                        return
                    voice_state = member.voice
                    if not voice_state or not voice_state.channel or voice_state.channel.id != voice_channel_id:
                        logger.error(f"Player ID={user_id} has invalid voice state: voice={voice_state}, channel={voice_state.channel if voice_state else None}, interaction_id={interaction.id}")
                        await interaction.followup.send(f"Ng∆∞·ªùi ch∆°i {member.display_name} kh√¥ng c√≤n trong k√™nh voice h·ª£p l·ªá!", ephemeral=True)
                        return
                    selected_ids.append(user_id)
                    selected_names.append(member.display_name)
                except ValueError as ve:
                    logger.error(f"Invalid ID in PlayerSelect: {id_str}, error={str(ve)}, interaction_id={interaction.id}")
                    await interaction.followup.send("L·ªói: ID ng∆∞·ªùi ch∆°i kh√¥ng h·ª£p l·ªá!", ephemeral=True)
                    return
                except Exception as e:
                    logger.error(f"Error processing player ID={id_str}, error={str(e)}, interaction_id={interaction.id}")
                    await interaction.followup.send(f"L·ªói khi x·ª≠ l√Ω ng∆∞·ªùi ch∆°i ID {id_str}. Vui l√≤ng th·ª≠ l·∫°i!", ephemeral=True)
                    return
            if len(selected_ids) != self.game_state["temp_player_count"]:
                await interaction.followup.send(
                    f"Vui l√≤ng ch·ªçn ƒë√∫ng {self.game_state['temp_player_count']} ng∆∞·ªùi ch∆°i! ƒê√£ ch·ªçn: {len(selected_ids)}",
                    ephemeral=True
                )
                return
            self.game_state["temp_players"] = selected_ids
            selected_players_str = ", ".join(selected_names)
            
            try:
                await interaction.message.edit(
                    content=f"ƒê√£ ch·ªçn ng∆∞·ªùi ch∆°i: {selected_players_str}. Ch·ªçn s·ªë l∆∞·ª£ng S√≥i, D√¢n L√†ng v√† vai ƒë·∫∑c bi·ªát (t·ªïng ph·∫£i b·∫±ng {self.game_state['temp_player_count']}):",
                    view=RoleSelectView(interaction.user.id, self.game_state)
                )
            except discord.errors.NotFound:
                logger.warning("Tin nh·∫Øn kh√¥ng t·ªìn t·∫°i ƒë·ªÉ ch·ªânh s·ª≠a, g·ª≠i tin nh·∫Øn m·ªõi.")
                new_message = await interaction.channel.send(
                    content=f"ƒê√£ ch·ªçn ng∆∞·ªùi ch∆°i: {selected_players_str}. Ch·ªçn s·ªë l∆∞·ª£ng S√≥i, D√¢n L√†ng v√† vai ƒë·∫∑c bi·ªát (t·ªïng ph·∫£i b·∫±ng {self.game_state['temp_player_count']}):",
                    view=RoleSelectView(interaction.user.id, self.game_state)
                )
                self.game_state["setup_message"] = new_message
        except Exception as e:
            logger.error(f"Unexpected error in PlayerSelect.callback: error={str(e)}, interaction_id={interaction.id}")
            await interaction.followup.send("L·ªói kh√¥ng x√°c ƒë·ªãnh khi x·ª≠ l√Ω l·ª±a ch·ªçn ng∆∞·ªùi ch∆°i. Vui l√≤ng th·ª≠ l·∫°i!", ephemeral=True)

# View cho l·ª±a ch·ªçn vai tr√≤
class RoleSelectView(discord.ui.View):
    def __init__(self, admin_id, game_state):
        super().__init__(timeout=180)
        self.admin_id = admin_id
        self.game_state = game_state
        logger.info(f"Initializing RoleSelectView: admin_id={admin_id}, temp_player_count={game_state['temp_player_count']}, temp_roles={game_state['temp_roles']}")
        self.add_item(WerewolfCountSelect(game_state))
        self.add_item(VillagerCountSelect(game_state))
        self.add_item(VillagerSpecialRoleSelect(game_state))
        self.add_item(WerewolfSpecialRoleSelect(game_state))
        self.add_item(ConfirmButton(game_state))
        self.add_item(ResetRolesButton(game_state))

class WerewolfCountSelect(discord.ui.Select):
    def __init__(self, game_state):
        total_roles = sum(game_state["temp_roles"].values())
        remaining = game_state["temp_player_count"] - total_roles
        options = [
            discord.SelectOption(label=str(i), value=str(i))
            for i in range(0, min(remaining + game_state["temp_roles"]["Werewolf"] + 1, game_state["temp_player_count"] + 1))
        ]
        super().__init__(
            placeholder=f"Ch·ªçn s·ªë l∆∞·ª£ng S√≥i (hi·ªán t·∫°i: {game_state['temp_roles']['Werewolf']})",
            options=options,
            min_values=1,
            max_values=1
        )
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        count = int(self.values[0])
        self.game_state["temp_roles"]["Werewolf"] = count
        total_roles = sum(self.game_state["temp_roles"].values())
        remaining = self.game_state["temp_player_count"] - total_roles
        logger.info(f"Werewolf count selected: count={count}, total_roles={total_roles}, remaining={remaining}, interaction_id={interaction.id}")
        role_summary = "\n".join([f"{role}: {count}" for role, count in self.game_state["temp_roles"].items()])
        new_content = (f"Ch·ªçn s·ªë l∆∞·ª£ng S√≥i, D√¢n L√†ng v√† vai ƒë·∫∑c bi·ªát (t·ªïng ph·∫£i b·∫±ng {self.game_state['temp_player_count']}):\n"
                       f"Tr·∫°ng th√°i vai tr√≤:\n{role_summary}\n"
                       f"T·ªïng vai: {total_roles}/{self.game_state['temp_player_count']} (c√≤n {remaining})")
        new_view = RoleSelectView(self.view.admin_id, self.game_state)
        await interaction.response.edit_message(content=new_content, view=new_view)

class VillagerCountSelect(discord.ui.Select):
    def __init__(self, game_state):
        total_roles = sum(game_state["temp_roles"].values())
        remaining = game_state["temp_player_count"] - total_roles
        options = [
            discord.SelectOption(label=str(i), value=str(i))
            for i in range(0, min(remaining + game_state["temp_roles"]["Villager"] + 1, game_state["temp_player_count"] + 1))
        ]
        super().__init__(
            placeholder=f"Ch·ªçn s·ªë l∆∞·ª£ng D√¢n L√†ng (hi·ªán t·∫°i: {game_state['temp_roles']['Villager']})",
            options=options,
            min_values=1,
            max_values=1
        )
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        count = int(self.values[0])
        self.game_state["temp_roles"]["Villager"] = count
        total_roles = sum(self.game_state["temp_roles"].values())
        remaining = self.game_state["temp_player_count"] - total_roles
        logger.info(f"Villager count selected: count={count}, total_roles={total_roles}, remaining={remaining}, interaction_id={interaction.id}")
        role_summary = "\n".join([f"{role}: {count}" for role, count in self.game_state["temp_roles"].items()])
        new_content = (f"Ch·ªçn s·ªë l∆∞·ª£ng S√≥i, D√¢n L√†ng v√† vai ƒë·∫∑c bi·ªát (t·ªïng ph·∫£i b·∫±ng {self.game_state['temp_player_count']}):\n"
                       f"Tr·∫°ng th√°i vai tr√≤:\n{role_summary}\n"
                       f"T·ªïng vai: {total_roles}/{self.game_state['temp_player_count']} (c√≤n {remaining})")
        new_view = RoleSelectView(self.view.admin_id, self.game_state)
        await interaction.response.edit_message(content=new_content, view=new_view)

class VillagerSpecialRoleSelect(discord.ui.Select):
    def __init__(self, game_state):
        total_roles = sum(game_state["temp_roles"].values())
        remaining = game_state["temp_player_count"] - total_roles
        options = []
        for role in VILLAGER_SPECIAL_ROLES:
            if game_state["temp_roles"].get(role, 0) == 0 and remaining > 0:
                options.append(discord.SelectOption(label=role, value=role))
        if not options:
            options.append(discord.SelectOption(label="Kh√¥ng c√≤n vai ƒë·∫∑c bi·ªát Phe D√¢n", value="none"))
        super().__init__(
            placeholder=f"Ch·ªçn vai ƒë·∫∑c bi·ªát Phe D√¢n (c√≤n {remaining} vai)",
            options=options,
            min_values=1,
            max_values=1
        )
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        if self.values[0] == "none":
            await text_channel.send("Kh√¥ng c√≤n vai ƒë·∫∑c bi·ªát Phe D√¢n ƒë·ªÉ ch·ªçn!", ephemeral=True)
            return
        role = self.values[0]
        self.game_state["temp_roles"][role] = 1
        total_roles = sum(self.game_state["temp_roles"].values())
        remaining = self.game_state["temp_player_count"] - total_roles
        logger.info(f"Villager special role selected: role={role}, count=1, total_roles={total_roles}, remaining={remaining}, interaction_id={interaction.id}")
        role_summary = "\n".join([f"{r}: {count}" for r, count in self.game_state["temp_roles"].items()])
        new_content = (f"Ch·ªçn s·ªë l∆∞·ª£ng S√≥i, D√¢n L√†ng v√† vai ƒë·∫∑c bi·ªát (t·ªïng ph·∫£i b·∫±ng {self.game_state['temp_player_count']}):\n"
                       f"Tr·∫°ng th√°i vai tr√≤:\n{role_summary}\n"
                       f"T·ªïng vai: {total_roles}/{self.game_state['temp_player_count']} (c√≤n {remaining})")
        new_view = RoleSelectView(self.view.admin_id, self.game_state)
        await interaction.response.edit_message(content=new_content, view=new_view)

class WerewolfSpecialRoleSelect(discord.ui.Select):
    def __init__(self, game_state):
        total_roles = sum(game_state["temp_roles"].values())
        remaining = game_state["temp_player_count"] - total_roles
        options = []
        for role in WEREWOLF_SPECIAL_ROLES:
            if game_state["temp_roles"].get(role, 0) == 0 and remaining > 0:
                options.append(discord.SelectOption(label=role, value=role))
        if not options:
            options.append(discord.SelectOption(label="Kh√¥ng c√≤n vai ƒë·∫∑c bi·ªát Phe S√≥i", value="none"))
        super().__init__(
            placeholder=f"Ch·ªçn vai ƒë·∫∑c bi·ªát Phe S√≥i (c√≤n {remaining} vai)",
            options=options,
            min_values=1,
            max_values=1
        )
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        if self.values[0] == "none":
            await text_channel.send("Kh√¥ng c√≤n vai ƒë·∫∑c bi·ªát Phe S√≥i ƒë·ªÉ ch·ªçn!", ephemeral=True)
            return
        role = self.values[0]
        self.game_state["temp_roles"][role] = 1
        total_roles = sum(self.game_state["temp_roles"].values())
        remaining = self.game_state["temp_player_count"] - total_roles
        logger.info(f"Werewolf special role selected: role={role}, count=1, total_roles={total_roles}, remaining={remaining}, interaction_id={interaction.id}")
        role_summary = "\n".join([f"{r}: {count}" for r, count in self.game_state["temp_roles"].items()])
        new_content = (f"Ch·ªçn s·ªë l∆∞·ª£ng S√≥i, D√¢n L√†ng v√† vai ƒë·∫∑c bi·ªát (t·ªïng ph·∫£i b·∫±ng {self.game_state['temp_player_count']}):\n"
                       f"Tr·∫°ng th√°i vai tr√≤:\n{role_summary}\n"
                       f"T·ªïng vai: {total_roles}/{self.game_state['temp_player_count']} (c√≤n {remaining})")
        new_view = RoleSelectView(self.view.admin_id, self.game_state)
        await interaction.response.edit_message(content=new_content, view=new_view)

class ConfirmButton(discord.ui.Button):
    def __init__(self, game_state):
        super().__init__(label="X√°c nh·∫≠n", style=discord.ButtonStyle.green)
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        total_roles = sum(self.game_state["temp_roles"].values())
        logger.info(f"ConfirmButton clicked: total_roles={total_roles}, expected={self.game_state['temp_player_count']}, temp_roles={self.game_state['temp_roles']}, interaction_id={interaction.id}")
        if total_roles != self.game_state["temp_player_count"]:
            await text_channel.send(
                f"T·ªïng s·ªë vai ({total_roles}) kh√¥ng kh·ªõp v·ªõi s·ªë ng∆∞·ªùi ch∆°i ({self.game_state['temp_player_count']})!",
                ephemeral=True
            )
            return
        if self.game_state["temp_roles"]["Werewolf"] + self.game_state["temp_roles"]["Wolfman"] + self.game_state["temp_roles"]["Assassin Werewolf"] < 1:
            await text_channel.send("Ph·∫£i c√≥ √≠t nh·∫•t 1 S√≥i, Ng∆∞·ªùi S√≥i ho·∫∑c S√≥i √Åm S√°t!", ephemeral=True)
            return
        if self.game_state["temp_roles"]["Villager"] < 0:
            await text_channel.send("S·ªë D√¢n L√†ng kh√¥ng th·ªÉ √¢m!", ephemeral=True)
            return
        await interaction.response.edit_message(content="Kh·ªüi t·∫°o game!", view=None)
        await start_game_logic(interaction, self.game_state)

class ResetRolesButton(discord.ui.Button):
    def __init__(self, game_state):
        super().__init__(label="Reset Roles", style=discord.ButtonStyle.red)
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.game_state["temp_admin_id"]:
            await text_channel.send("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        self.game_state["temp_roles"] = {role: 0 for role in ROLES}
        total_roles = sum(self.game_state["temp_roles"].values())
        remaining = self.game_state["temp_player_count"] - total_roles
        logger.info(f"Roles reset: temp_roles={self.game_state['temp_roles']}, interaction_id={interaction.id}")
        role_summary = "\n".join([f"{role}: {count}" for role, count in self.game_state["temp_roles"].items()])
        new_content = (f"ƒê√£ reset vai tr√≤. Ch·ªçn s·ªë l∆∞·ª£ng S√≥i, D√¢n L√†ng v√† vai ƒë·∫∑c bi·ªát (t·ªïng ph·∫£i b·∫±ng {self.game_state['temp_player_count']}):\n"
                       f"Tr·∫°ng th√°i vai tr√≤:\n{role_summary}\n"
                       f"T·ªïng vai: {total_roles}/{self.game_state['temp_player_count']} (c√≤n {remaining})")
        new_view = RoleSelectView(self.view.admin_id, self.game_state)
        await interaction.response.edit_message(content=new_content, view=new_view)

# View cho b√†i to√°n ban ƒë√™m
class NightMathView(discord.ui.View):
    def __init__(self, user_id, options, correct_answer, game_state, timeout=40):
        super().__init__(timeout=timeout)
        self.user_id = user_id
        self.correct_answer = correct_answer
        self.game_state = game_state
        for option in options:
            self.add_item(MathAnswerButton(option, option == correct_answer, user_id, game_state))

class MathAnswerButton(discord.ui.Button):
    def __init__(self, answer, is_correct, user_id, game_state):
        super().__init__(label=str(answer), style=discord.ButtonStyle.primary)
        self.answer = answer
        self.is_correct = is_correct
        self.user_id = user_id
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("ƒê√¢y kh√¥ng ph·∫£i b√†i to√°n c·ªßa b·∫°n!", ephemeral=True)
            return
        if self.game_state["phase"] != "night":
            await interaction.response.send_message("Ch∆∞a ph·∫£i pha ƒë√™m!", ephemeral=True)
            return
        if self.game_state["is_game_paused"]:
            await interaction.response.send_message("Game ƒëang t·∫°m d·ª´ng, kh√¥ng th·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông!", ephemeral=True)
            return
        if not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Vui l√≤ng tr·∫£ l·ªùi qua DM!", ephemeral=True)
            return
        if interaction.user.id not in self.game_state["math_problems"]:
            await interaction.response.send_message("B·∫°n ƒë√£ tr·∫£ l·ªùi ho·∫∑c kh√¥ng c√≥ b√†i to√°n!", ephemeral=True)
            return

        if self.is_correct:
            self.game_state["math_results"][self.user_id] = True
            await interaction.response.send_message("ƒê√∫ng! B·∫°n ƒë√£ ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ b·ªè phi·∫øu v√†o ban ng√†y.", ephemeral=True)
        else:
            self.game_state["math_results"][self.user_id] = False
            await interaction.response.send_message("Sai! B·∫°n s·∫Ω kh√¥ng ƒë∆∞·ª£c b·ªè phi·∫øu v√†o ban ng√†y.", ephemeral=True)

        del self.game_state["math_problems"][self.user_id]
        for child in self.view.children:
            child.disabled = True
        await interaction.message.edit(view=self.view)

#Leader board
async def update_leaderboard(interaction: discord.Interaction, game_state, winning_team):
    guild_id = interaction.guild.id  # Guild ID as integer
    try:
        db = get_db_connection()
        cursor = db.cursor()

        # T·∫°o b·∫£ng n·∫øu ch∆∞a t·ªìn t·∫°i
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS leaderboard (
                id INT AUTO_INCREMENT PRIMARY KEY,
                guild_id BIGINT NOT NULL,
                player_id BIGINT NOT NULL,
                player_name VARCHAR(255) NOT NULL,
                score INT DEFAULT 0,
                UNIQUE KEY unique_guild_player (guild_id, player_id)
            )
        """)

        # Chu·∫©n b·ªã c·∫≠p nh·∫≠t cho t·∫•t c·∫£ ng∆∞·ªùi ch∆°i
        updates = []
        for user_id, data in game_state["players"].items():
            member = game_state["member_cache"].get(user_id)
            if not member:
                continue

            player_id = user_id
            player_name = member.display_name

            # X√°c ƒë·ªãnh ƒë·ªôi c·ªßa ng∆∞·ªùi ch∆°i
            if data["role"] in VILLAGER_ROLES:
                player_team = "villagers"
            elif data["role"] in WEREWOLF_ROLES:
                player_team = "werewolves"
            else:
                continue

            # T√≠nh to√°n m·ª©c tƒÉng ƒëi·ªÉm
            if player_team == winning_team:
                score_increment = 3 if data["status"] in ["alive", "wounded"] else 1
            else:
                score_increment = -1

            updates.append((guild_id, player_id, player_name, score_increment))

        if updates:
            # C·∫≠p nh·∫≠t h√†ng lo·∫°t b·∫±ng executemany
            cursor.executemany("""
                INSERT INTO leaderboard (guild_id, player_id, player_name, score)
                VALUES (%s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE
                player_name = VALUES(player_name),
                score = score + VALUES(score)
            """, updates)
            db.commit()

        logger.info(f"Leaderboard updated for guild {guild_id}")

    except mysql.connector.Error as err:
        logger.error(f"MySQL Error updating leaderboard for guild {guild_id}: {err}")
        if game_state["text_channel"]:
            await game_state["text_channel"].send(f"L·ªói MySQL khi c·∫≠p nh·∫≠t leaderboard: {err}")
    except Exception as e:
        logger.error(f"Error updating leaderboard for guild {guild_id}: {e}")
        if game_state["text_channel"]:
            await game_state["text_channel"].send(f"L·ªói khi c·∫≠p nh·∫≠t leaderboard: {e}")
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'db' in locals():
            db.close()

# View cho Detective
class DetectiveSelectView(discord.ui.View):
    def __init__(self, detective_id, alive_players, game_state):
        super().__init__(timeout=180)
        self.detective_id = detective_id
        self.game_state = game_state
        options = [
            discord.SelectOption(label=member.display_name, value=str(member.id))
            for member in alive_players if member.id != detective_id
        ]
        self.select = discord.ui.Select(
            placeholder="Ch·ªçn hai ng∆∞·ªùi ch∆°i ƒë·ªÉ ki·ªÉm tra",
            options=options,
            min_values=2,
            max_values=2
        )
        self.select.callback = self.select_callback
        self.add_item(self.select)

    async def select_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.detective_id:
            await interaction.response.send_message("Ch·ªâ th√°m t·ª≠ ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        if self.game_state["phase"] != "night":
            await interaction.response.send_message("Ch∆∞a ph·∫£i pha ƒë√™m!", ephemeral=True)
            return
        if self.game_state["is_game_paused"]:
            await interaction.response.send_message("Game ƒëang t·∫°m d·ª´ng, kh√¥ng th·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông!", ephemeral=True)
            return
        if self.game_state["detective_has_used_power"]:
            await interaction.response.send_message("B·∫°n ƒë√£ s·ª≠ d·ª•ng quy·ªÅn c·ªßa m√¨nh!", ephemeral=True)
            return
        target1_id = int(self.select.values[0])
        target2_id = int(self.select.values[1])
        if target1_id == target2_id:
            awaitinteraction.response.send_message("B·∫°n ph·∫£i ch·ªçn hai ng∆∞·ªùi ch∆°i kh√°c nhau!", ephemeral=True)
            return
        target1_role = self.game_state["players"][target1_id]["role"]
        target2_role = self.game_state["players"][target2_id]["role"]
        target1_team = get_player_team(target1_role)
        target2_team = get_player_team(target2_role)
        if target1_team == target2_team:
            result = "Hai ng∆∞·ªùi ch∆°i n√†y c√πng phe."
        else:
            result = "Hai ng∆∞·ªùi ch∆°i n√†y kh√°c phe."
        await interaction.response.send_message(f"K·∫øt qu·∫£: {result}", ephemeral=True)
        self.game_state["detective_has_used_power"] = True
        self.game_state["detective_target1_id"] = target1_id
        self.game_state["detective_target2_id"] = target2_id
        for child in self.children:
            child.disabled = True
        await interaction.message.edit(view=self)
        # Th√¥ng b√°o b·ªï sung cho Th√°m T·ª≠
        await interaction.followup.send("B·∫°n ƒë√£ s·ª≠ d·ª•ng quy·ªÅn c·ªßa m√¨nh v√† kh√¥ng c√≤n ch·ª©c nƒÉng n·ªØa.", ephemeral=True)
      
# H√†m x·ª≠ l√Ω logic b·∫Øt ƒë·∫ßu game
async def start_game_logic(interaction: discord.Interaction, game_state):
    await interaction.followup.send("Game ƒëang ƒë∆∞·ª£c kh·ªüi t·∫°o...", ephemeral=True)
    voice_channel = bot.get_channel(game_state["voice_channel_id"])
    guild = interaction.guild
    text_channel = interaction.channel
    if not text_channel:
        logger.error("morning_phase: text_channel is None, cannot proceed with morning phase")
        return

    # Ki·ªÉm tra v√† ng·∫Øt k·∫øt n·ªëi n·∫øu bot ƒë√£ ·ªü trong k√™nh voice
    if game_state["voice_connection"] and game_state["voice_connection"].is_connected():
        await game_state["voice_connection"].disconnect()
        logger.info(f"Bot ƒë√£ ng·∫Øt k·∫øt n·ªëi kh·ªèi k√™nh voice c≈©: ID={game_state['voice_channel_id']}")

    # Tham gia k√™nh voice m·ªõi
    try:
        game_state["voice_connection"] = await voice_channel.connect()
        logger.info(f"Bot ƒë√£ tham gia k√™nh voice: ID={voice_channel.id}, Name={voice_channel.name}")
    except Exception as e:
        logger.error(f"Kh√¥ng th·ªÉ tham gia k√™nh voice ID={voice_channel.id}: {str(e)}")
        await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ tham gia k√™nh voice {voice_channel.name}.")
        return

    # T·∫°o vai tr√≤ Discord
    villager_role = await guild.create_role(name="Villager", color=discord.Color.green(), hoist=True, mentionable=False)
    game_state["villager_role_id"] = villager_role.id
    dead_role = await guild.create_role(name="Dead", color=discord.Color.greyple(), hoist=True, mentionable=False)
    game_state["dead_role_id"] = dead_role.id
    werewolf_role = await guild.create_role(name="Werewolf", color=discord.Color.red(), hoist=False, mentionable=False)
    game_state["werewolf_role_id"] = werewolf_role.id

    await voice_channel.set_permissions(dead_role, speak=False)

    # L·∫•y danh s√°ch ng∆∞·ªùi ch∆°i ƒë√£ ch·ªçn
    selected_players = [game_state["member_cache"].get(uid) for uid in game_state["temp_players"]]
    if None in selected_players:
        await text_channel.send("L·ªói: Kh√¥ng t√¨m th·∫•y m·ªôt ho·∫∑c nhi·ªÅu ng∆∞·ªùi ch∆°i!")
        return

    # Thi·∫øt l·∫≠p k√™nh
    text_channel = interaction.channel
    await text_channel.set_permissions(guild.default_role, send_messages=False)
    await text_channel.set_permissions(villager_role, send_messages=True)
    await text_channel.set_permissions(dead_role, send_messages=False)
    
    wolf_channel = await setup_wolf_channel(guild, game_state)
    dead_channel = await setup_dead_channel(guild, game_state)
    
    # T·∫°o c√°c k√™nh voice ri√™ng bi·ªát cho t·ª´ng ng∆∞·ªùi ch∆°i
    game_state["player_channels"] = {}
    for member in selected_players:
        max_name_length = 100 - len("House of ") - 1  # ƒê·∫£m b·∫£o t√™n kh√¥ng v∆∞·ª£t qu√° 100 k√Ω t·ª±
        channel_name = f"House of {member.display_name[:max_name_length]}"
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False, connect=False),
            member: discord.PermissionOverwrite(read_messages=True, connect=True),
            guild.me: discord.PermissionOverwrite(read_messages=True, connect=True)
        }
        channel = await guild.create_voice_channel(channel_name, overwrites=overwrites)
        game_state["player_channels"][member.id] = channel
        logger.info(f"Created private voice channel for player: {member.display_name}, channel_id={channel.id}")
    
    # G√°n vai tr√≤ v√† g·ª≠i tin nh·∫Øn th√¥ng b√°o vai tr√≤
    roles = [role for role, count in game_state["temp_roles"].items() for _ in range(count)]
    random.shuffle(roles)
    game_state["players"] = {}
    for i, member in enumerate(selected_players):
        role = roles[i]
        game_state["players"][member.id] = {"role": role, "status": "alive", "muted": False}
        await member.add_roles(villager_role)
        if role in ["Werewolf", "Wolfman", "Demon Werewolf", "Assassin Werewolf"]:
            await member.add_roles(werewolf_role)
        role_icon_url = ROLE_ICONS.get(role, "https://example.com/default_icon.png")
        embed = discord.Embed(
            title="Vai Tr√≤ C·ªßa B·∫°n",
            description=f"B·∫°n ƒë√£ ƒë∆∞·ª£c ph√¢n vai: **{role}**",
            color=discord.Color.blue()
        )
        embed.set_thumbnail(url=role_icon_url)
        await retry_api_call(lambda: member.send(embed=embed))

    # C·∫≠p nh·∫≠t tr·∫°ng th√°i game
    game_state["voice_channel_id"] = voice_channel.id
    game_state["guild_id"] = interaction.guild.id
    game_state["text_channel"] = interaction.channel
    game_state["is_game_running"] = True
    game_state["witch_has_power"] = game_state["temp_roles"]["Witch"] > 0
    game_state["hunter_has_power"] = game_state["temp_roles"]["Hunter"] > 0
    game_state["is_first_day"] = True
    game_state["night_count"] = 0
    game_state["demon_werewolf_activated"] = False
    game_state["demon_werewolf_cursed_player"] = None
    game_state["demon_werewolf_has_cursed"] = False
    game_state["demon_werewolf_cursed_this_night"] = False
    game_state["wolf_channel"] = wolf_channel

    # Ghi log v√† g·ª≠i h∆∞·ªõng d·∫´n c·ª• th·ªÉ theo vai tr√≤
    role_counts = {role: 0 for role in ROLES}
    illusionist_id = None
    werewolf_ids = []
    game_logs[interaction.guild.id] = []
    role_log = []
    for member in selected_players:
        role = game_state["players"][member.id]["role"]
        role_counts[role] += 1
        role_log.append(f"{member.display_name}: {role} (S·ªëng)")
        if role == "Werewolf":
            await retry_api_call(lambda: wolf_channel.set_permissions(member, read_messages=True, send_messages=True))
            await retry_api_call(lambda: member.send("B·∫°n l√† S√≥i! Th·∫£o lu·∫≠n v·ªõi ƒë·ªìng ƒë·ªôi trong k√™nh wolf-chat v√†o pha ƒë√™m v√† ch·ªçn m·ª•c ti√™u b·∫±ng n√∫t ch·ªçn."))
            werewolf_ids.append(member.id)
        elif role == "Wolfman":
            await retry_api_call(lambda: wolf_channel.set_permissions(member, read_messages=True, send_messages=True))
            await retry_api_call(lambda: member.send("B·∫°n l√† Ng∆∞·ªùi S√≥i! Th·ª©c d·∫≠y c√πng b·∫ßy S√≥i trong k√™nh wolf-chat v√† ch·ªçn m·ª•c ti√™u b·∫±ng n√∫t ch·ªçn. B·∫°n hi·ªÉn th·ªã l√† Phe D√¢n n·∫øu b·ªã Ti√™n Tri soi."))
            werewolf_ids.append(member.id)
        elif role == "Witch":
            await retry_api_call(lambda: member.send("B·∫°n l√† Ph√π Th·ªßy! M·ªói ƒë√™m, b·∫°n s·∫Ω nh·∫≠n th√¥ng b√°o mu·ªôn h∆°n v·ªÅ ng∆∞·ªùi b·ªã gi·∫øt v√† c√≥ 20 gi√¢y ƒë·ªÉ c·ª©u ho·∫∑c gi·∫øt b·∫±ng n√∫t ch·ªçn."))
        elif role == "Hunter":
            await retry_api_call(lambda: member.send("B·∫°n l√† Th·ª£ SƒÉn! B·∫°n c√≥ 40 gi√¢y ƒë·∫ßu m·ªói ƒë√™m ƒë·ªÉ ch·ªçn ng∆∞·ªùi gi·∫øt b·∫±ng n√∫t ch·ªçn qua DM."))
        elif role == "Tough Guy":
            await retry_api_call(lambda: member.send("B·∫°n l√† Ng∆∞·ªùi C·ª©ng C·ªèi! B·∫°n c√≥ 2 m·∫°ng ƒë·ªëi v·ªõi c√°c h√†nh ƒë·ªông gi·∫øt v√†o ban ƒë√™m, ph·∫£i b·ªã gi·∫øt 2 l·∫ßn v√†o ban ƒë√™m ƒë·ªÉ ch·∫øt ho√†n to√†n. Kh√¥ng c√≥ th√¥ng b√°o khi m·∫•t m·∫°ng. N·∫øu b·ªã ng·ªìi gh·∫ø ƒëi·ªán ban ng√†y, b·∫°n ch·∫øt ngay l·∫≠p t·ª©c. B·∫°n ph·∫£i ch·ªçn ƒë√°p √°n ƒë√∫ng trong b√†i to√°n c·ªông/tr·ª´ ƒë·ªÉ ƒë∆∞·ª£c quy·ªÅn b·ªè phi·∫øu."))
        elif role == "Illusionist":
            illusionist_id = member.id
            await retry_api_call(lambda: member.send("B·∫°n l√† Nh√† ·∫¢o Gi√°c! B·∫°n thu·ªôc phe S√≥i nh∆∞ng kh√¥ng th·ª©c d·∫≠y trong wolf-chat v√† kh√¥ng bi·∫øt ai l√† S√≥i. S√≥i bi·∫øt b·∫°n l√† Nh√† ·∫¢o Gi√°c. B·∫°n ph·∫£i ch·ªçn ƒë√°p √°n ƒë√∫ng trong b√†i to√°n c·ªông/tr·ª´ v√†o ban ƒë√™m ƒë·ªÉ ƒë∆∞·ª£c quy·ªÅn b·ªè phi·∫øu."))
        elif role == "Explorer":
            game_state["explorer_id"] = member.id
            game_state["explorer_can_act"] = True
            await retry_api_call(lambda: member.send("B·∫°n l√† Ng∆∞·ªùi Kh√°m Ph√°! T·ª´ ƒë√™m th·ª© hai, m·ªói ƒë√™m b·∫°n ph·∫£i ch·ªçn gi·∫øt m·ªôt ng∆∞·ªùi qua DM. N·∫øu kh√¥ng ch·ªçn, b·∫°n s·∫Ω m·∫•t ch·ª©c nƒÉng. N·∫øu ch·ªçn ƒë√∫ng S√≥i (kh√¥ng t√≠nh Nh√† ·∫¢o Gi√°c), S√≥i s·∫Ω ch·∫øt. N·∫øu ch·ªçn tr√∫ng Phe D√¢n (t√≠nh c·∫£ Nh√† ·∫¢o Gi√°c), b·∫°n s·∫Ω ch·∫øt."))
        elif role == "Villager":
            await retry_api_call(lambda: member.send("B·∫°n l√† D√¢n L√†ng! B·∫°n kh√¥ng c√≥ ch·ª©c nƒÉng ƒë·∫∑c bi·ªát v√†o ban ƒë√™m, nh∆∞ng ph·∫£i ch·ªçn ƒë√°p √°n ƒë√∫ng trong b√†i to√°n c·ªông/tr·ª´ ƒë·ªÉ ƒë∆∞·ª£c quy·ªÅn b·ªè phi·∫øu v√†o ban ng√†y."))
        elif role == "Demon Werewolf":
            await retry_api_call(lambda: wolf_channel.set_permissions(member, read_messages=True, send_messages=True))
            await retry_api_call(lambda: member.send("B·∫°n l√† S√≥i Qu·ª∑! Khi m·ªôt S√≥i b·∫•t k·ª≥ ch·∫øt, b·∫°n c√≥ th·ªÉ nguy·ªÅn m·ªôt ng∆∞·ªùi qua DM ƒë·ªÉ bi·∫øn h·ªç th√†nh S√≥i v√†o ƒë√™m ti·∫øp theo."))
            werewolf_ids.append(member.id)
        elif role == "Assassin Werewolf":
            await retry_api_call(lambda: wolf_channel.set_permissions(member, read_messages=True, send_messages=True))
            await retry_api_call(lambda: member.send("B·∫°n l√† S√≥i √Åm S√°t! V√†o ƒë√™m, b·∫°n c√≥ 1 c∆° h·ªôi ƒëo√°n ch·ª©c nƒÉng c·ªßa ng∆∞·ªùi ch∆°i ngo·∫°i tr·ª´ D√¢n L√†ng. ƒêo√°n ƒë√∫ng h·ªç ch·∫øt, sai b·∫°n ch·∫øt."))
            werewolf_ids.append(member.id)
        elif role == "Detective":
            await retry_api_call(lambda: member.send("B·∫°n l√† Th√°m T·ª≠! B·∫°n c√≥ 1 l·∫ßn duy nh·∫•t do th√°m xem 2 ng∆∞·ªùi ch∆°i c√πng phe hay kh√°c phe."))
        elif role == "Seer":
            await retry_api_call(lambda: member.send("B·∫°n l√† Ti√™n Tri! Ch·ªçn m·ªôt ng∆∞·ªùi ƒë·ªÉ bi·∫øt ng∆∞·ªùi ƒë√≥ Phe S√≥i hay Phe d√¢n. L∆∞u √Ω k·∫øt qu·∫£ c√≥ th·ªÉ b·ªã ·∫£nh h∆∞·ªüng b·ªüi Ng∆∞·ªùi S√≥i v√† Nh√† ·∫¢o Gi√°c."))
        elif role == "Guard":
            await retry_api_call(lambda: member.send("B·∫°n l√† B·∫£o V·ªá! Ch·ªçn m·ªôt ng∆∞·ªùi ƒë·ªÉ b·∫£o v·ªá m·ªói ƒë√™m, ng∆∞·ªùi ƒë√≥ s·∫Ω kh√¥ng ch·∫øt. Kh√¥ng th·ªÉ ch·ªçn 1 ng∆∞·ªùi 2 ƒë√™m li√™n ti·∫øp"))

    # Th√¥ng b√°o danh s√°ch s√≥i v√† Nh√† ·∫¢o Gi√°c trong wolf-chat
    werewolf_members = [game_state["member_cache"].get(wid) for wid in werewolf_ids if game_state["member_cache"].get(wid)]
    illusionist_member = game_state["member_cache"].get(illusionist_id) if illusionist_id else None

    embed = discord.Embed(
        title="Danh s√°ch S√≥i phe S√≥i",
        color=discord.Color.red()
    )

    if werewolf_members:
        werewolf_names = ", ".join([m.display_name for m in werewolf_members])
        embed.add_field(name="S√≥i", value=werewolf_names, inline=False)

    if illusionist_member:
        embed.add_field(name="·∫¢o Gi√°c", value=illusionist_member.display_name, inline=False)
        embed.add_field(name="L∆∞u √Ω", value="·∫¢o Gi√°c thu·ªôc phe S√≥i nh∆∞ng kh√¥ng th·ª©c d·∫≠y c√πng c√°c b·∫°n v√† kh√¥ng bi·∫øt ai l√† S√≥i", inline=False)

    if game_state["wolf_channel"]:
        await game_state["wolf_channel"].send(embed=embed)

    # Th√™m th√¥ng b√°o game b·∫Øt ƒë·∫ßu v·ªõi s·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i v√† vai tr√≤
    if game_state["text_channel"]:
        # T·∫°o chu·ªói danh s√°ch vai tr√≤
        role_list_str = ", ".join([f"{role}: {count}" for role, count in game_state["temp_roles"].items() if count > 0])
        
        start_embed = discord.Embed(
            title="üéÆ **Game Ma S√≥i DeWolfVie B·∫Øt ƒê·∫ßu!**",
            description=(
                f"**üîπ S·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i: {len(game_state['players'])}**\n"
                f"**üîπ C√°c vai tr√≤ trong game: {role_list_str}**\n"
                "**üîπ T·∫•t c·∫£ ng∆∞·ªùi ch∆°i ƒë√£ ƒë∆∞·ª£c g√°n vai tr√≤.**\n"
                "**üîπ K√™nh wolf-chat v√† dead-chat ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p.**\n"
                "**üîπ H√£y ki·ªÉm tra tin nh·∫Øn DM ƒë·ªÉ bi·∫øt vai tr√≤ c·ªßa b·∫°n.**\n"
                "**üîπ Chu·∫©n b·ªã cho pha ng√†y ƒë·∫ßu ti√™n!**"
            ),
            color=discord.Color.blue()
        )
        start_embed.set_image(url="https://cdn.discordapp.com/attachments/1365707789321633813/1372536545717780601/Banner_early_acccess_540x320.png?ex=682721c4&is=6825d044&hm=edce6a3e72304cce30f95e30fca1a3c480e7e8b0a340c95fd6d850541cafc7c6&")  # Th√™m URL c·ªßa ·∫£nh banner
        start_embed.set_footer(text="DeWolfVie ver 5.15")
        await game_state["text_channel"].send(embed=start_embed)
    await morning_phase(interaction, game_state)

# View cho h√†nh ƒë·ªông ƒë√™m (Ti√™n Tri, B·∫£o V·ªá, Th·ª£ SƒÉn, S√≥i, Ng∆∞·ªùi Kh√°m Ph√°)
class NightActionView(discord.ui.View):
    def __init__(self, role, players, game_state, timeout=40):
        super().__init__(timeout=timeout)
        self.role = role
        self.game_state = game_state
        self.add_item(NightActionSelect(role, players, game_state))

class NightActionSelect(discord.ui.Select):
    def __init__(self, role, players, game_state):
        options = [
            discord.SelectOption(label=p.display_name, value=str(p.id))
            for p in players
        ]
        options.append(discord.SelectOption(label="B·ªè qua", value="skip"))
        super().__init__(
            placeholder=f"Ch·ªçn ng∆∞·ªùi ƒë·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông ({role})",
            options=options,
            min_values=1,
            max_values=1
        )
        self.role = role
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id not in self.game_state["players"]:
            await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi ch∆°i!", ephemeral=True)
            return
        if self.game_state["phase"] != "night":
            await interaction.response.send_message("Ch∆∞a ph·∫£i pha ƒë√™m!", ephemeral=True)
            return
        if self.game_state["is_game_paused"]:
            await interaction.response.send_message("Game ƒëang t·∫°m d·ª´ng, kh√¥ng th·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông!", ephemeral=True)
            return
        if self.role == "Werewolf" and not isinstance(interaction.channel, discord.TextChannel):
            await interaction.response.send_message("Vui l√≤ng th·ª±c hi·ªán h√†nh ƒë·ªông trong wolf-chat!", ephemeral=True)
            return
        if self.role != "Werewolf" and not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Vui l√≤ng th·ª±c hi·ªán h√†nh ƒë·ªông qua DM!", ephemeral=True)
            return
        if self.values[0] == "skip":
            await interaction.response.send_message(f"B·∫°n ƒë√£ ch·ªçn b·ªè qua h√†nh ƒë·ªông {self.role}.", ephemeral=True)
            return
        user_id = interaction.user.id
        target_id = int(self.values[0])
        selected_id = int(self.values[0])
        if self.role == "Seer":
            self.game_state["seer_target_id"] = target_id
            target_role = self.game_state["players"][target_id]["role"]
            if target_role == "Illusionist":
                if self.game_state["illusionist_effect_active"]:
                    await interaction.response.send_message("Ng∆∞·ªùi b·∫°n soi thu·ªôc **Phe S√≥i**!", ephemeral=True)
                else:
                    await interaction.response.send_message("Ng∆∞·ªùi b·∫°n soi thu·ªôc **Phe D√¢n**!", ephemeral=True)
                self.game_state["illusionist_effect_night"] = self.game_state["night_count"] + 1
                self.game_state["illusionist_scanned"] = True
            else:
                if self.game_state["illusionist_effect_active"]:
                    if target_role in VILLAGER_ROLES or target_role == "Wolfman":
                        await interaction.response.send_message("Ng∆∞·ªùi b·∫°n soi thu·ªôc **Phe S√≥i**!", ephemeral=True)
                    else:
                        await interaction.response.send_message("Ng∆∞·ªùi b·∫°n soi thu·ªôc **Phe D√¢n**!", ephemeral=True)
                else:
                    if target_role in VILLAGER_ROLES or target_role == "Wolfman":
                        await interaction.response.send_message("Ng∆∞·ªùi b·∫°n soi thu·ªôc **Phe D√¢n**!", ephemeral=True)
                    else:
                        await interaction.response.send_message("Ng∆∞·ªùi b·∫°n soi thu·ªôc **Phe S√≥i**!", ephemeral=True)

        elif self.role == "Guard":
            if target_id == self.game_state["previous_protected_player_id"]:
                await interaction.response.send_message("B·∫°n kh√¥ng th·ªÉ b·∫£o v·ªá c√πng m·ªôt ng∆∞·ªùi hai ƒë√™m li√™n ti·∫øp!", ephemeral=True)
                return
            self.game_state["protected_player_id"] = target_id
            target = self.game_state["member_cache"].get(target_id)
            if target:
                await interaction.response.send_message(f"B·∫°n ƒë√£ ch·ªçn b·∫£o v·ªá {target.display_name}!", ephemeral=True)
        elif self.role == "Werewolf":
            self.game_state["werewolf_target_id"] = target_id
            target = self.game_state["member_cache"].get(target_id)
            if target:
                await interaction.response.send_message(f"B·∫ßy S√≥i ƒë√£ ch·ªçn gi·∫øt {target.display_name}!", ephemeral=True)
        elif self.role == "Hunter":
            self.game_state["hunter_target_id"] = target_id
            target = self.game_state["member_cache"].get(target_id)
            if target:
                await interaction.response.send_message(f"B·∫°n ƒë√£ ch·ªçn gi·∫øt {target.display_name}!", ephemeral=True)
        elif self.role == "Explorer":
            self.game_state["explorer_target_id"] = target_id
            target = self.game_state["member_cache"].get(target_id)
            if target:
                await interaction.response.send_message(f"B·∫°n ƒë√£ ch·ªçn kh√°m ph√° {target.display_name}!", ephemeral=True)
        elif self.role == "Demon Werewolf":
            if self.game_state["demon_werewolf_activated"] and not self.game_state["demon_werewolf_has_cursed"]:
                self.game_state["demon_werewolf_has_cursed"] = True
                self.game_state["demon_werewolf_cursed_player"] = target_id
                self.game_state["demon_werewolf_cursed_this_night"] = True
                target = self.game_state["member_cache"].get(target_id)
                if target:
                  await interaction.response.send_message(f"B·∫°n ƒë√£ nguy·ªÅn {target.display_name}!", ephemeral=True)
                  logger.info(f"S√≥i Qu·ª∑ {interaction.user.id} ƒë√£ nguy·ªÅn {target_id}")
            else:
                await interaction.response.send_message("B·∫°n ƒë√£ s·ª≠ d·ª•ng ch·ª©c nƒÉng nguy·ªÅn ho·∫∑c ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t!", ephemeral=True)
              
        for child in self.view.children:
            child.disabled = True
        await interaction.message.edit(view=self.view)

# View cho h√†nh ƒë·ªông c·ªßa S√≥i √Åm S√°t
class AssassinActionView(discord.ui.View):
    def __init__(self, game_state, assassin_id):
        super().__init__(timeout=40)
        self.game_state = game_state
        self.assassin_id = assassin_id
        self.add_item(PlayerSelectDropdown(self.game_state, self.assassin_id))
        self.add_item(RoleSelectDropdown(self.game_state, self.assassin_id))

class PlayerSelectDropdown(discord.ui.Select):
    def __init__(self, game_state, assassin_id):
        options = [
            discord.SelectOption(label=game_state["member_cache"][pid].display_name, value=str(pid))
            for pid, data in game_state["players"].items()
            if data["status"] in ["alive", "wounded"] and pid != assassin_id
        ]
        super().__init__(placeholder="Ch·ªçn ng∆∞·ªùi ch∆°i", options=options, min_values=1, max_values=1)
        self.game_state = game_state
        self.assassin_id = assassin_id

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.assassin_id:
            await interaction.response.send_message("Ch·ªâ S√≥i √Åm S√°t ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        self.game_state["assassin_werewolf_target_id"] = int(self.values[0])
        await interaction.response.defer()

class RoleSelectDropdown(discord.ui.Select):
    def __init__(self, game_state, assassin_id):
        # Lo·∫°i b·ªè "Villager" kh·ªèi danh s√°ch vai tr√≤ c√≥ th·ªÉ ch·ªçn
        options = [discord.SelectOption(label=role, value=role) for role in ROLES if role != "Villager"]
        super().__init__(placeholder="Ch·ªçn vai tr√≤", options=options, min_values=1, max_values=1)
        self.game_state = game_state
        self.assassin_id = assassin_id
      
    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.assassin_id:
            await interaction.response.send_message("Ch·ªâ S√≥i √Åm S√°t ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        self.game_state["assassin_werewolf_role_guess"] = self.values[0]
        self.game_state["assassin_werewolf_has_acted"] = True
        await interaction.response.send_message("B·∫°n ƒë√£ ch·ªçn xong. K·∫øt qu·∫£ s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω cu·ªëi pha ƒë√™m.", ephemeral=True)
        for child in self.view.children:
            child.disabled = True
        await interaction.message.edit(view=self.view)
      
# View cho Ph√π Th·ªßy
class WitchActionView(discord.ui.View):
    def __init__(self, alive_players, potential_targets, game_state, timeout):
        super().__init__(timeout=timeout)
        self.game_state = game_state
        self.alive_players = alive_players
        self.potential_targets = potential_targets
        if potential_targets:
            self.add_item(WitchSaveSelect(potential_targets, game_state))
        self.add_item(WitchKillSelect(alive_players, game_state))
        self.add_item(WitchSkipButton(game_state))

class WitchSaveSelect(discord.ui.Select):
    def __init__(self, potential_targets, game_state):
        options = [
            discord.SelectOption(label=member.display_name, value=str(member.id))
            for member in potential_targets
        ]
        super().__init__(
            placeholder="Ch·ªçn ng∆∞·ªùi ƒë·ªÉ c·ª©u",
            options=options,
            min_values=1,
            max_values=1
        )
        self.potential_targets = potential_targets
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id not in self.view.game_state["players"] or self.view.game_state["players"][interaction.user.id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi ch∆°i ho·∫∑c ƒë√£ ch·∫øt!", ephemeral=True)
            return
        if self.view.game_state["is_game_paused"]:
            await interaction.response.send_message("Game ƒëang t·∫°m d·ª´ng, kh√¥ng th·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông!", ephemeral=True)
            return
        if self.view.game_state["players"][interaction.user.id]["role"] != "Witch":
            await interaction.response.send_message("Ch·ªâ Ph√π Th·ªßy m·ªõi c√≥ th·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông n√†y!", ephemeral=True)
            return
        if self.view.game_state["phase"] != "night":
            await interaction.response.send_message("Ch∆∞a ph·∫£i pha ƒë√™m!", ephemeral=True)
            return
        if not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Vui l√≤ng th·ª±c hi·ªán h√†nh ƒë·ªông qua DM!", ephemeral=True)
            return
        if not self.view.game_state["witch_has_power"]:
            await interaction.response.send_message("B·∫°n ƒë√£ s·ª≠ d·ª•ng ch·ª©c nƒÉng!", ephemeral=True)
            return
        target_id = int(self.values[0])
        if target_id not in [m.id for m in self.potential_targets]:
            await interaction.response.send_message("M·ª•c ti√™u kh√¥ng h·ª£p l·ªá!", ephemeral=True)
            return
        self.view.game_state["witch_action_save"] = True
        self.view.game_state["witch_target_save_id"] = target_id
        target_member = next((m for m in self.potential_targets if m.id == target_id), None)
        if target_member:
            await interaction.response.send_message(f"B·∫°n ƒë√£ ch·ªçn c·ª©u {target_member.display_name}!", ephemeral=True)
        else:
            await interaction.response.send_message("B·∫°n ƒë√£ ch·ªçn c·ª©u m·ªôt ng∆∞·ªùi, nh∆∞ng kh√¥ng t√¨m th·∫•y m·ª•c ti√™u!", ephemeral=True)
        logger.info(f"Witch chose to save player: target_id={target_id}, target_name={target_member.display_name if target_member else 'Unknown'}, interaction_id={interaction.id}")
        for child in self.view.children:
            child.disabled = True
        try:
            await interaction.message.edit(view=self.view)
        except discord.errors.NotFound:
            logger.warning(f"Message not found when editing WitchSaveSelect view for interaction_id={interaction.id}")

class WitchKillSelect(discord.ui.Select):
    def __init__(self, alive_players, game_state):
        options = [
            discord.SelectOption(label=member.display_name, value=str(member.id))
            for member in alive_players
        ]
        super().__init__(
            placeholder="Ch·ªçn ng∆∞·ªùi ƒë·ªÉ gi·∫øt",
            options=options,
            min_values=1,
            max_values=1
        )
        self.alive_players = alive_players
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id not in self.view.game_state["players"] or self.view.game_state["players"][interaction.user.id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi ch∆°i ho·∫∑c ƒë√£ ch·∫øt!", ephemeral=True)
            return
        if self.view.game_state["is_game_paused"]:
            await interaction.response.send_message("Game ƒëang t·∫°m d·ª´ng, kh√¥ng th·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông!", ephemeral=True)
            return
        if self.view.game_state["players"][interaction.user.id]["role"] != "Witch":
            await interaction.response.send_message("Ch·ªâ Ph√π Th·ªßy m·ªõi c√≥ th·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông n√†y!", ephemeral=True)
            return
        if self.view.game_state["phase"] != "night":
            await interaction.response.send_message("Ch∆∞a ph·∫£i pha ƒë√™m!", ephemeral=True)
            return
        if not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Vui l√≤ng th·ª±c hi·ªán h√†nh ƒë·ªông qua DM!", ephemeral=True)
            return
        if not self.view.game_state["witch_has_power"]:
            await interaction.response.send_message("B·∫°n ƒë√£ s·ª≠ d·ª•ng ch·ª©c nƒÉng!", ephemeral=True)
            return
        target_id = int(self.values[0])
        if target_id not in self.view.game_state["players"] or self.view.game_state["players"][target_id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("M·ª•c ti√™u kh√¥ng h·ª£p l·ªá!", ephemeral=True)
            return
        self.view.game_state["witch_action_kill"] = True
        self.view.game_state["witch_target_kill_id"] = target_id
        target_member = next((m for m in self.alive_players if m.id == target_id), None)
        if target_member:
            await interaction.response.send_message(f"B·∫°n ƒë√£ ch·ªçn gi·∫øt {target_member.display_name}!", ephemeral=True)
        else:
            await interaction.response.send_message("B·∫°n ƒë√£ ch·ªçn gi·∫øt m·ªôt ng∆∞·ªùi, nh∆∞ng kh√¥ng t√¨m th·∫•y m·ª•c ti√™u!", ephemeral=True)
        logger.info(f"Witch chose to kill player: target_id={target_id}, target_name={target_member.display_name if target_member else 'Unknown'}, interaction_id={interaction.id}")
        for child in self.view.children:
            child.disabled = True
        try:
            await interaction.message.edit(view=self.view)
        except discord.errors.NotFound:
            logger.warning(f"Message not found when editing WitchKillSelect view for interaction_id={interaction.id}")

class WitchSkipButton(discord.ui.Button):
    def __init__(self, game_state):
        super().__init__(label="B·ªè qua", style=discord.ButtonStyle.grey)
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id not in self.view.game_state["players"] or self.view.game_state["players"][interaction.user.id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi ch∆°i ho·∫∑c ƒë√£ ch·∫øt!", ephemeral=True)
            return
        if self.view.game_state["is_game_paused"]:
            await interaction.response.send_message("Game ƒëang t·∫°m d·ª´ng, kh√¥ng th·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông!", ephemeral=True)
            return
        if self.view.game_state["players"][interaction.user.id]["role"] != "Witch":
            await interaction.response.send_message("Ch·ªâ Ph√π Th·ªßy m·ªõi c√≥ th·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông n√†y!", ephemeral=True)
            return
        if self.view.game_state["phase"] != "night":
            await interaction.response.send_message("Ch∆∞a ph·∫£i pha ƒë√™m!", ephemeral=True)
            return
        if not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Vui l√≤ng th·ª±c hi·ªán h√†nh ƒë·ªông qua DM!", ephemeral=True)
            return
        self.view.game_state["witch_action_save"] = False
        self.view.game_state["witch_action_kill"] = False
        self.view.game_state["witch_target_save_id"] = None
        self.view.game_state["witch_target_kill_id"] = None
        await interaction.response.send_message("B·∫°n ƒë√£ ch·ªçn b·ªè qua h√†nh ƒë·ªông ƒë√™m nay.", ephemeral=True)
        logger.info(f"Witch skipped action: interaction_id={interaction.id}")
        for child in self.view.children:
            child.disabled = True
        try:
            await interaction.message.edit(view=self.view)
        except discord.errors.NotFound:
            logger.warning(f"Message not found when editing WitchSkipButton view for interaction_id={interaction.id}")

# View cho b·ªè phi·∫øu ban ng√†y
import asyncio
import discord

async def morning_phase(interaction: discord.Interaction, game_state):
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("morning_phase: Game stopped or paused, skipping")
        return
    game_state["phase"] = "morning"
    main_channel = bot.get_channel(game_state["voice_channel_id"])
  
    text_channel = game_state.get("text_channel")
    if not text_channel:
        logger.error("morning_phase: text_channel is None, cannot proceed with morning phase")
        return
        logger.info(f"ƒê√£ kh√¥i ph·ª•c text_channel: ID={text_channel.id}, Name={text_channel.name}")
    voice_channel = bot.get_channel(game_state["voice_channel_id"])
    villager_role = interaction.guild.get_role(game_state["villager_role_id"])

    # Kh√¥i ph·ª•c quy·ªÅn cho k√™nh text: cho ph√©p chat cho @everyone v√† vai tr√≤ D√¢n L√†ng
    if text_channel and villager_role:
        try:
            await text_channel.set_permissions(interaction.guild.default_role, send_messages=True)
            await text_channel.set_permissions(villager_role, send_messages=True)
            logger.info(f"Set text_channel permissions: default_role send_messages=True, villager_role send_messages=True")
        except Exception as e:
            logger.error(f"Failed to restore text channel permissions: {str(e)}")
            await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ kh√¥i ph·ª•c chat trong k√™nh text: {str(e)}")

    # Kh√¥i ph·ª•c quy·ªÅn chat cho t·ª´ng ng∆∞·ªùi ch∆°i trong k√™nh text
    #for user_id in game_state["players"]:
        #if game_state["players"][user_id]["status"] in ["alive", "wounded"]:
            #member = game_state["member_cache"].get(user_id)
            #if member:
                #try:
                    #await text_channel.set_permissions(member, send_messages=True)
                    #logger.info(f"Set text_channel permissions for player {member.display_name}: send_messages=True")
                #except Exception as e:
                    #logger.error(f"Failed to restore text channel permissions for player ID={member.id}: {str(e)}")

    # Di chuy·ªÉn t·∫•t c·∫£ ng∆∞·ªùi ch∆°i v·ªÅ k√™nh ch√≠nh
    tasks = []
    for user_id in game_state["players"]:
        member = game_state["member_cache"].get(user_id)
        if member:  # B·ªè ƒëi·ªÅu ki·ªán ki·ªÉm tra status ƒë·ªÉ di chuy·ªÉn t·∫•t c·∫£
            tasks.append(member.move_to(main_channel))
    await asyncio.gather(*tasks)
    
    # ƒê·∫£m b·∫£o ng∆∞·ªùi ch∆°i ƒë√£ ch·∫øt b·ªã mute
    #mute_tasks = []
    #for user_id in game_state["players"]:
        #if game_state["players"][user_id]["status"] == "dead":
            #member = game_state["member_cache"].get(user_id)
            #if member and member.voice:  # Ki·ªÉm tra xem ng∆∞·ªùi ch∆°i c√≥ trong voice kh√¥ng
                #mute_tasks.append(member.edit(mute=True))
    #await asyncio.gather(*mute_tasks)

    # X·ª≠ l√Ω ng∆∞·ªùi ch∆°i b·ªã nguy·ªÅn t·ª´ ƒë√™m tr∆∞·ªõc
    if game_state["demon_werewolf_cursed_player"]:
        cursed_id = game_state["demon_werewolf_cursed_player"]
        if cursed_id in game_state["players"] and game_state["players"][cursed_id]["status"] in ["alive", "wounded"]:
            game_state["players"][cursed_id]["role"] = "Werewolf"
            member = game_state["member_cache"].get(cursed_id)
            if member:
                await retry_api_call(lambda: member.send("B·∫°n ƒë√£ b·ªã nguy·ªÅn v√† tr·ªü th√†nh S√≥i! B·∫°n s·∫Ω th·ª©c d·∫≠y c√πng b·∫ßy S√≥i v√† m·∫•t ch·ª©c nƒÉng c≈©."))
                await retry_api_call(lambda: game_state["wolf_channel"].set_permissions(member, read_messages=True, send_messages=True))
        #game_state["demon_werewolf_cursed_player"] = None  # Reset sau khi x·ª≠ l√Ω

    embed = discord.Embed(
        title="‚òÄÔ∏è B√¨nh Minh",
        description="M·ªçi ng∆∞·ªùi th·ª©c d·∫≠y! Th·∫£o lu·∫≠n trong 120 gi√¢y tr∆∞·ªõc khi b·ªè phi·∫øu (30 gi√¢y n·∫øu l√† ng√†y ƒë·∫ßu ti√™n).",
        color=discord.Color.gold()
    )
    embed.set_image(url=GIF_URLS["morning"])
    await text_channel.send(embed=embed)
    await play_audio(AUDIO_FILES["morning"], game_state["voice_connection"])
    discussion_time = 30 if game_state["is_first_day"] else 120
    await countdown(text_channel, discussion_time, "th·∫£o lu·∫≠n", game_state)
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused after discussion, skipping voting phase")
        return
    if game_state["is_first_day"]:
        game_state["is_first_day"] = False
        await night_phase(interaction, game_state)
        return
    alive_players = await get_alive_players(interaction, game_state)
    vote_embed = discord.Embed(
        title="üó≥Ô∏è Pha B·ªè Phi·∫øu",
        description="Ch·ªçn ng∆∞·ªùi ƒë·ªÉ lo·∫°i trong 45 gi√¢y.",
        color=discord.Color.gold()
    )
    vote_embed.set_image(url=GIF_URLS["vote"])
    vote_message = await text_channel.send(embed=vote_embed, view=VoteView(alive_players, game_state, 45))
    
    # Ghim tin nh·∫Øn vote khi b·∫Øt ƒë·∫ßu voting phase
    await vote_message.pin()
    
    await play_audio(AUDIO_FILES["vote"], game_state["voice_connection"])
    game_state["phase"] = "voting"
    
    # Ch·ªù 15 gi√¢y v√† g·ª≠i nh·∫Øc nh·ªü ƒë·∫ßu ti√™n
    await asyncio.sleep(15)
    if game_state["is_game_running"] and not game_state["is_game_paused"]:
        await vote_message.reply("üó≥Ô∏è **Nh·∫Øc nh·ªü:** C√≤n th·ªùi gian ƒë·ªÉ b·ªè phi·∫øu! H√£y ch·ªçn ng∆∞·ªùi ƒë·ªÉ lo·∫°i.")
    
    # Ch·ªù th√™m 15 gi√¢y (t·ªïng 30 gi√¢y), g·ª≠i nh·∫Øc nh·ªü th·ª© hai v√† hi·ªÉn th·ªã phi·∫øu hi·ªán t·∫°i
    await asyncio.sleep(15)
    if game_state["is_game_running"] and not game_state["is_game_paused"]:
        await vote_message.reply("üó≥Ô∏è **Nh·∫Øc nh·ªü:** C√≤n th·ªùi gian ƒë·ªÉ b·ªè phi·∫øu! H√£y ch·ªçn ng∆∞·ªùi ƒë·ªÉ lo·∫°i.")
        await display_current_votes(interaction, game_state)
    
    # ƒê·∫øm ng∆∞·ª£c 15 gi√¢y cu·ªëi, v·ªõi ƒë·∫øm ng∆∞·ª£c 5 gi√¢y cu·ªëi ƒë∆∞·ª£c hi·ªÉn th·ªã
    await countdown(game_state["text_channel"], 15, "b·ªè phi·∫øu", game_state)
    
    if game_state["is_game_running"] and not game_state["is_game_paused"]:
        await display_final_votes(interaction, game_state)
    
        # H√†m ƒë·∫øm vote (gi·ªØ nguy√™n logic c·ªßa b·∫°n)
        vote_counts = {}
        skip_votes = 0
        for voter_id in game_state["players"]:
            if game_state["players"][voter_id]["status"] in ["alive", "wounded"]:
                if game_state["players"][voter_id]["role"] in ["Villager", "Tough Guy", "Illusionist"]:
                    if not game_state["math_results"].get(voter_id, False):
                        continue
                target_id = game_state["votes"].get(voter_id, "skip")
                if target_id == "skip":
                    skip_votes += 1
                else:
                    vote_counts[target_id] = vote_counts.get(target_id, 0) + 1
    
        if vote_counts or skip_votes > 0:
            player_vote_counts = {k: v for k, v in vote_counts.items() if k != "skip"}
            if player_vote_counts:
                max_votes = max(player_vote_counts.values())
                candidates = [k for k, v in player_vote_counts.items() if v == max_votes]
                if len(candidates) == 1 and max_votes > skip_votes:
                    eliminated_id = candidates[0]
                    eliminated_member = game_state["member_cache"].get(eliminated_id)
                    if (eliminated_member and eliminated_id in game_state["players"] and
                        game_state["players"][eliminated_id]["status"] in ["alive", "wounded"]):
                        game_state["players"][eliminated_id]["status"] = "dead"
                        await handle_player_death(interaction, eliminated_member, eliminated_id, game_state)
                        hang_embed = discord.Embed(
                            title="‚ö∞Ô∏è K·∫øt Qu·∫£ B·ªè Phi·∫øu",
                            description=f"{eliminated_member.display_name} ƒë√£ b·ªã ng·ªìi gh·∫ø ƒëi·ªán v·ªõi {max_votes} phi·∫øu!)",
                            color=discord.Color.red()
                        )
                        hang_embed.set_image(url=GIF_URLS["hang"])
                        await text_channel.send(embed=hang_embed)
                        await play_audio(AUDIO_FILES["hang"], game_state["voice_connection"])
                        game_logs[interaction.guild.id].append(f"{eliminated_member.display_name} b·ªã ng·ªìi gh·∫ø ƒëi·ªán v·ªõi {max_votes} phi·∫øu.")
                elif len(candidates) > 1:
                    await text_channel.send("C√≥ ƒë·ªìng phi·∫øu gi·ªØa nhi·ªÅu ng∆∞·ªùi, kh√¥ng ai b·ªã lo·∫°i!")
                else:
                    await text_channel.send(f"Kh√¥ng ai b·ªã lo·∫°i! S·ªë phi·∫øu 'b·ªè qua' cao h∆°n ho·∫∑c b·∫±ng s·ªë phi·∫øu cao nh·∫•t cho ng∆∞·ªùi ch∆°i ({max_votes}).")
            else:
                await text_channel.send(f"Kh√¥ng ai b·ªã lo·∫°i! T·∫•t c·∫£ phi·∫øu ƒë·ªÅu ch·ªçn 'b·ªè qua' ho·∫∑c d·ªët to√°n).")
        else:
            await text_channel.send("Kh√¥ng ai b·ªã lo·∫°i v√¨ kh√¥ng c√≥ phi·∫øu b·∫ßu n√†o!")
    
    # B·ªè ghim tin nh·∫Øn vote khi k·∫øt th√∫c voting phase
    await vote_message.unpin()
    
    game_state["votes"].clear()
    if await check_win_condition(interaction, game_state):
        return
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused after voting, skipping night phase")
        return
    # Th√™m 10 gi√¢y ch·ªù tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu pha ƒë√™m
    await text_channel.send("Pha b·ªè phi·∫øu ƒë√£ k·∫øt th√∫c. Chu·∫©n b·ªã chuy·ªÉn sang pha ƒë√™m trong 10 gi√¢y...")
    await play_audio(AUDIO_FILES["night"], game_state["voice_connection"])
    await countdown(game_state["text_channel"], 10, "chu·∫©n b·ªã pha ƒë√™m", game_state)
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused during pre-night countdown, skipping night phase")
        return
    await night_phase(interaction, game_state)

class VoteView(discord.ui.View):
    def __init__(self, alive_players, game_state, timeout):
        super().__init__(timeout=timeout)
        self.alive_players = alive_players
        self.game_state = game_state
        self.add_item(VoteSelect(alive_players, game_state))
        self.add_item(SkipButton(game_state))

class VoteSelect(discord.ui.Select):
    def __init__(self, alive_players, game_state):
        options = [
            discord.SelectOption(label=member.display_name, value=str(member.id))
            for member in alive_players
        ]
        super().__init__(placeholder="Ch·ªçn ng∆∞·ªùi ƒë·ªÉ lo·∫°i", options=options, min_values=1, max_values=1)
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        # Ki·ªÉm tra ƒëi·ªÅu ki·ªán c∆° b·∫£n
        if interaction.user.id not in self.game_state["players"] or self.game_state["players"][interaction.user.id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("B·∫°n kh√¥ng th·ªÉ b·ªè phi·∫øu!", ephemeral=True)
            return
        if self.game_state["phase"] != "voting":
            await interaction.response.send_message("Ch∆∞a ph·∫£i pha b·ªè phi·∫øu!", ephemeral=True)
            return
        if self.game_state["is_game_paused"]:
            await interaction.response.send_message("Game ƒëang t·∫°m d·ª´ng, kh√¥ng th·ªÉ b·ªè phi·∫øu!", ephemeral=True)
            return

        # Ghi nh·∫≠n phi·∫øu b·∫ßu
        target_id = int(self.values[0])
        self.game_state["votes"][interaction.user.id] = target_id
        target_member = next((m for m in self.options if m.value == self.values[0]), None)
        target_name = target_member.label if target_member else "Unknown"

        # Ki·ªÉm tra ƒëi·ªÅu ki·ªán ƒë·ªÉ hi·ªÉn th·ªã th√¥ng b√°o ph√π h·ª£p
        player_data = self.game_state["players"][interaction.user.id]
        # Ng∆∞·ªùi ch∆°i ƒë·ªß ƒëi·ªÅu ki·ªán n·∫øu: vai tr√≤ kh√¥ng y√™u c·∫ßu to√°n HO·∫∂C ƒë√£ gi·∫£i to√°n ƒë√∫ng
        if player_data["role"] not in NO_NIGHT_ACTION_ROLES or (interaction.user.id in self.game_state["math_results"] and self.game_state["math_results"][interaction.user.id]):
            await interaction.response.send_message(f"B·∫°n ƒë√£ b·ªè phi·∫øu cho {target_name}!", ephemeral=True)
        else:
            await interaction.response.send_message(f"B·∫°n ƒë√£ b·ªè phi·∫øu cho {target_name}, nh∆∞ng vote c·ªßa b·∫°n kh√¥ng ƒë∆∞·ª£c t√≠nh do kh√¥ng gi·∫£i ƒë√∫ng b√†i to√°n!", ephemeral=True)

class SkipButton(discord.ui.Button):
    def __init__(self, game_state):
        super().__init__(label="B·ªè qua", style=discord.ButtonStyle.grey)
        self.game_state = game_state

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id not in self.game_state["players"] or self.game_state["players"][interaction.user.id]["status"] not in ["alive", "wounded"]:
            await interaction.response.send_message("B·∫°n kh√¥ng th·ªÉ b·ªè phi·∫øu!", ephemeral=True)
            return
        if self.game_state["phase"] != "voting":
            await interaction.response.send_message("Ch∆∞a ph·∫£i pha b·ªè phi·∫øu!", ephemeral=True)
            return
        if self.game_state["is_game_paused"]:
            await interaction.response.send_message("Game ƒëang t·∫°m d·ª´ng, kh√¥ng th·ªÉ b·ªè phi·∫øu!", ephemeral=True)
            return
        if interaction.user.id in self.game_state["math_results"] and not self.game_state["math_results"][interaction.user.id]:
            await interaction.response.send_message("B·∫°n kh√¥ng c√≥ quy·ªÅn b·ªè phi·∫øu do tr·∫£ l·ªùi sai b√†i to√°n ƒë√™m qua!", ephemeral=True)
            return
        self.game_state["votes"][interaction.user.id] = "skip"
        await interaction.response.send_message("B·∫°n ƒë√£ ch·ªçn b·ªè qua!", ephemeral=True)

async def handle_player_death(interaction: discord.Interaction, member, user_id, game_state):
    guild = bot.get_guild(game_state["guild_id"])
    dead_role = guild.get_role(game_state["dead_role_id"])
    villager_role = guild.get_role(game_state["villager_role_id"])
    wolf_channel = game_state["wolf_channel"]
    dead_channel = game_state["dead_channel"]
    voice_channel = bot.get_channel(game_state["voice_channel_id"])

    # G√°n vai tr√≤ Ng∆∞·ªùi Ch·∫øt v√† x√≥a vai tr√≤ D√¢n L√†ng
    try:
        if villager_role in member.roles:
            await member.remove_roles(villager_role)
        await member.add_roles(dead_role)
        logger.info(f"Assigned Dead role to member: ID={member.id}, Name={member.display_name}")
    except Exception as e:
        logger.error(f"Failed to assign Dead role to member ID={member.id}: {str(e)}")
        await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ g√°n vai tr√≤ Ng∆∞·ªùi Ch·∫øt cho {member.display_name}.")

    # C·∫•p quy·ªÅn truy c·∫≠p k√™nh dead-chat
    try:
        await dead_channel.set_permissions(member, read_messages=True, send_messages=True)
        await dead_channel.send(f"{member.mention} ƒë√£ tham gia k√™nh ng∆∞·ªùi ch·∫øt! Ch√†o m·ª´ng ƒë·∫øn v·ªõi nghƒ©a ƒë·ªãa!")
        logger.info(f"Granted access to dead-chat for member: ID={member.id}, Name={member.display_name}")
    except Exception as e:
        logger.error(f"Failed to grant access to dead-chat for member ID={member.id}: {str(e)}")
        await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ c·∫•p quy·ªÅn dead-chat cho {member.display_name}.")

    # Thu h·ªìi quy·ªÅn truy c·∫≠p wolf-chat n·∫øu l√† s√≥i
    player_role = game_state["players"][user_id]["role"]
    if player_role in WEREWOLF_ROLES:
        try:
            await wolf_channel.set_permissions(member, read_messages=False, send_messages=False)
            logger.info(f"Revoked access to wolf-chat for dead werewolf: ID={member.id}, Name={member.display_name}")
        except Exception as e:
            logger.error(f"Failed to revoke access to wolf-chat for member ID={member.id}: {str(e)}")
            await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ thu h·ªìi quy·ªÅn wolf-chat cho {member.display_name}.")

    # C·∫≠p nh·∫≠t tr·∫°ng th√°i ng∆∞·ªùi ch∆°i
    game_state["players"][user_id]["status"] = "dead"

async def night_phase(interaction: discord.Interaction, game_state):
  
    if not game_state["is_game_running"]:
        logger.info("night_phase: Game is not running, skipping night phase")
        return
    if game_state["is_game_paused"]:
        logger.info("night_phase: Game is paused, skipping night phase")
        return
    if game_state["demon_werewolf_cursed_player"] is not None:
        cursed_id = game_state["demon_werewolf_cursed_player"]
        if cursed_id in game_state["players"] and game_state["players"][cursed_id]["status"] in ["alive", "wounded"]:
            game_state["players"][cursed_id]["role"] = "Werewolf"
            member = game_state["member_cache"].get(cursed_id)
            if member:
                await retry_api_call(lambda: member.send("B·∫°n ƒë√£ b·ªã nguy·ªÅn v√† tr·ªü th√†nh S√≥i!"))
                await retry_api_call(lambda: game_state["wolf_channel"].set_permissions(member, read_messages=True, send_messages=True))
            game_state["demon_werewolf_cursed_player"] = None
            logger.info(f"Player {cursed_id} transformed into Werewolf")

    game_state["phase"] = "night"
    game_state["night_count"] += 1
    guild = interaction.guild
    main_channel = bot.get_channel(game_state["voice_channel_id"])
  
    text_channel = game_state["text_channel"]
    voice_channel = bot.get_channel(game_state["voice_channel_id"])
    villager_role = interaction.guild.get_role(game_state["villager_role_id"])

    # Thi·∫øt l·∫≠p quy·ªÅn cho k√™nh text: c·∫•m chat cho @everyone v√† vai tr√≤ D√¢n L√†ng
    if text_channel and villager_role:
        try:
            await text_channel.set_permissions(interaction.guild.default_role, send_messages=False)  # S·ª≠a l·ªói defaxult_role
            await text_channel.set_permissions(villager_role, send_messages=False)
            logger.info(f"Set text_channel permissions: default_role send_messages=False, villager_role send_messages=False")
        except Exception as e:
            logger.error(f"Failed to set text channel permissions: {str(e)}")
            await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ ch·∫∑n chat trong k√™nh text: {str(e)}")

    # C·∫•m chat cho t·ª´ng ng∆∞·ªùi ch∆°i c√≤n s·ªëng trong k√™nh text
    #for user_id in game_state["players"]:
        #if game_state["players"][user_id]["status"] in ["alive", "wounded"]:
            #member = game_state["member_cache"].get(user_id)
            #if member:
                #try:
                    #await text_channel.set_permissions(member, send_messages=False)
                    #logger.info(f"Set text_channel permissions for player {member.display_name}: send_messages=False")
                #except Exception as e:
                    #logger.error(f"Failed to set text channel permissions for player ID={member.id}: {str(e)}")

    # Di chuy·ªÉn ng∆∞·ªùi ch∆°i v√†o k√™nh ri√™ng
    tasks = []
    alive_players = await get_alive_players(interaction, game_state)
    for member in alive_players:
        if member.id in game_state["player_channels"]:
            temp_channel = game_state["player_channels"][member.id]
            tasks.append(member.move_to(temp_channel))
    await asyncio.gather(*tasks)
    
    
    night_embed = discord.Embed(
        title="üåô Pha ƒê√™m B·∫Øt ƒê·∫ßu",
        description="M·ªçi ng∆∞·ªùi ƒë√£ b·ªã c√¥ l·∫≠p ƒë·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông ƒë√™m!",
        color=discord.Color.dark_blue()
    )
    night_embed.set_image(url=GIF_URLS["night"])
    await game_state["text_channel"].send(embed=night_embed)

    alive_players = await get_alive_players(interaction, game_state)
    if not alive_players:
        logger.error("No alive players found for night phase")
        await text_channel.send("L·ªói: Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i c√≤n s·ªëng ƒë·ªÉ ti·∫øp t·ª•c pha ƒë√™m!")
        return
    game_state["werewolf_target_id"] = None
    game_state["witch_target_save_id"] = None
    game_state["witch_target_kill_id"] = None
    game_state["witch_action_save"] = False
    game_state["witch_action_kill"] = False
    game_state["hunter_target_id"] = None
    game_state["explorer_target_id"] = None
    game_state["math_problems"] = {}
    game_state["math_results"] = {}
    game_state["demon_werewolf_cursed_this_night"] = False    
    ###game_state["demon_werewolf_has_cursed"] = False  # Th√™m khai b√°o n√†y

    if game_state["illusionist_scanned"] and game_state["night_count"] == game_state["illusionist_effect_night"]:
        game_state["illusionist_effect_active"] = True
    else:
        game_state["illusionist_effect_active"] = False

    # Ki·ªÉm tra n·∫øu c√≥ S√≥i ch·∫øt ƒë·ªÉ k√≠ch ho·∫°t S√≥i Qu·ª∑
    werewolf_dead = any(data["role"] in WEREWOLF_ROLES and data["status"] == "dead" for data in game_state["players"].values())
    if werewolf_dead and not game_state["demon_werewolf_activated"]:
        game_state["demon_werewolf_activated"] = True
        for user_id, data in game_state["players"].items():
            if data["role"] == "Demon Werewolf" and data["status"] in ["alive", "wounded"]:
                member = game_state["member_cache"].get(user_id)
                if member:
                    await retry_api_call(lambda: member.send("M·ªôt S√≥i ƒë√£ ch·∫øt! B·∫°n c√≥ th·ªÉ nguy·ªÅn m·ªôt ng∆∞·ªùi ch∆°i trong ƒë√™m n√†y ho·∫∑c c√°c ƒë√™m ti·∫øp theo."))

    # G·ª≠i th√¥ng b√°o chung cho phe S√≥i trong wolf-chat
    if game_state["wolf_channel"]:
        await retry_api_call(lambda: game_state["wolf_channel"].send(
            "Phe S√≥i th·ª©c d·∫≠y! Ch·ªçn ng∆∞·ªùi ƒë·ªÉ gi·∫øt trong 40 gi√¢y:",
            view=NightActionView("Werewolf", alive_players, game_state, 40)
        ))

    # X·ª≠ l√Ω h√†nh ƒë·ªông ƒë√™m cho c√°c vai tr√≤ kh√°c
    for user_id, data in game_state["players"].items():
        if data["status"] not in ["alive", "wounded"] or data["role"] in NO_NIGHT_ACTION_ROLES:
            continue
        member = game_state["member_cache"].get(user_id)
        if not member or member not in alive_players:
            continue
        if data["role"] == "Seer":
            await retry_api_call(lambda: member.send("B·∫°n l√† Ti√™n Tri! Ch·ªçn ng∆∞·ªùi ƒë·ªÉ soi trong 40 gi√¢y:", view=NightActionView("Seer", alive_players, game_state, 40)))
        elif data["role"] == "Guard":
            await retry_api_call(lambda: member.send("B·∫°n l√† B·∫£o V·ªá! Ch·ªçn ng∆∞·ªùi ƒë·ªÉ b·∫£o v·ªá trong 40 gi√¢y:", view=NightActionView("Guard", alive_players, game_state, 40)))
        elif data["role"] == "Hunter" and game_state["hunter_has_power"]:
            await retry_api_call(lambda: member.send("B·∫°n l√† Th·ª£ SƒÉn! Ch·ªçn ng∆∞·ªùi ƒë·ªÉ gi·∫øt trong 40 gi√¢y (ch·ªâ 1 l·∫ßn):", view=NightActionView("Hunter", alive_players, game_state, 40)))
        elif data["role"] == "Explorer" and game_state["night_count"] >= 2 and game_state.get("explorer_can_act", False):
            await retry_api_call(lambda: member.send("B·∫°n l√† Ng∆∞·ªùi Kh√°m Ph√°! Ch·ªçn ng∆∞·ªùi ƒë·ªÉ gi·∫øt trong 40 gi√¢y:", view=NightActionView("Explorer", alive_players, game_state, 40)))
        elif data["role"] == "Demon Werewolf":
            if game_state["demon_werewolf_activated"] and not game_state["demon_werewolf_has_cursed"] and game_state["demon_werewolf_cursed_player"]==None:
                try:
                    await retry_api_call(lambda: member.send(
                        "B·∫°n l√† S√≥i Qu·ª∑! Ch·ªçn ng∆∞·ªùi ƒë·ªÉ nguy·ªÅn trong 40 gi√¢y (ch·ªâ 1 l·∫ßn duy nh·∫•t):",
                        view=NightActionView("Demon Werewolf", alive_players, game_state, 40)
                    ))
                    logger.info(f"ƒê√£ g·ª≠i l·ª±a ch·ªçn nguy·ªÅn cho S√≥i Qu·ª∑: {member.id}")
                except discord.errors.Forbidden:
                    logger.error(f"Kh√¥ng c√≥ quy·ªÅn g·ª≠i DM cho S√≥i Qu·ª∑: {member.id}")
                except Exception as e:
                    logger.error(f"L·ªói g·ª≠i view cho S√≥i Qu·ª∑ {member.id}: {str(e)}")
            elif game_state["demon_werewolf_has_cursed"]:
                try:
                    await retry_api_call(lambda: member.send("B·∫°n ƒë√£ nguy·ªÅn m·ªôt ng∆∞·ªùi tr∆∞·ªõc ƒë√≥! Ch·ª©c nƒÉng nguy·ªÅn c·ªßa b·∫°n ƒë√£ b·ªã v√¥ hi·ªáu h√≥a."))
                    logger.info(f"Th√¥ng b√°o S√≥i Qu·ª∑ ƒë√£ m·∫•t ch·ª©c nƒÉng nguy·ªÅn: {member.id}")
                except discord.errors.Forbidden:
                    logger.error(f"Kh√¥ng c√≥ quy·ªÅn g·ª≠i DM cho S√≥i Qu·ª∑: {member.id}")
                except Exception as e:
                    logger.error(f"L·ªói g·ª≠i th√¥ng b√°o cho S√≥i Qu·ª∑ {member.id}: {str(e)}")
    
    # X·ª≠ l√Ω h√†nh ƒë·ªông c·ªßa S√≥i √Åm S√°t
    for user_id, data in game_state["players"].items():
        if data["role"] == "Assassin Werewolf" and data["status"] in ["alive", "wounded"] and not game_state["assassin_werewolf_has_acted"]:
            assassin_member = game_state["member_cache"].get(user_id)
            if assassin_member:
                view = AssassinActionView(game_state, user_id)
                await assassin_member.send("B·∫°n l√† S√≥i √Åm S√°t. Ch·ªçn m·ªôt ng∆∞·ªùi ch∆°i v√† ƒëo√°n vai tr√≤ c·ªßa h·ªç:", view=view)
    
    # Th√™m h√†nh ƒë·ªông cho Detective
    detective_id = next((uid for uid, data in game_state["players"].items() if data["role"] == "Detective"), None)
    if detective_id and not game_state["detective_has_used_power"]:
        detective_member = game_state["member_cache"].get(detective_id)
        if detective_member:
            alive_players = await get_alive_players(interaction, game_state)
            view = DetectiveSelectView(detective_id, alive_players, game_state)
            await detective_member.send("Ch·ªçn hai ng∆∞·ªùi ch∆°i ƒë·ªÉ ki·ªÉm tra phe:", view=view)
                  
    # G·ª≠i b√†i to√°n cho c√°c vai kh√¥ng c√≥ h√†nh ƒë·ªông ƒë√™m
    for user_id, data in game_state["players"].items():
        if data["status"] not in ["alive", "wounded"] or data["role"] not in ["Villager", "Tough Guy", "Illusionist"]:
            continue
        member = game_state["member_cache"].get(user_id)
        if not member or member not in alive_players:
            continue
        try:
            math_problem = await generate_math_problem(game_state["math_problems"])
            game_state["math_problems"][user_id] = math_problem
            options_str = "\n".join([f"{i+1}. {opt}" for i, opt in enumerate(math_problem["options"])])
            await retry_api_call(lambda: member.send(
                f"B·∫°n ph·∫£i gi·∫£i b√†i to√°n sau ƒë·ªÉ ƒë∆∞·ª£c quy·ªÅn b·ªè phi·∫øu v√†o ban ng√†y: **{math_problem['problem']}**.\n"
                f"Ch·ªçn ƒë√°p √°n ƒë√∫ng trong 40 gi√¢y:\n{options_str}",
                view=NightMathView(user_id, math_problem["options"], math_problem["answer"], game_state)
            ))
        except Exception as e:
            logger.error(f"Failed to generate math problem for user_id={user_id}: {str(e)}")
            await retry_api_call(lambda: member.send("L·ªói: Kh√¥ng th·ªÉ t·∫°o b√†i to√°n. B·∫°n ƒë∆∞·ª£c quy·ªÅn b·ªè phi·∫øu m·∫∑c ƒë·ªãnh."))
            game_state["math_results"][user_id] = True

    await countdown(game_state["text_channel"], 40, "h√†nh ƒë·ªông ƒë√™m", game_state)
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused during night phase, skipping further actions")
        return

    # L∆∞u m·ª•c ti√™u ban ƒë·∫ßu c·ªßa Hunter
    original_hunter_target_id = game_state["hunter_target_id"]

    # X√°c ƒë·ªãnh c√°c m·ª•c ti√™u ti·ªÅm nƒÉng cho Ph√π Th·ªßy
    potential_targets = []
    target_ids = set()
    kill_counts = {}  # T·ª´ ƒëi·ªÉn ƒë·ªÉ ƒë·∫øm s·ªë l·∫ßn b·ªã gi·∫øt c·ªßa m·ªói ng∆∞·ªùi ch∆°i
    
    # Thu th·∫≠p t·∫•t c·∫£ c√°c h√†nh ƒë·ªông gi·∫øt
    actions = []
    
    # H√†nh ƒë·ªông c·ªßa S√≥i
    if game_state["werewolf_target_id"] and not game_state["demon_werewolf_cursed_this_night"]:
        actions.append(("werewolf", game_state["werewolf_target_id"]))
    
    # H√†nh ƒë·ªông c·ªßa Th·ª£ SƒÉn
    if game_state["hunter_target_id"]:
        actions.append(("hunter", game_state["hunter_target_id"]))
    
    # H√†nh ƒë·ªông c·ªßa Ng∆∞·ªùi Kh√°m Ph√°
    if game_state["night_count"] >= 2 and game_state["explorer_target_id"]:
        explorer_target_id = game_state["explorer_target_id"]
        target_role = game_state["players"][explorer_target_id]["role"]
        if target_role in ["Werewolf", "Wolfman", "Assassin Werewolf", "Demon Werewolf"]:
            actions.append(("explorer", explorer_target_id))
        else:
            explorer_id = next(uid for uid, d in game_state["players"].items() if d["role"] == "Explorer" and d["status"] in ["alive", "wounded"])
            actions.append(("explorer", explorer_id))
    
    # H√†nh ƒë·ªông c·ªßa S√≥i √Åm S√°t
    assassin_id = next((uid for uid, d in game_state["players"].items() if d["role"] == "Assassin Werewolf" and d["status"] in ["alive", "wounded"]), None)
    if assassin_id and game_state["assassin_werewolf_has_acted"]:
        target_id = game_state["assassin_werewolf_target_id"]
        role_guess = game_state["assassin_werewolf_role_guess"]
        if target_id in game_state["players"] and game_state["players"][target_id]["status"] in ["alive", "wounded"]:
            actual_role = game_state["players"][target_id]["role"]
            if actual_role == role_guess:
                actions.append(("assassin", target_id))
            else:
                actions.append(("assassin", assassin_id))
    
    # ƒê·∫øm s·ªë l·∫ßn b·ªã gi·∫øt, b·ªè qua ng∆∞·ªùi ƒë∆∞·ª£c B·∫£o V·ªá
    protected_id = game_state["protected_player_id"]
    for action_type, target_id in actions:
        if target_id != protected_id:
            kill_counts[target_id] = kill_counts.get(target_id, 0) + 1
    
    # X√°c ƒë·ªãnh ai s·∫Ω ch·∫øt v√† th√™m v√†o potential targets
    for user_id, count in kill_counts.items():
        data = game_state["players"].get(user_id)
        if data and data["status"] in ["alive", "wounded"]:
            if data["role"] == "Tough Guy":
                # Touch Guy ch·∫øt n·∫øu: alive + >=2 l·∫ßn gi·∫øt, ho·∫∑c wounded + >=1 l·∫ßn gi·∫øt
                if (data["status"] == "alive" and count >= 2) or (data["status"] == "wounded" and count >= 1):
                    target = game_state["member_cache"].get(user_id)
                    if target:
                        potential_targets.append(target)
                        target_ids.add(user_id)
            else:
                # Ng∆∞·ªùi th∆∞·ªùng ch·∫øt n·∫øu b·ªã gi·∫øt √≠t nh·∫•t 1 l·∫ßn
                if count >= 1:
                    target = game_state["member_cache"].get(user_id)
                    if target:
                        potential_targets.append(target)
                        target_ids.add(user_id)
    
    logger.info(f"Potential targets for Witch: {target_ids}")
    for user_id, data in game_state["players"].items():
        if data["role"] == "Witch" and data["status"] in ["alive", "wounded"]:
            member = game_state["member_cache"].get(user_id)
            if not member:
                continue
            if game_state["witch_has_power"]:
                if potential_targets:
                    target_names = ", ".join([t.display_name for t in potential_targets])
                    await retry_api_call(lambda: member.send(
                        f"ƒê√™m nay, {target_names} s·∫Ω b·ªã √∫p s·ªçt. Ch·ªçn h√†nh ƒë·ªông trong 20 gi√¢y:",
                        view=WitchActionView(alive_players, potential_targets, game_state, timeout=20)
                    ))
                    logger.info(f"Sent Witch notification: targets={target_names}, user_id={user_id}")
                else:
                    await retry_api_call(lambda: member.send(
                        "Kh√¥ng ai l√™n dƒ©a ƒë√™m nay! Ch·ªçn ng∆∞·ªùi ƒë·ªÉ b·∫Øt u·ªëng r∆∞·ª£u ƒë·ªôc ho·∫∑c b·ªè qua trong 20 gi√¢y:",
                        view=WitchActionView(alive_players, [], game_state, timeout=20)
                    ))
                    logger.info(f"Sent Witch notification: no targets, user_id={user_id}")
            else:
                await retry_api_call(lambda: member.send("Kh√¥ng ai l√™n dƒ©a ƒë√™m nay!"))
                logger.info(f"Sent Witch no-power notification: user_id={user_id}")
            break
    await countdown(game_state["text_channel"], 20, "ƒë√™m", game_state)
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused after Witch phase, skipping further actions")
        return

    # X·ª≠ l√Ω h√†nh ƒë·ªông c·ªßa Ph√π Th·ªßy
    dead_players = []
    if game_state["witch_has_power"]:
        if game_state["witch_action_save"] and game_state["witch_target_save_id"]:
            target_id = game_state["witch_target_save_id"]
            if target_id in game_state["players"] and game_state["players"][target_id]["status"] in ["alive", "wounded"]:
                target_data = game_state["players"][target_id]
                logger.info(f"Witch saving player: target_id={target_id}")
                # Ki·ªÉm tra n·∫øu l√† Touch Guy v√† s·∫Ω ch·∫øt
                if target_data["role"] == "Tough Guy":
                    count = kill_counts.get(target_id, 0)
                    if (target_data["status"] == "alive" and count >= 2) or (target_data["status"] == "wounded" and count >= 1):
                        target_data["status"] = "wounded"
                        logger.info(f"Witch saved Tough Guy: target_id={target_id}, status set to wounded")
                    else:
                        logger.info(f"Witch saved Tough Guy but no status change needed: target_id={target_id}")
                # H·ªßy c√°c h√†nh ƒë·ªông gi·∫øt
                if game_state["werewolf_target_id"] == target_id:
                    game_state["werewolf_target_id"] = None
                if game_state["hunter_target_id"] == target_id:
                    game_state["hunter_target_id"] = None
                if game_state["explorer_target_id"] == target_id:
                    game_state["explorer_target_id"] = None
                witch_member = next((m for uid, d in game_state["players"].items() if d["role"] == "Witch" and d["status"] in ["alive", "wounded"] and (m := game_state["member_cache"].get(uid))), None)
                if witch_member:
                    target_member = game_state["member_cache"].get(target_id)
                    if target_member:
                        await retry_api_call(lambda: witch_member.send(f"B·∫°n ƒë√£ c·ª©u {target_member.display_name} th√†nh c√¥ng! T·ª´ ƒë√™m sau, b·∫°n s·∫Ω kh√¥ng nh·∫≠n th√¥ng tin v·ªÅ ng∆∞·ªùi b·ªã l√™n dƒ©a n·ªØa."))
                    else:
                        await retry_api_call(lambda: witch_member.send("B·∫°n ƒë√£ c·ª©u m·ªôt ng∆∞·ªùi th√†nh c√¥ng! T·ª´ ƒë√™m sau, b·∫°n s·∫Ω kh√¥ng nh·∫≠n th√¥ng tin v·ªÅ ng∆∞·ªùi b·ªã l√™n dƒ©a n·ªØa."))
            game_state["witch_has_power"] = False

        if game_state["witch_action_kill"] and game_state["witch_target_kill_id"]:
            target_id = game_state["witch_target_kill_id"]
            if target_id in game_state["players"] and game_state["players"][target_id]["status"] in ["alive", "wounded"]:
                target_data = game_state["players"][target_id]
                member = game_state["member_cache"].get(target_id)
                if member:
                    if target_id == game_state["protected_player_id"]:
                        logger.info(f"Witch kill failed: target_id={target_id} is protected")
                        witch_member = next((m for uid, d in game_state["players"].items() if d["role"] == "Witch" and d["status"] in ["alive", "wounded"] and (m := game_state["member_cache"].get(uid))), None)
                        if witch_member:
                            await retry_api_call(lambda: witch_member.send("B·∫°n ƒë√£ s·ª≠ d·ª•ng quy·ªÅn nƒÉng! T·ª´ ƒë√™m sau, b·∫°n s·∫Ω kh√¥ng nh·∫≠n th√¥ng tin v·ªÅ ng∆∞·ªùi b·ªã l√™n dƒ©a n·ªØa."))
                    else:
                        logger.info(f"Witch killing player: target_id={target_id}, target_name={member.display_name}")
                        if target_data["role"] == "Tough Guy" and target_data["status"] == "alive":
                            target_data["status"] = "wounded"
                            logger.info(f"Tough Guy wounded by Witch: target_id={target_id}")
                        else:
                            target_data["status"] = "dead"
                            dead_players.append(member.display_name)
                            await handle_player_death(interaction, member, target_id, game_state)
                            logger.info(f"Witch killed player: target_id={target_id}")
                        witch_member = next((m for uid, d in game_state["players"].items() if d["role"] == "Witch" and d["status"] in ["alive", "wounded"] and (m := game_state["member_cache"].get(uid))), None)
                        if witch_member:
                            await retry_api_call(lambda: witch_member.send("B·∫°n ƒë√£ s·ª≠ d·ª•ng quy·ªÅn nƒÉng! T·ª´ ƒë√™m sau, b·∫°n s·∫Ω kh√¥ng nh·∫≠n th√¥ng tin v·ªÅ ng∆∞·ªùi b·ªã l√™n dƒ©a n·ªØa."))
            game_state["witch_has_power"] = False

    # X·ª≠ l√Ω c√°c c√°i ch·∫øt t·ª´ S√≥i v√† Th·ª£ SƒÉn
    for target_id, source in [(game_state["werewolf_target_id"], "Werewolf"), (game_state["hunter_target_id"], "Hunter")]:
        if target_id and target_id != game_state["protected_player_id"] and target_id in game_state["players"]:
            target_data = game_state["players"].get(target_id)
            if target_data["status"] in ["alive", "wounded"]:
                member = game_state["member_cache"].get(target_id)
                if member:
                    logger.info(f"Processing death by {source}: target_id={target_id}, target_name={member.display_name}")
                    if source == "Werewolf" and game_state["demon_werewolf_cursed_this_night"]:
                        logger.info(f"Werewolf target not killed because Demon Werewolf cursed this night: target_id={target_id}")
                    elif target_data["role"] == "Tough Guy" and target_data["status"] == "alive":
                        target_data["status"] = "wounded"
                        logger.info(f"Tough Guy wounded by {source}: target_id={target_id}")
                    else:
                        target_data["status"] = "dead"
                        dead_players.append(member.display_name)
                        await handle_player_death(interaction, member, target_id, game_state)

    # C·∫≠p nh·∫≠t tr·∫°ng th√°i Hunter sau khi x·ª≠ l√Ω t·∫•t c·∫£ h√†nh ƒë·ªông
    if original_hunter_target_id is not None:
        game_state["hunter_has_power"] = False
        for user_id_hunter, data_hunter in game_state["players"].items():
            if data_hunter["role"] == "Hunter" and data_hunter["status"] in ["alive", "wounded"]:
                hunter_member = game_state["member_cache"].get(user_id_hunter)
                if hunter_member:
                    await retry_api_call(lambda: hunter_member.send("B·∫°n ƒë√£ s·ª≠ d·ª•ng quy·ªÅn nƒÉng c·ªßa m√¨nh! B·∫°n kh√¥ng c√≤n ch·ª©c nƒÉng n·ªØa."))
                break
    # X·ª≠ l√Ω c√°c c√°i ch·∫øt c·ªßa Kh√°m ph√°
    if game_state["night_count"] >= 2 and game_state.get("explorer_id") in game_state["players"] and game_state["players"][game_state["explorer_id"]]["status"] in ["alive", "wounded"]:
        if game_state["explorer_target_id"] is None:
            game_state["explorer_can_act"] = False
            explorer_member = game_state["member_cache"].get(game_state["explorer_id"])
            if explorer_member:
                await retry_api_call(lambda: explorer_member.send("B·∫°n ƒë√£ kh√¥ng ch·ªçn ai ƒë·ªÉ kh√°m ph√°, b·∫°n ƒë√£ m·∫•t ch·ª©c nƒÉng c·ªßa m√¨nh!"))
        else:
            target_id = game_state["explorer_target_id"]
            if target_id in game_state["players"] and game_state["players"][target_id]["status"] in ["alive", "wounded"]:
                target_role = game_state["players"][target_id]["role"]
                explorer_id = game_state["explorer_id"]
                explorer_member = game_state["member_cache"].get(explorer_id)
                if target_role in ["Werewolf", "Wolfman", "Assassin Werewolf", "Demon Werewolf"]:
                    if target_id == game_state["witch_target_save_id"]:
                        if explorer_member:
                            await retry_api_call(lambda: explorer_member.send("B·∫°n v√† m·ª•c ti√™u kh√¥ng ch·∫øt! B·∫°n v·∫´n gi·ªØ ch·ª©c nƒÉng."))
                    elif target_id != game_state["protected_player_id"]:
                        target_data = game_state["players"][target_id]
                        member = game_state["member_cache"].get(target_id)
                        if member:
                            if target_data["role"] == "Tough Guy" and target_data["status"] == "alive":
                                target_data["status"] = "wounded"
                            else:
                                target_data["status"] = "dead"
                                dead_players.append(member.display_name)
                                await handle_player_death(interaction, member, target_id, game_state)
                            if explorer_member:
                                await retry_api_call(lambda: explorer_member.send(f"B·∫°n ƒë√£ kh√°m ph√° v√† gi·∫øt {member.display_name}!"))
                else:
                    if explorer_id == game_state["witch_target_save_id"]:
                        if explorer_member:
                            await retry_api_call(lambda: explorer_member.send("B·∫°n v√† m·ª•c ti√™u kh√¥ng ch·∫øt! B·∫°n v·∫´n gi·ªØ ch·ª©c nƒÉng."))
                    elif explorer_id != game_state["protected_player_id"]:
                        explorer_data = game_state["players"][explorer_id]
                        if explorer_data["role"] == "Tough Guy" and explorer_data["status"] == "alive":
                            explorer_data["status"] = "wounded"
                        else:
                            explorer_data["status"] = "dead"
                            dead_players.append(explorer_member.display_name)
                            await handle_player_death(interaction, explorer_member, explorer_id, game_state)
                        if explorer_member:
                            await retry_api_call(lambda: explorer_member.send("B·∫°n ƒë√£ kh√°m ph√° sai v√† t·ª± s√°t!"))
    
    # X·ª≠ l√Ω h√†nh ƒë·ªông c·ªßa S√≥i √Åm S√°t
    if game_state["assassin_werewolf_has_acted"] and game_state["assassin_werewolf_target_id"] and game_state["assassin_werewolf_role_guess"]:
        target_id = game_state["assassin_werewolf_target_id"]
        role_guess = game_state["assassin_werewolf_role_guess"]
        assassin_id = next((uid for uid, d in game_state["players"].items() if d["role"] == "Assassin Werewolf"), None)
        if target_id in game_state["players"] and game_state["players"][target_id]["status"] in ["alive", "wounded"]:
            actual_role = game_state["players"][target_id]["role"]
            target_member = game_state["member_cache"].get(target_id)
            assassin_member = game_state["member_cache"].get(assassin_id)
            if actual_role == role_guess:
                # ƒêo√°n ƒë√∫ng, ki·ªÉm tra xem m·ª•c ti√™u c√≥ ƒë∆∞·ª£c c·ª©u hay kh√¥ng
                if target_id != game_state["witch_target_save_id"] and target_id != game_state["protected_player_id"]:
                    target_data = game_state["players"][target_id]
                    if target_data["role"] == "Tough Guy" and target_data["status"] == "alive":
                        target_data["status"] = "wounded"
                    else:
                        target_data["status"] = "dead"
                        dead_players.append(target_member.display_name)
                        await handle_player_death(interaction, target_member, target_id, game_state)
            else:
                # ƒêo√°n sai, ki·ªÉm tra xem S√≥i √Åm S√°t c√≥ ƒë∆∞·ª£c c·ª©u hay kh√¥ng
                if assassin_id != game_state["witch_target_save_id"] and assassin_id != game_state["protected_player_id"]:
                    assassin_data = game_state["players"][assassin_id]
                    if assassin_data["role"] == "Tough Guy" and assassin_data["status"] == "alive":
                        assassin_data["status"] = "wounded"
                    else:
                        assassin_data["status"] = "dead"
                        dead_players.append(assassin_member.display_name)
                        await handle_player_death(interaction, assassin_member, assassin_id, game_state)
        game_state["assassin_werewolf_target_id"] = None
        game_state["assassin_werewolf_role_guess"] = None
    # X·ª≠ l√Ω c√°c nguy·ªÅn Demon Werewolf
    

    if game_state["text_channel"]:
        if dead_players:
            death_embed = discord.Embed(
                title="üíÄ Th√¥ng B√°o Ng∆∞·ªùi Ra ƒêi",
                description=f"{', '.join(dead_players)} ƒë√£ l√™n b√†n th·ªù ng·∫Øm g√† ƒÉn x√¥i n·∫øp!",
                color=discord.Color.red()
            )
            death_embed.set_image(url=GIF_URLS["death"])
            await text_channel.send(embed=death_embed)
            logger.info(f"Announced deaths: {dead_players}")
        else:
            no_death_embed = discord.Embed(
                title="üíÄ Th√¥ng B√°o Ng∆∞·ªùi Ra ƒêi",
                description="Kh√¥ng ai t·ª´ b·ªè l√†ng trong ƒë√™m nay!",
                color=discord.Color.red()
            )
            await text_channel.send(embed=no_death_embed)
            logger.info("No deaths announced")
          
    # Log tr·∫°ng th√°i c·ªßa Demon Werewolf sau m·ªói ƒë√™m
    logger.info(f"Demon Werewolf cursed player: {game_state['demon_werewolf_cursed_player']}")
  
    game_state["previous_protected_player_id"] = game_state["protected_player_id"]
    game_state["protected_player_id"] = None
    game_state["demon_werewolf_cursed_this_night"] = False
    if await check_win_condition(interaction, game_state):
        return
    if not game_state["is_game_running"] or game_state["is_game_paused"]:
        logger.info("Game stopped or paused, skipping morning phase")
        return
    if text_channel:
        await text_channel.set_permissions(interaction.guild.default_role, send_messages=True)
    if voice_channel:
        await voice_channel.set_permissions(interaction.guild.default_role, speak=True)
    await morning_phase(interaction, game_state)

# H√†m reset game state m√† kh√¥ng x√≥a th√¥ng tin t·∫°m th·ªùi
async def reset_game_state(interaction: discord.Interaction, game_state):
    if not isinstance(interaction, discord.Interaction):
        logger.error(f"reset_game_state called with invalid type: {type(interaction)}")
        logger.error(f"Call stack: {''.join(traceback.format_stack())}")
        if hasattr(interaction, 'channel'):
            await interaction.channel.send("L·ªói: H√†m n√†y ch·ªâ h·ªó tr·ª£ slash commands!")
        return
    
    guild_id = interaction.guild.id
    if game_state["reset_in_progress"]:
        logger.warning(f"Reset already in progress, ignoring reset request by {interaction.user.id}")
        await interaction.channel.send("ƒêang th·ª±c hi·ªán reset, vui l√≤ng ch·ªù!")
        return
    if not game_state["is_game_running"]:
        logger.info(f"No game running to reset, requested by {interaction.user.id}")
        await interaction.channel.send("Ch∆∞a c√≥ game n√†o ƒë·ªÉ reset!")
        return
    game_state["reset_in_progress"] = True
    logger.info(f"Resetting game state: is_game_running={game_state['is_game_running']}, guild_id={game_state.get('guild_id')}")

    try:
        # G·ª≠i log k·∫øt qu·∫£ game
        if guild_id in game_logs:
            embed = discord.Embed(title="K·∫øt Qu·∫£ Game", color=discord.Color.blue())
            role_list = []
            for user_id, data in game_state["players"].items():
                member = game_state["member_cache"].get(user_id)
                if member:
                    status = "S·ªëng" if data["status"] in ["alive", "wounded"] else "Ch·∫øt"
                    role_list.append(f"{member.display_name}: {data['role']} ({status})")
            log_text = "\n".join(game_logs[guild_id] + ["Danh s√°ch cu·ªëi game:"] + role_list)
            if len(log_text) > 1024:
                log_text = log_text[-1024:]
            embed.add_field(name="T√¨nh tr·∫°ng", value=log_text or "Kh√¥ng c√≥ d·ªØ li·ªáu", inline=False)
            embed.set_footer(text=f"Log ƒë∆∞·ª£c g·ª≠i b·ªüi {interaction.user.name}")
            await interaction.channel.send(embed=embed)
        else:
            await interaction.channel.send("Kh√¥ng c√≥ d·ªØ li·ªáu n√†o ƒë∆∞·ª£c ghi l·∫°i trong game.")

        # L·∫•y c√°c k√™nh v√† vai tr√≤
        dead_channel = game_state.get("dead_channel") or discord.utils.get(interaction.guild.text_channels, name="dead-chat")
        wolf_channel = game_state.get("wolf_channel") or discord.utils.get(interaction.guild.text_channels, name="wolf-chat")
        voice_channel = bot.get_channel(game_state["voice_channel_id"])
        main_channel = bot.get_channel(game_state["voice_channel_id"])
        guild = bot.get_guild(game_state["guild_id"])
        villager_role = guild.get_role(game_state["villager_role_id"]) if game_state.get("villager_role_id") else None
        dead_role = guild.get_role(game_state["dead_role_id"]) if game_state.get("dead_role_id") else None
        werewolf_role = guild.get_role(game_state["werewolf_role_id"]) if game_state.get("werewolf_role_id") else None

        # L√†m m·ªõi member_cache
        try:
            game_state["member_cache"] = {m.id: m for m in await retry_api_call(lambda: interaction.guild.members)}
            logger.info(f"Refreshed member_cache with {len(game_state['member_cache'])} members")
        except Exception as e:
            logger.error(f"Failed to refresh member_cache: {str(e)}")
            await text_channel.send("L·ªói: Kh√¥ng th·ªÉ l√†m m·ªõi danh s√°ch th√†nh vi√™n server.")
        
        # Di chuy·ªÉn t·∫•t c·∫£ ng∆∞·ªùi ch∆°i v·ªÅ k√™nh ch√≠nh v√† unmute
        move_tasks = []
        for user_id in game_state["players"]:
            member = game_state["member_cache"].get(user_id)
            if member:
                move_tasks.append(member.move_to(main_channel))
                if member.voice:  # Unmute n·∫øu ng∆∞·ªùi ch∆°i ƒëang ·ªü trong voice
                    move_tasks.append(member.edit(mute=False))
        await asyncio.gather(*move_tasks)

        # X√≥a vai tr√≤ kh·ªèi ng∆∞·ªùi ch∆°i
        for user_id in game_state["players"]:
            member = game_state["member_cache"].get(user_id)
            if member:
                try:
                    if villager_role and villager_role in member.roles:
                        await member.remove_roles(villager_role)
                    if dead_role and dead_role in member.roles:
                        await member.remove_roles(dead_role)
                    logger.info(f"Removed Villager/Dead roles from member: ID={member.id}, Name={member.display_name}")
                except Exception as e:
                    logger.error(f"Failed to remove roles from member ID={member.id}: {str(e)}")
                    await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ x√≥a vai tr√≤ kh·ªèi {member.display_name}: {str(e)}")

        # Unmute v√† kh√¥i ph·ª•c quy·ªÅn cho ng∆∞·ªùi ch∆°i trong k√™nh voice
        if voice_channel:
            for user_id in game_state["players"]:
                member = game_state["member_cache"].get(user_id)
                if member and member in voice_channel.members:
                    try:
                        await member.edit(mute=False)
                        logger.info(f"Unmuted member: ID={member.id}, Name={member.display_name}")
                    except Exception as e:
                        logger.error(f"Failed to unmute member ID={member.id}: {str(e)}")
                        await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ unmute {member.display_name}: {str(e)}")
                      
            # Kh√¥i ph·ª•c quy·ªÅn n√≥i cho @everyone trong k√™nh voice
            try:
                await voice_channel.set_permissions(interaction.guild.default_role, speak=True)
                logger.info(f"Restored speak permission for @everyone in voice_channel: ID={voice_channel.id}")
            except Exception as e:
                logger.error(f"Failed to restore speak permission in voice_channel: {str(e)}")
                await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ kh√¥i ph·ª•c quy·ªÅn voice cho @everyone: {str(e)}")

        # X√≥a c√°c k√™nh voice ri√™ng bi·ªát
        if "player_channels" in game_state:
            for channel in game_state["player_channels"].values():
                try:
                    await channel.delete()
                    logger.info(f"Deleted player channel: ID={channel.id}")
                except Exception as e:
                    logger.error(f"Failed to delete player channel ID={channel.id}: {str(e)}")
                    await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ x√≥a k√™nh voice ri√™ng: {str(e)}")
            game_state["player_channels"].clear()

        # ƒê·ªìng b·ªô ho·∫∑c kh√¥i ph·ª•c quy·ªÅn c·ªßa k√™nh vƒÉn b·∫£n
        text_channel = game_state.get("text_channel") or interaction.channel
        if text_channel:
            try:
                if text_channel.category:
                    await text_channel.edit(sync_permissions=True)
                    logger.info(f"Synchronized permissions for channel {text_channel.name} with category {text_channel.category.name}")
                else:
                    await text_channel.set_permissions(interaction.guild.default_role, send_messages=True)
                    logger.info(f"Restored default send_messages permission for channel {text_channel.name}")
            except Exception as e:
                logger.error(f"Failed to synchronize or restore permissions for channel {text_channel.name}: {str(e)}")
                await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ ƒë·ªìng b·ªô ho·∫∑c kh√¥i ph·ª•c quy·ªÅn cho k√™nh {text_channel.name}: {str(e)}")

        # ƒê·ªìng b·ªô ho·∫∑c kh√¥i ph·ª•c quy·ªÅn c·ªßa k√™nh voice
        voice_channel = bot.get_channel(game_state["voice_channel_id"])
        if voice_channel:
            # Unmute ng∆∞·ªùi ch∆°i
            for user_id in game_state["players"]:
                member = game_state["member_cache"].get(user_id)
                if member and member in voice_channel.members:
                    try:
                        await member.edit(mute=False)
                        logger.info(f"Unmuted member: ID={member.id}, Name={member.display_name}")
                    except Exception as e:
                        logger.error(f"Failed to unmute member ID={member.id}: {str(e)}")
                        await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ unmute {member.display_name}: {str(e)}")
            
            # Kh√¥i ph·ª•c quy·ªÅn cho @everyone
            try:
                if voice_channel.category:
                    # N·∫øu k√™nh thu·ªôc category, ƒë·ªìng b·ªô quy·ªÅn v·ªõi category
                    await voice_channel.edit(sync_permissions=True)
                    logger.info(f"Synchronized permissions for voice channel {voice_channel.name} with category {voice_channel.category.name}")
                else:
                    # N·∫øu kh√¥ng c√≥ category, ƒë·∫∑t quy·ªÅn m·∫∑c ƒë·ªãnh
                    await voice_channel.set_permissions(interaction.guild.default_role, speak=True, connect=True)
                    logger.info(f"Restored default permissions (speak=True, connect=True) for @everyone in voice_channel: ID={voice_channel.id}")
            except Exception as e:
                logger.error(f"Failed to restore permissions for voice channel {voice_channel.name}: {str(e)}")
                await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ kh√¥i ph·ª•c quy·ªÅn cho k√™nh voice {voice_channel.name}: {str(e)}")

        # X√≥a k√™nh dead-chat v√† wolf-chat
        if dead_channel:
            try:
                await dead_channel.delete()
                logger.info(f"Deleted dead-chat: ID={dead_channel.id}")
            except Exception as e:
                logger.error(f"Failed to delete dead-chat: {str(e)}")
                await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ x√≥a k√™nh dead-chat: {str(e)}")
        if wolf_channel:
            try:
                await wolf_channel.delete()
                logger.info(f"Deleted wolf-chat: ID={wolf_channel.id}")
            except Exception as e:
                logger.error(f"Failed to delete wolf-chat: {str(e)}")
                await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ x√≥a k√™nh wolf-chat: {str(e)}")

        # X√≥a vai tr√≤ game
        if villager_role:
            try:
                await villager_role.delete()
                logger.info(f"Deleted Villager role: ID={villager_role.id}")
            except Exception as e:
                logger.error(f"Failed to delete Villager role: {str(e)}")
                await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ x√≥a vai tr√≤ D√¢n L√†ng: {str(e)}")
        if dead_role:
            try:
                await dead_role.delete()
                logger.info(f"Deleted Dead role: ID={dead_role.id}")
            except Exception as e:
                logger.error(f"Failed to delete Dead role: {str(e)}")
                await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ x√≥a vai tr√≤ Ng∆∞·ªùi Ch·∫øt: {str(e)}")
        if werewolf_role:
            try:
                await werewolf_role.delete()
                logger.info(f"Deleted Werewolf role: ID={werewolf_role.id}")
            except Exception as e:
                logger.error(f"Failed to delete Werewolf role: {str(e)}")
                await text_channel.send(f"L·ªói: Kh√¥ng th·ªÉ x√≥a vai tr√≤ Werewolf: {str(e)}")

        # Reset game_state
        game_state["players"].clear()
        game_state["is_game_running"] = False
        game_state["is_game_paused"] = False
        game_state["phase"] = "none"
        game_state["text_channel"] = interaction.channel
        game_state["is_first_day"] = True
        game_state["protected_player_id"] = None
        game_state["previous_protected_player_id"] = None
        game_state["werewolf_target_id"] = None
        game_state["witch_target_id"] = None
        game_state["witch_action"] = None
        game_state["witch_has_power"] = True
        game_state["hunter_target_id"] = None
        game_state["hunter_has_power"] = True
        game_state["explorer_target_id"] = None
        game_state["votes"] = {}
        game_state["wolf_channel"] = None
        game_state["dead_channel"] = None
        game_state["illusionist_scanned"] = False
        game_state["illusionist_effect_active"] = False
        game_state["illusionist_effect_night"] = 0
        game_state["villager_role_id"] = None
        game_state["dead_role_id"] = None
        game_state["werewolf_role_id"] = None
        game_state["night_count"] = 0
        game_state["demon_werewolf_activated"] = False
        game_state["demon_werewolf_cursed_player"] = None
        game_state["demon_werewolf_cursed_this_night"] = False
        game_state["demon_werewolf_has_cursed"] = False
        game_state["assassin_werewolf_has_acted"] = False
        game_state["assassin_werewolf_target_id"] = None
        game_state["assassin_werewolf_role_guess"] = None
        game_state["detective_has_used_power"] = False
        game_state["detective_target1_id"] = None
        game_state["detective_target2_id"] = None
        game_logs[guild_id].clear()

        await text_channel.send("Game ƒë√£ ƒë∆∞·ª£c reset th√†nh c√¥ng! T·∫•t c·∫£ tr·∫°ng th√°i ƒë√£ ƒë∆∞·ª£c kh√¥i ph·ª•c.")
    finally:
        game_state["reset_in_progress"] = False

# H√†m x·ª≠ l√Ω khi game k·∫øt th√∫c v√† cung c·∫•p t√πy ch·ªçn
async def handle_game_end(interaction: discord.Interaction, game_state):
    if game_state["text_channel"] is not None:
        await game_state["text_channel"].send("Game ƒëang k·∫øt th√∫c v√† d·ªØ li·ªáu ƒëang ƒë∆∞·ª£c x√≥a, vui l√≤ng ch·ªù...")
    else:
        logger.warning("Text channel not set, cannot send game ending message")
    # Reset game state tr∆∞·ªõc
    await reset_game_state(interaction, game_state)
    
    # Th√™m kho·∫£ng th·ªùi gian ch·ªù 5 gi√¢y ƒë·ªÉ ƒë·∫£m b·∫£o c√°c t√°c v·ª• trong reset_game_state ho√†n t·∫•t
    await asyncio.sleep(5)
    
    # Ph√°t √¢m thanh end_game.mp3 tr∆∞·ªõc khi bot r·ªùi k√™nh voice
    if game_state["voice_connection"] and game_state["voice_connection"].is_connected():
        await play_audio(AUDIO_FILES["end_game"], game_state["voice_connection"])
    
    # Bot r·ªùi k√™nh voice sau khi ph√°t √¢m thanh
    if game_state["voice_connection"] and game_state["voice_connection"].is_connected():
        try:
            await game_state["voice_connection"].disconnect()
            logger.info(f"Bot disconnected from voice channel: ID={game_state['voice_channel_id']}")
        except Exception as e:
            logger.error(f"Failed to disconnect from voice channel ID={game_state['voice_channel_id']}: {str(e)}")
        game_state["voice_connection"] = None
    
    if game_state["text_channel"] is not None:
        await game_state["text_channel"].send("Game ƒë√£ k·∫øt th√∫c. Ch·ªçn h√†nh ƒë·ªông ti·∫øp theo:", view=GameEndView(game_state["temp_admin_id"], interaction, game_state))
    else:
        logger.warning("Text channel not set, cannot send game end options message")

# View cho t√πy ch·ªçn khi game k·∫øt th√∫c
class GameEndView(discord.ui.View):
    def __init__(self, admin_id, interaction: discord.Interaction, game_state):
        super().__init__(timeout=60)
        self.admin_id = admin_id
        self.interaction = interaction
        self.game_state = game_state

    @discord.ui.button(label="Start New Game", style=discord.ButtonStyle.green)
    async def start_new_game(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.admin_id:
            await interaction.response.send_message("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        await interaction.response.send_message("B·∫Øt ƒë·∫ßu game m·ªõi...", ephemeral=True)
        await start_new_game_with_same_setup(self.interaction, self.game_state)

    @discord.ui.button(label="End Game", style=discord.ButtonStyle.red)
    async def end_game(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.admin_id:
            await interaction.response.send_message("Ch·ªâ ng∆∞·ªùi ch·∫°y l·ªánh !start_game ƒë∆∞·ª£c thao t√°c!", ephemeral=True)
            return
        await interaction.response.send_message("K·∫øt th√∫c game.", ephemeral=True)
        self.game_state["temp_players"] = []
        self.game_state["temp_roles"] = {role: 0 for role in ROLES}
        self.game_state["temp_admin_id"] = None
        self.game_state["voice_channel_id"] = None
        self.game_state["guild_id"] = None
        self.game_state["text_channel"] = None
        self.game_state["member_cache"].clear()

# H√†m b·∫Øt ƒë·∫ßu game m·ªõi v·ªõi c√πng ng∆∞·ªùi ch∆°i v√† vai tr√≤
async def start_new_game_with_same_setup(interaction: discord.Interaction, game_state):
    if not game_state["temp_players"] or not game_state["temp_roles"]:
        await game_state["text_channel"].send("L·ªói: Kh√¥ng c√≥ th√¥ng tin ng∆∞·ªùi ch∆°i ho·∫∑c vai tr√≤ ƒë·ªÉ kh·ªüi ƒë·ªông l·∫°i game!")
        return
    guild = bot.get_guild(game_state["guild_id"])
    voice_channel = bot.get_channel(game_state["voice_channel_id"])
    
    # L√†m m·ªõi member_cache
    game_state["member_cache"] = {m.id: m for m in await retry_api_call(lambda: guild.members)}
    
    # Ki·ªÉm tra tr·∫°ng th√°i voice c·ªßa ng∆∞·ªùi ch∆°i
    current_members = {m.id for m in voice_channel.members if not m.bot}
    missing_players = [uid for uid in game_state["temp_players"] if uid not in current_members]
    if missing_players:
        await game_state["text_channel"].send(f"C√°c ng∆∞·ªùi ch∆°i sau kh√¥ng c√≤n trong k√™nh voice: {', '.join([str(uid) for uid in missing_players])}")
        return
    
    # Bot tham gia l·∫°i k√™nh voice
    try:
        game_state["voice_connection"] = await voice_channel.connect()
        logger.info(f"Bot joined voice channel: ID={voice_channel.id}, Name={voice_channel.name}")
    except Exception as e:
        logger.error(f"Failed to join voice channel ID={voice_channel.id}: {str(e)}")
        await game_state["text_channel"].send(f"L·ªói: Kh√¥ng th·ªÉ tham gia k√™nh voice {voice_channel.name}.")
        return
    
    # T·∫°o vai tr√≤ Discord
    villager_role = await guild.create_role(
        name="D√¢n L√†ng",
        color=discord.Color.green(),
        hoist=True,
        mentionable=False
    )
    game_state["villager_role_id"] = villager_role.id
    dead_role = await guild.create_role(
        name="Ng∆∞·ªùi Ch·∫øt",
        color=discord.Color.greyple(),
        hoist=True,
        mentionable=False
    )
    game_state["dead_role_id"] = dead_role.id
    werewolf_role = await guild.create_role(
        name="Werewolf",
        color=discord.Color.red(),
        hoist=False,
        mentionable=False
    )
    game_state["werewolf_role_id"] = werewolf_role.id

    await voice_channel.set_permissions(dead_role, speak=False)
    
    # Thi·∫øt l·∫≠p quy·ªÅn cho k√™nh vƒÉn b·∫£n
    text_channel = interaction.channel
    await text_channel.set_permissions(guild.default_role, send_messages=False)
    await text_channel.set_permissions(villager_role, send_messages=True)
    await text_channel.set_permissions(dead_role, send_messages=False)
    game_state["text_channel"] = text_channel
    
    # T·∫°o c√°c k√™nh voice ri√™ng cho ng∆∞·ªùi ch∆°i
    game_state["player_channels"] = {}
    for uid in game_state["temp_players"]:
        member = game_state["member_cache"].get(uid)
        if member:
            max_name_length = 100 - len("House of ") - 1
            channel_name = f"House of {member.display_name[:max_name_length]}"
            overwrites = {
                guild.default_role: discord.PermissionOverwrite(read_messages=False, connect=False),
                member: discord.PermissionOverwrite(read_messages=True, connect=True),
                guild.me: discord.PermissionOverwrite(read_messages=True, connect=True)
            }
            channel = await guild.create_voice_channel(channel_name, overwrites=overwrites)
            game_state["player_channels"][member.id] = channel
            logger.info(f"ƒê√£ t·∫°o ph√≤ng voice ri√™ng cho ng∆∞·ªùi ch∆°i: {member.display_name}, channel_id={channel.id}")
    
    # T·∫°o k√™nh wolf-chat v√† dead-chat
    game_state["wolf_channel"] = await setup_wolf_channel(guild, game_state)
    game_state["dead_channel"] = await setup_dead_channel(guild, game_state)
    
    # Ph√¢n vai ng·∫´u nhi√™n
    roles = []
    for role, count in game_state["temp_roles"].items():
        roles.extend([role] * count)
    random.shuffle(roles)
    game_state["players"] = {}
    werewolf_ids = []
    illusionist_id = None
    for i, uid in enumerate(game_state["temp_players"]):
        member = game_state["member_cache"].get(uid)
        if member:
            role = roles[i]
            game_state["players"][uid] = {"role": role, "status": "alive", "muted": False}
            await member.add_roles(villager_role)
            if role in ["Werewolf", "Wolfman", "Demon Werewolf", "Assassin Werewolf"]:
                werewolf_ids.append(uid)
                await member.add_roles(werewolf_role)
                await game_state["wolf_channel"].set_permissions(member, read_messages=True, send_messages=True)
            elif role == "Illusionist":
                illusionist_id = uid
            # G·ª≠i th√¥ng b√°o vai tr√≤ qua DM
            role_icon_url = ROLE_ICONS.get(role, "https://example.com/default_icon.png")
            embed = discord.Embed(
                title="Vai Tr√≤ C·ªßa B·∫°n",
                description=f"B·∫°n ƒë√£ ƒë∆∞·ª£c ph√¢n vai: **{role}**",
                color=discord.Color.blue()
            )
            embed.set_thumbnail(url=role_icon_url)
            await retry_api_call(lambda: member.send(embed=embed))
    
    # Th√¥ng b√°o danh s√°ch s√≥i v√† Nh√† ·∫¢o Gi√°c trong wolf-chat
    werewolf_members = [game_state["member_cache"].get(wid) for wid in werewolf_ids if game_state["member_cache"].get(wid)]
    illusionist_member = game_state["member_cache"].get(illusionist_id) if illusionist_id else None

    embed = discord.Embed(
        title="Danh s√°ch S√≥i phe S√≥i",
        color=discord.Color.red()
    )

    if werewolf_members:
        werewolf_names = ", ".join([m.display_name for m in werewolf_members])
        embed.add_field(name="S√≥i", value=werewolf_names, inline=False)

    if illusionist_member:
        embed.add_field(name="·∫¢o Gi√°c", value=illusionist_member.display_name, inline=False)
        embed.add_field(name="L∆∞u √Ω", value="·∫¢o Gi√°c thu·ªôc phe S√≥i nh∆∞ng kh√¥ng th·ª©c d·∫≠y c√πng c√°c b·∫°n v√† kh√¥ng bi·∫øt s√≥i l√† ai", inline=False)

    if game_state["wolf_channel"]:
        await game_state["wolf_channel"].send(embed=embed)

    # Th√™m th√¥ng b√°o game b·∫Øt ƒë·∫ßu v·ªõi s·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i v√† vai tr√≤
    if game_state["text_channel"]:
        # T·∫°o chu·ªói danh s√°ch vai tr√≤
        role_list_str = ", ".join([f"{role}: {count}" for role, count in game_state["temp_roles"].items() if count > 0])
        
        start_embed = discord.Embed(
            title="üéÆ **Game Ma S√≥i DeWolfVie B·∫Øt ƒê·∫ßu!**",
            description=(
                f"**üîπ S·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i: {len(game_state['players'])}**\n"
                f"**üîπ C√°c vai tr√≤ trong game: {role_list_str}**\n"
                "**üîπ T·∫•t c·∫£ ng∆∞·ªùi ch∆°i ƒë√£ ƒë∆∞·ª£c g√°n vai tr√≤.**\n"
                "**üîπ K√™nh wolf-chat v√† dead-chat ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p.**\n"
                "**üîπ H√£y ki·ªÉm tra tin nh·∫Øn DM ƒë·ªÉ bi·∫øt vai tr√≤ c·ªßa b·∫°n.**\n"
                "**üîπ Chu·∫©n b·ªã cho pha ng√†y ƒë·∫ßu ti√™n!**"
            ),
            color=discord.Color.blue()
        )
        start_embed.set_image(url="https://cdn.discordapp.com/attachments/1365707789321633813/1372536545717780601/Banner_early_acccess_540x320.png?ex=682721c4&is=6825d044&hm=edce6a3e72304cce30f95e30fca1a3c480e7e8b0a340c95fd6d850541cafc7c6&")  # Th√™m URL c·ªßa ·∫£nh banner
        start_embed.set_footer(text="DeWolfVie ver 5.15")
        await game_state["text_channel"].send(embed=start_embed)
    
    # Reset tr·∫°ng th√°i game
    game_state["is_game_running"] = True
    game_state["is_first_day"] = True
    game_state["witch_has_power"] = game_state["temp_roles"]["Witch"] > 0
    game_state["hunter_has_power"] = game_state["temp_roles"]["Hunter"] > 0
    game_state["phase"] = "none"
    game_state["text_channel"] = interaction.channel
    game_state["votes"] = {}
    game_state["illusionist_scanned"] = False
    game_state["illusionist_effect_active"] = False
    game_state["illusionist_effect_night"] = 0
    game_state["night_count"] = 0
    game_state["math_problems"] = {}
    game_state["math_results"] = {}
    game_state["demon_werewolf_activated"] = False
    game_state["demon_werewolf_cursed_player"] = None
    game_state["demon_werewolf_has_cursed"] = False
    game_state["demon_werewolf_cursed_this_night"] = False
    game_state["assassin_werewolf_has_acted"] = False
    game_state["assassin_werewolf_target_id"] = None
    game_state["assassin_werewolf_role_guess"] = None
    game_state["detective_has_used_power"] = False
    game_state["detective_target1_id"] = None
    game_state["detective_target2_id"] = None
    
    await morning_phase(interaction, game_state)

# L·ªánh v√† s·ª± ki·ªán
@bot.event
async def on_ready():
    print("Commands in tree before sync:")
    for command in bot.tree.get_commands():
        print(f"- {command.name}")
    init_game_logs_table()  # Th√™m d√≤ng n√†y
    await bot.tree.sync()
    print(f"Bot ƒë√£ s·∫µn s√†ng v·ªõi t√™n {bot.user}")

@bot.tree.command(name="help_masoi", description="Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n ch∆°i Ma S√≥i")
async def help_masoi(interaction: discord.Interaction):
    await interaction.response.defer()
    text_channel = interaction.channel
    embed = discord.Embed(
        title="H∆∞·ªõng D·∫´n Bot Ma S√≥i",
        description="Danh s√°ch l·ªánh v√† c√°ch s·ª≠ d·ª•ng ƒë·ªÉ ch∆°i Ma S√≥i.",
        color=discord.Color.blue()
    )
    embed.add_field(
        name="/start_game",
        value="B·∫Øt ƒë·∫ßu game m·ªõi, ch·ªçn k√™nh voice, s·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i, danh s√°ch ng∆∞·ªùi ch∆°i v√† vai tr√≤. Ng∆∞·ªùi ch∆°i s·∫Ω ƒë∆∞·ª£c c·∫•p vai tr√≤ D√¢n L√†ng trong Discord. Bot s·∫Ω tham gia k√™nh voice c√πng ng∆∞·ªùi ch∆°i.",
        inline=False
    )
    embed.add_field(
        name="/pause_game",
        value="T·∫°m d·ª´ng game hi·ªán t·∫°i. C√°c pha s·∫Ω d·ª´ng l·∫°i, ng∆∞·ªùi ch∆°i kh√¥ng th·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông cho ƒë·∫øn khi ti·∫øp t·ª•c.",
        inline=False
    )
    embed.add_field(
        name="/resume_game",
        value="Ti·∫øp t·ª•c game ƒë√£ b·ªã t·∫°m d·ª´ng.",
        inline=False
    )
    embed.add_field(
        name="/reset_game",
        value="Reset game hi·ªán t·∫°i, x√≥a k√™nh wolf-chat v√† dead-chat, b·∫≠t l·∫°i mic, x√≥a vai tr√≤ D√¢n L√†ng/Ng∆∞·ªùi Ch·∫øt, g·ª≠i log tr·∫°ng th√°i ng∆∞·ªùi ch∆°i, sau ƒë√≥ t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu l·∫°i game v·ªõi c√πng ng∆∞·ªùi ch∆°i v√† vai tr√≤ (ch·ªâ x√°o tr·ªôn vai tr√≤).",
        inline=False
    )
    embed.add_field(
        name="/end_game",
        value="K·∫øt th√∫c game, x√≥a vai tr√≤ D√¢n L√†ng/Ng∆∞·ªùi Ch·∫øt, g·ª≠i log tr·∫°ng th√°i ng∆∞·ªùi ch∆°i, reset game v√† bot r·ªùi k√™nh voice.",
        inline=False
    )
    embed.add_field(
        name="/roles_list",
        value="Hi·ªÉn th·ªã danh s√°ch c√°c vai tr√≤ v√† m√¥ t·∫£ ch·ª©c nƒÉng c·ªßa ch√∫ng trong game, ph√¢n chia theo Phe D√¢n v√† Phe S√≥i.",
        inline=False
    )
    embed.add_field(
        name="/status",
        value="Ki·ªÉm tra tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa bot (game ƒëang ch·∫°y, s·ªë ng∆∞·ªùi ch∆°i, pha hi·ªán t·∫°i, tr·∫°ng th√°i t·∫°m d·ª´ng).",
        inline=False
    )
    embed.add_field(
        name="/check_mute",
        value="Ki·ªÉm tra xem c√≥ ng∆∞·ªùi ch∆°i n√†o ƒëang b·ªã mute trong game hay kh√¥ng.",
        inline=False
    )
    embed.add_field(
        name="/help_masoi",
        value="Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n n√†y.",
        inline=False
    )
    embed.set_footer(text="DeWolfVie ver 5.15")
    await interaction.followup.send(embed=embed)

# L·ªánh roles_list ƒë√£ ƒë∆∞·ª£c s·ª≠a
@bot.tree.command(name="roles_list", description="Hi·ªÉn th·ªã danh s√°ch vai tr√≤ trong game")
async def roles_list(interaction: discord.Interaction):
    await interaction.response.defer()
    embed = discord.Embed(
        title="Danh S√°ch Vai Tr√≤ Ma S√≥i",
        description="Danh s√°ch c√°c vai tr√≤ trong game, ph√¢n chia theo phe. Chi ti·∫øt v·ªÅ c√°c vai tr√≤ c√≥ th·ªÉ xem t·∫°i [ƒë√¢y](https://www.dewolfvie.net/vn/chucnang).",
        color=discord.Color.blue()
    )

    # Danh s√°ch vai tr√≤ Phe D√¢n
    villager_roles = "\n".join([f"**{role}**" for role in VILLAGER_ROLES])
    embed.add_field(name="Phe D√¢n", value=villager_roles, inline=False)

    # Danh s√°ch vai tr√≤ Phe S√≥i
    werewolf_roles = "\n".join([f"**{role}**" for role in WEREWOLF_ROLES])
    embed.add_field(name="Phe S√≥i", value=werewolf_roles, inline=False)

    embed.set_footer(text="DeWolfVie ver 5.15")
    await interaction.followup.send(embed=embed)

# L·ªánh roles m·ªõi
@bot.tree.command(name="roles", description="Xem m√¥ t·∫£ chi ti·∫øt c·ªßa m·ªôt vai tr√≤ c·ª• th·ªÉ")
@app_commands.describe(role="Ch·ªçn vai tr√≤ ƒë·ªÉ xem chi ti·∫øt")
@app_commands.choices(role=[
    app_commands.Choice(name=role, value=role) for role in ROLES
])
async def roles(interaction: discord.Interaction, role: str):
    await interaction.response.defer()
    if role not in ROLE_LINKS:
        await interaction.followup.send("Vai tr√≤ kh√¥ng h·ª£p l·ªá!")
        return
    link = ROLE_LINKS[role]
    embed = discord.Embed(
        title=f"Chi Ti·∫øt Vai Tr√≤: {role}",
        description=f"Xem chi ti·∫øt v·ªÅ vai tr√≤ **{role}** t·∫°i [ƒë√¢y]({link}).",
        color=discord.Color.blue()
    )
    embed.set_footer(text="DeWolfVie ver 5.15")
    await interaction.followup.send(embed=embed)

@bot.tree.command(name="start_game", description="B·∫Øt ƒë·∫ßu m·ªôt game Ma S√≥i m·ªõi")
async def start_game(interaction: discord.Interaction):
    await interaction.response.defer()
    text_channel = interaction.channel
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        game_states[guild_id] = {
            "players": {},
            "voice_channel_id": None,
            "guild_id": guild_id,
            "is_game_running": False,
            "is_game_paused": False,
            "phase": "none",
            "is_first_day": True,
            "protected_player_id": None,
            "previous_protected_player_id": None,
            "werewolf_target_id": None,
            "witch_target_id": None,
            "witch_action": None,
            "witch_has_power": True,
            "hunter_target_id": None,
            "hunter_has_power": True,
            "votes": {},
            "text_channel": text_channel,
            "wolf_channel": None,
            "dead_channel": None,
            "illusionist_scanned": False,
            "illusionist_effect_active": False,
            "illusionist_effect_night": 0,
            "temp_player_count": 0,
            "temp_players": [],
            "temp_roles": {role: 0 for role in ROLES},
            "temp_admin_id": None,
            "reset_in_progress": False,
            "math_problems": {},
            "math_results": {},
            "member_cache": {},
            "player_channels": {},
            "villager_role_id": None,
            "dead_role_id": None,
            "werewolf_role_id": None,
            "night_count": 0,
            "voice_connection": None,
            "demon_werewolf_activated": False,
            "demon_werewolf_cursed_player": None,
            "demon_werewolf_cursed_this_night": False,
            "demon_werewolf_cursed_this_night": False,
            "setup_message": None,
            "assassin_werewolf_has_acted": False,
            "assassin_werewolf_target_id": None,
            "assassin_werewolf_role_guess": None,
            "detective_has_used_power": False,
            "detective_target1_id": None,
            "detective_target2_id": None
        }
    game_state = game_states[guild_id]
    if game_state["is_game_running"]:
        await interaction.followup.send("Game ƒëang ch·∫°y tr√™n server n√†y! D√πng /reset_game ho·∫∑c /end_game ƒë·ªÉ k·∫øt th√∫c game hi·ªán t·∫°i.")
        return
    game_state["temp_admin_id"] = interaction.user.id
    guild = interaction.guild
    voice_channels = [ch for ch in guild.voice_channels if ch.members]
    if not voice_channels:
        await interaction.followup.send("Kh√¥ng c√≥ k√™nh voice n√†o c√≥ ng∆∞·ªùi ch∆°i!")
        return
    await interaction.followup.send(
        "Ch·ªçn k√™nh voice ƒë·ªÉ b·∫Øt ƒë·∫ßu game:",
        view=VoiceChannelView(guild, interaction.user.id, game_states)
    )

@bot.tree.command(name="pause_game", description="T·∫°m d·ª´ng game")
async def pause_game(interaction: discord.Interaction):
    await interaction.response.defer()
    text_channel = interaction.channel
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        await interaction.followup.send("Ch∆∞a c√≥ game n√†o ƒë·ªÉ t·∫°m d·ª´ng tr√™n server n√†y!")
        return
    game_state = game_states[guild_id]
    if not game_state["is_game_running"]:
        await interaction.followup.send("Ch∆∞a c√≥ game n√†o ƒë·ªÉ t·∫°m d·ª´ng!")
        return
    if game_state["is_game_paused"]:
        await interaction.followup.send("Game ƒë√£ ƒëang t·∫°m d·ª´ng r·ªìi! D√πng !resume_game ƒë·ªÉ ti·∫øp t·ª•c.")
        return
    game_state["is_game_paused"] = True
    logger.info(f"Game paused by {interaction.user.id} on guild {guild_id}")
    await interaction.followup.send("Game ƒë√£ ƒë∆∞·ª£c t·∫°m d·ª´ng! D√πng !resume_game ƒë·ªÉ ti·∫øp t·ª•c.")

@bot.tree.command(name="resume_game", description="Ti·∫øp t·ª•c game")
async def resume_game(interaction: discord.Interaction):
    await interaction.response.defer()
    text_channel = interaction.channel
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        await interaction.followup.send("Ch∆∞a c√≥ game n√†o ƒë·ªÉ ti·∫øp t·ª•c tr√™n server n√†y!")
        return
    game_state = game_states[guild_id]
    if not game_state["is_game_running"]:
        await interaction.followup.sendd("Ch∆∞a c√≥ game n√†o ƒë·ªÉ ti·∫øp t·ª•c!")
        return
    if not game_state["is_game_paused"]:
        await interaction.followup.send("Game kh√¥ng ƒëang t·∫°m d·ª´ng! D√πng !pause_game ƒë·ªÉ t·∫°m d·ª´ng.")
        return
    game_state["is_game_paused"] = False
    logger.info(f"Game resumed by {interaction.user.id} on guild {guild_id}")
    await interaction.followup.send("Game ƒë√£ ƒë∆∞·ª£c ti·∫øp t·ª•c! Tr√≤ ch∆°i s·∫Ω ti·∫øp t·ª•c t·ª´ pha hi·ªán t·∫°i.")
    if game_state["phase"] == "morning":
        await morning_phase(interaction, game_state)
    elif game_state["phase"] == "night":
        await night_phase(interaction, game_state)
    elif game_state["phase"] == "voting":
        alive_players = await get_alive_players(interaction, game_state)
        vote_embed = discord.Embed(
            title="üó≥Ô∏è Pha B·ªè Phi·∫øu Ti·∫øp T·ª•c",
            description="Ch·ªçn ng∆∞·ªùi ƒë·ªÉ lo·∫°i trong 45 gi√¢y.",
            color=discord.Color.gold()
        )
        await game_state["text_channel"].send(embed=vote_embed, view=VoteView(alive_players, game_state, 45))
        await countdown(game_state["text_channel"], 30, "b·ªè phi·∫øu (30 gi√¢y ƒë·∫ßu)", game_state)
        await display_current_votes(interaction, game_state)
        await countdown(game_state["text_channel"], 15, "b·ªè phi·∫øu (15 gi√¢y cu·ªëi)", game_state)
        await morning_phase(interaction, game_state)

@bot.tree.command(name="reset_game", description="Kh·ªüi ƒë·ªông l·∫°i game")
async def reset_game(interaction: discord.Interaction):
    await interaction.response.defer()
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        await interaction.followup.send("Ch∆∞a c√≥ game n√†o ƒë·ªÉ reset tr√™n server n√†y!")
        return
    game_state = game_states[guild_id]
    if not game_state["is_game_running"]:
        await interaction.followup.send("Ch∆∞a c√≥ game n√†o ƒë·ªÉ reset!")
        return
    await reset_game_state(interaction, game_state)

# L·ªánh k·∫øt th√∫c game
@bot.tree.command(name="end_game", description="K·∫øt th√∫c game")
async def end_game(interaction: discord.Interaction):
    await interaction.response.defer()
    guild_id = interaction.guild.id
    text_channel = interaction.channel
    if guild_id not in game_states:
        await interaction.followup.send("Ch∆∞a c√≥ game n√†o ƒë·ªÉ k·∫øt th√∫c tr√™n server n√†y!")
        return
    game_state = game_states[guild_id]
    if not game_state["is_game_running"]:
        await interaction.followup.send("Ch∆∞a c√≥ game n√†o ƒë·ªÉ k·∫øt th√∫c!")
        return

    game_state["reset_in_progress"] = True
    error_messages = []
    
    try:
        # G·ª≠i log k·∫øt qu·∫£ game ƒë·∫øn text_channel
        text_channel = game_state.get("text_channel") or interaction.channel
        if guild_id in game_logs and text_channel:
            embed = discord.Embed(title="K·∫øt Qu·∫£ Game", color=discord.Color.blue())
            role_list = []
            for user_id, data in game_state["players"].items():
                member = game_state["member_cache"].get(user_id)
                if member:
                    status = "S·ªëng" if data["status"] in ["alive", "wounded"] else "Ch·∫øt"
                    role_list.append(f"{member.display_name}: {data['role']} ({status})")
            log_text = "\n".join(game_logs[guild_id] + ["Danh s√°ch cu·ªëi game:"] + role_list)
            if len(log_text) > 1024:
                log_text = log_text[-1024:]
            embed.add_field(name="T√¨nh tr·∫°ng", value=log_text or "Kh√¥ng c√≥ d·ªØ li·ªáu", inline=False)
            user_name = interaction.user.name
            embed.set_footer(text=f"Log ƒë∆∞·ª£c g·ª≠i b·ªüi {user_name}")
            await interaction.followup.send(embed=embed)
        elif text_channel:
            await interaction.followup.send("Kh√¥ng c√≥ d·ªØ li·ªáu n√†o ƒë∆∞·ª£c ghi l·∫°i trong game.")

        # L√†m m·ªõi member_cache
        try:
            game_state["member_cache"] = {m.id: m for m in await retry_api_call(lambda: interaction.guild.members)}
            logger.info(f"Refreshed member_cache with {len(game_state['member_cache'])} members")
        except Exception as e:
            error_messages.append(f"Kh√¥ng th·ªÉ l√†m m·ªõi danh s√°ch th√†nh vi√™n server: {str(e)}")

        # Di chuy·ªÉn ng∆∞·ªùi ch∆°i v·ªÅ k√™nh ch√≠nh v√† unmute
        main_voice_channel = bot.get_channel(game_state["voice_channel_id"])
        if main_voice_channel:
            for user_id in game_state["players"]:
                member = game_state["member_cache"].get(user_id)
                if member and member.voice and member.voice.channel:
                    try:
                        await member.move_to(main_voice_channel)
                        await member.edit(mute=False)
                    except Exception as e:
                        error_messages.append(f"Kh√¥ng th·ªÉ di chuy·ªÉn ho·∫∑c unmute {member.display_name}: {str(e)}")

        # X√≥a vai tr√≤ kh·ªèi ng∆∞·ªùi ch∆°i
        villager_role = interaction.guild.get_role(game_state["villager_role_id"])
        dead_role = interaction.guild.get_role(game_state["dead_role_id"])
        werewolf_role = interaction.guild.get_role(game_state["werewolf_role_id"])
        for user_id in game_state["players"]:
            member = game_state["member_cache"].get(user_id)
            if member:
                try:
                    if villager_role and villager_role in member.roles:
                        await member.remove_roles(villager_role)
                    if dead_role and dead_role in member.roles:
                        await member.remove_roles(dead_role)
                    if werewolf_role and werewolf_role in member.roles:
                        await member.remove_roles(werewolf_role)
                except Exception as e:
                    error_messages.append(f"Kh√¥ng th·ªÉ x√≥a vai tr√≤ kh·ªèi {member.display_name}: {str(e)}")

        # X√≥a c√°c k√™nh voice ri√™ng
        if "player_channels" in game_state:
            for channel in game_state["player_channels"].values():
                try:
                    await channel.delete()
                except Exception as e:
                    error_messages.append(f"Kh√¥ng th·ªÉ x√≥a k√™nh voice ri√™ng: {str(e)}")
            game_state["player_channels"].clear()

        # X√≥a k√™nh dead-chat v√† wolf-chat
        dead_channel = game_state.get("dead_channel")
        wolf_channel = game_state.get("wolf_channel")
        if dead_channel:
            try:
                await dead_channel.delete()
            except Exception as e:
                error_messages.append(f"Kh√¥ng th·ªÉ x√≥a dead-chat: {str(e)}")
        if wolf_channel:
            try:
                await wolf_channel.delete()
            except Exception as e:
                error_messages.append(f"Kh√¥ng th·ªÉ x√≥a wolf-chat: {str(e)}")

        # X√≥a vai tr√≤ game
        if villager_role:
            try:
                await villager_role.delete()
            except Exception as e:
                error_messages.append(f"Kh√¥ng th·ªÉ x√≥a vai tr√≤ D√¢n L√†ng: {str(e)}")
        if dead_role:
            try:
                await dead_role.delete()
            except Exception as e:
                error_messages.append(f"Kh√¥ng th·ªÉ x√≥a vai tr√≤ Ng∆∞·ªùi Ch·∫øt: {str(e)}")
        if werewolf_role:
            try:
                await werewolf_role.delete()
            except Exception as e:
                error_messages.append(f"Kh√¥ng th·ªÉ x√≥a vai tr√≤ Werewolf: {str(e)}")

        # Kh√¥i ph·ª•c quy·ªÅn k√™nh vƒÉn b·∫£n
        if text_channel:
            try:
                if text_channel.category:
                    await text_channel.edit(sync_permissions=True)
                else:
                    await text_channel.set_permissions(interaction.guild.default_role, send_messages=True)
            except Exception as e:
                error_messages.append(f"Kh√¥ng th·ªÉ kh√¥i ph·ª•c quy·ªÅn k√™nh vƒÉn b·∫£n: {str(e)}")

        # Bot r·ªùi k√™nh voice
        if game_state["voice_connection"] and game_state["voice_connection"].is_connected():
            try:
                await game_state["voice_connection"].disconnect()
            except Exception as e:
                error_messages.append(f"Kh√¥ng th·ªÉ ng·∫Øt k·∫øt n·ªëi bot kh·ªèi k√™nh voice: {str(e)}")
            game_state["voice_connection"] = None

        # Reset game_state
        game_state["players"].clear()
        game_state["is_game_running"] = False
        game_state["is_game_paused"] = False
        game_state["phase"] = "none"
        game_state["is_first_day"] = True
        game_state["voice_channel_id"] = None
        game_state["guild_id"] = None
        game_state["protected_player_id"] = None
        game_state["previous_protected_player_id"] = None
        game_state["werewolf_target_id"] = None
        game_state["witch_target_id"] = None
        game_state["witch_action"] = None
        game_state["witch_has_power"] = True
        game_state["hunter_target_id"] = None
        game_state["hunter_has_power"] = True
        game_state["votes"] = {}
        game_state["text_channel"] = None
        game_state["wolf_channel"] = None
        game_state["dead_channel"] = None
        game_state["illusionist_scanned"] = False
        game_state["illusionist_effect_active"] = False
        game_state["illusionist_effect_night"] = 0
        game_state["temp_player_count"] = 0
        game_state["temp_players"] = []
        game_state["temp_roles"] = {role: 0 for role in ROLES}
        game_state["temp_admin_id"] = None
        game_state["reset_in_progress"] = False
        game_state["villager_role_id"] = None
        game_state["dead_role_id"] = None
        game_state["werewolf_role_id"] = None
        game_state["member_cache"].clear()
        game_state["night_count"] = 0
        game_state["demon_werewolf_activated"] = False
        game_state["demon_werewolf_cursed_player"] = None
        game_state["demon_werewolf_has_cursed"] = False
        game_state["demon_werewolf_cursed_this_night"] = False
        game_state["assassin_werewolf_has_acted"] = False
        game_state["assassin_werewolf_target_id"] = None
        game_state["assassin_werewolf_role_guess"] = None
        game_state["detective_has_used_power"] = False
        game_state["detective_target1_id"] = None
        game_state["detective_target2_id"] = None
        game_logs[guild_id].clear()

        # G·ª≠i ph·∫£n h·ªìi duy nh·∫•t
        if error_messages:
            error_text = "\n".join(error_messages)
            await interaction.followup.send(f"Game ƒë√£ ƒë∆∞·ª£c k·∫øt th√∫c v·ªõi m·ªôt s·ªë l·ªói:\n{error_text}")
        else:
            await interaction.followup.send("Game ƒë√£ ƒë∆∞·ª£c k·∫øt th√∫c th√†nh c√¥ng! T·∫•t c·∫£ tr·∫°ng th√°i ƒë√£ ƒë∆∞·ª£c kh√¥i ph·ª•c.")
    finally:
        game_state["reset_in_progress"] = False

@bot.tree.command(name="status", description="T√¨nh tr·∫°ng game tr√™n server")
async def status(interaction: discord.Interaction):
    await interaction.response.defer()
    guild_id = interaction.guild.id
    text_channel = interaction.channel
    if guild_id not in game_states:
        embed = discord.Embed(
            title="Tr·∫°ng th√°i Bot Ma S√≥i",
            description="Ch∆∞a c√≥ game n√†o ƒëang ch·∫°y tr√™n server n√†y.",
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed)
        return
    game_state = game_states[guild_id]
    embed = discord.Embed(title="Tr·∫°ng th√°i Bot Ma S√≥i", color=discord.Color.green())
    embed.add_field(name="Game ƒëang ch·∫°y", value=str(game_state["is_game_running"]), inline=False)
    embed.add_field(name="Game ƒëang t·∫°m d·ª´ng", value=str(game_state["is_game_paused"]), inline=False)
    embed.add_field(name="S·ªë ng∆∞·ªùi ch∆°i", value=str(len(game_state["players"])), inline=False)
    embed.add_field(name="Pha hi·ªán t·∫°i", value=game_state["phase"], inline=False)
    await interaction.followup.send(embed=embed)
  
@bot.tree.command(name="leaderboard", description="Hi·ªÉn th·ªã b·∫£ng vinh danh")
async def leaderboard(interaction: discord.Interaction):
    await interaction.response.defer()
    guild_id = interaction.guild.id
    try:
        db = get_db_connection()
        cursor = db.cursor(dictionary=True)

        # ƒê·∫£m b·∫£o b·∫£ng t·ªìn t·∫°i
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS leaderboard (
                id INT AUTO_INCREMENT PRIMARY KEY,
                guild_id BIGINT NOT NULL,
                player_id BIGINT NOT NULL,
                player_name VARCHAR(255) NOT NULL,
                score INT DEFAULT 0,
                UNIQUE KEY unique_guild_player (guild_id, player_id)
            )
        """)

        # L·∫•y top 10 ng∆∞·ªùi ch∆°i
        cursor.execute("""
            SELECT player_name, score FROM leaderboard
            WHERE guild_id = %s
            ORDER BY score DESC
            LIMIT 10
        """, (guild_id,))
        records = cursor.fetchall()

        if not records:
            await interaction.followup.send("Ch∆∞a c√≥ d·ªØ li·ªáu leaderboard cho server n√†y.")
            return

        embed = discord.Embed(
            title=f"üèÜ Leaderboard - Top 10 (Server: {interaction.guild.name})",
            color=discord.Color.gold()
        )
        for i, record in enumerate(records, start=1):
            embed.add_field(name=f"{i}. {record['player_name']}", value=f"ƒêi·ªÉm: {record['score']}", inline=False)

        await interaction.followup.send(embed=embed)

    except mysql.connector.Error as err:
        logger.error(f"MySQL Error fetching leaderboard for guild {guild_id}: {err}")
        await interaction.followup.send(f"L·ªói MySQL khi l·∫•y leaderboard: {err}")
    except Exception as e:
        logger.error(f"Error fetching leaderboard for guild {guild_id}: {e}")
        await interaction.followup.send(f"L·ªói khi l·∫•y leaderboard: {e}")
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'db' in locals():
            db.close()

@bot.tree.command(name="check_mute", description="Ki·ªÉm tra t√¨nh tr·∫°ng mic")
async def check_mute(interaction: discord.Interaction):
    await interaction.response.defer()
    text_channel = interaction.channel
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        await interaction.followup.send("Ch∆∞a c√≥ game n√†o ƒëang ch·∫°y tr√™n server n√†y!")
        return
    game_state = game_states[guild_id]
    muted_players = []
    for user_id in game_state["players"]:
        member = game_state["member_cache"].get(user_id)
        if member and member.voice and member.voice.mute:
            muted_players.append(f"{member.display_name} (ID: {member.id})")
    if muted_players:
        await interaction.followup.send(f"Ng∆∞·ªùi ch∆°i ƒëang b·ªã mute: {', '.join(muted_players)}")
    else:
        await interaction.followup.send("Kh√¥ng c√≥ ng∆∞·ªùi ch∆°i n√†o ƒëang b·ªã mute.")

@bot.tree.command(name="check_player", description="Ki·ªÉm tra ng∆∞·ªùi ch∆°i")
async def check_player(interaction: discord.Interaction):
    await interaction.response.defer()
    guild_id = interaction.guild.id
    if guild_id not in game_states:
        await interaction.followup.send("Ch∆∞a c√≥ game n√†o ƒëang ch·∫°y tr√™n server n√†y!")
        return
    game_state = game_states[guild_id]
    if player_id not in game_state["players"]:
        await interaction.followup.send("Ng∆∞·ªùi ch∆°i kh√¥ng c√≥ trong game!")
        return
    player_data = game_state["players"][player_id]
    member = game_state["member_cache"].get(player_id)
    if member:
        await interaction.followup.send(f"Ng∆∞·ªùi ch∆°i {member.display_name} (ID: {player_id})\n"
                       f"Vai tr√≤: {player_data['role']}\n"
                       f"Tr·∫°ng th√°i: {player_data['status']}\n"
                       f"Muted: {player_data['muted']}")
    else:
        await interaction.followup.send(f"Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i v·ªõi ID {player_id}")

# Kh·ªüi ƒë·ªông bot
if __name__ == "__main__":
    print("Starting script...")
    load_dotenv()
    db = get_db_connection()
    print("K·∫øt n·ªëi MySQL th√†nh c√¥ng!")
    db.close()
    token = os.getenv("TOKEN")
    print(f"Token: {token}")
    if not token:
        print("Error: TOKEN not found in .env file")
        sys.exit(1)
    print("Running bot...")
    try:
        bot.run(token)
    except Exception as e:
        print(f"Error starting bot: {str(e)}")
        logger.error(f"Error starting bot: {str(e)}")
        sys.exit(1)
